기존 백엔드는 로컬의 인텔리제이에서 직접 jar를 빌드하고 실행시키는 방식으로 이루어졌다.
이 방식은 레디스, DB와 같은 외부 어플리케이션에 의존성이 큰 주제에 포트도 직접 수정해야 하기 때문에 활용이 제한적이다.

따라서 백엔드를 개선하여 보다 유연하게 사용할 수 있도록 할 것이다.

# 개선 내용

총 3가지의 주요 단계로 이루어져있다.

- 1. Dockerfile 빌드
	- 논리적 격리 및 Dockerhub 배포로 환경 세팅 간소화
	- Github-actions를 이용한 Dockerhub CI
- 2. 매개변수를 통해 연결되는 포트 수정할 수 있도록 유연성 확보
	- docker-compose에서도 활용 가능.
- 2.5. (추가사항) Redis-Cluster 적용하기
- 3. Github-actions를 통한 CI/CD 파이프라인 구축으로 테스트 환경에 배포하기

---

# 개선하기

## 1. Dockerfile 이미지 빌드

Dockerfile을 통해 이미지를 빌드해본다.
아직 매개변수를 설정해주는 단계가 아니기 때문에 간단하게 Jar를 빌드하는 것만 작성할 것이다.

*Dockerfile*
```dockerfile
FROM gradle:8.9-jdk21 AS builder  
WORKDIR /app  
COPY . .  
RUN gradle bootJar --no-daemon  
  
FROM eclipse-temurin:21-jdk  
WORKDIR /app  
COPY --from=builder /app/build/libs/*.jar app.jar  
ENTRYPOINT ["java", "-jar", "app.jar"]
```

이제 이것을 빌드하고 Dockerhub에 올려주면 로컬이 아닌 외부에서도 간편하게 백엔드 환경을 가져올 수 있다.

### Github-actions Dockerhub CI

이제 외부에서도 백엔드 환경을 이용하기 편해졌다.
하지만 매번 커밋하고 변경점을 적용할 때마다 Dockerfile을 빌드해야 하는 것은 마음에 들지 않는다
그러니 CI(Continuous Intergration, 지속적 통합)를 통해 자동으로 빌드시켜주겠다.
> 코드 통합 및 자동 검증이 이루어저야 CI라고 할 수 있다.
> 그러나 여기서는 코드 통합(이미지 배포용 브랜치)과 빌드(도커 이미지 빌드)만 존재하기 때문에 반쪽짜리 CI인 걸 인지하자.
> 원래 테스트 실행과 코드 정적 분석이 함께 이루어져야 한다.

CI/CD는 보통 Jenkins 또는 Github Actions를 통해 이루어진다.
여기선 Github Actions를 사용하였다.

Jenkins를 쓰지 않는 이유는 다음과 같다.
- 비용
jenkins 사용 시 파이프라인을 관리할 aws 인스턴스 하나가 더 필요하다.
그런 비용을 감수할 생각이 없다.
- 학습 곡선
본인은 jenkins를 사용해본 적이 없어서 학습 곡선이 존재한다. 속도가 생명인 이 테스트에선 치명적이다.
- 구현 속도
Github Actions가 구현이 더 간단하기 때문에 빠르게 구현할 수 있다.
물론 제대로 된 CI/CD 파이프라인이 생기고 테스트 단계가 추가된다던지 복잡한 단계가 생기면 jenkins가 더 낫다. 

GithubAction을 위해 만들어진 yml은 다음과 같다.
> github actions 관련 정보는 [[github-skills]]를 참고하자.

```yaml
name: Build and Push Docker Image
  
on:  
  push:  
    branches: [ scenario/* ]  
  workflow_dispatch:  
  
jobs:  
  build:  
    runs-on: ubuntu-latest  
  
    steps:  
      - name: Checkout repository  
        uses: actions/checkout@v4  
  
      - name: Set up JDK  
        uses: actions/setup-java@v4  
        with:  
          java-version: '21'  
          distribution: 'temurin'  
  
      - name: Grant execute permission for Gradle wrapper  
        run: chmod +x gradlew  
  
      - name: Build JAR with Gradle  
        run: ./gradlew bootJar  
  
      - name: Log in to DockerHub  
        uses: docker/login-action@v3  
        with:  
          username: ${{ secrets.DOCKER_USERNAME }}  
          password: ${{ secrets.DOCKER_PASSWORD }}  
  
      - name: Set safe image tag  
        id: vars  
        run: |  
          SAFE_TAG=$(echo "${GITHUB_REF_NAME}" | tr '/' '-')  
          echo "SAFE_TAG=$SAFE_TAG" >> $GITHUB_OUTPUT  
  
      - name: Build and Push Docker image  
        uses: docker/build-push-action@v6  
        with:  
          context: .  
          push: true  
          tags: |  
            ${{ secrets.DOCKER_USERNAME }}/spring_batch_instruction:${{ steps.vars.outputs.SAFE_TAG }}  
            ${{ secrets.DOCKER_USERNAME }}/spring_batch_instruction:latest
```

여기에 CD(Continuous Deploy)를 수행하는 job을 추가해줄 수도 있다.
해당 작업은 [[4. EC2-backend-api-build (writing)]]에서 해줄 것이다.

---

## 2. Dockerfile 매개변수 추가하기

레디스를 차치하고서, 사용자가 이미 빌드된 이미지를 사용할 경우 DB나 다른 어플리케이션과 관련된 ip/포트가 고정되어 있다면 사용자는 이미지에 정해진 구성에 맞춰 시스템을 구성해야 한다.
즉, 이미지에 시스템이 의존적이게 되는 상황이다.

이런 상황을 피하기 위해 Dockerfile에서 매개변수로 환경 설정을 넣어주는 방식을 이용했다.

[참고1](https://wooono.tistory.com/670) - 도커 환경변수 전달
[참고2](https://imksh.com/94) - 스프링부트(2.2) 환경변수 전달
[참고3](https://spring.io/guides/gs/spring-boot-docker) - Spring io - 스프링 부트 with 도커

직접 Dockerfile에 ARGS를 선언하여 추가하는 방법도 있지만, 여기서는 간단하게 Profiles를 설정하는 식으로 만들어주었다.

Dockerfile을 설정하지 않아도 스프링부트 기반 프로젝트에서는 자동으로 설정할 수 있으며, 아래와 같이 -e를 통해 활성화할 프로필을 설정해줄 수 있다.
`docker run -e "SPRING_PROFILES_ACTIVE=dev" -p 8080:8080 -t springio/gs-spring-boot-docker`

구현이 간단하며, Dockerfile이나 프로젝트를 추가로 건드릴 필요가 없다!
Github 리포지토리 내부에서 environments만 추가해주면 되므로 사실 이 방법을 사용할 경우 우리가 할 일은 없다.

계속 진행해주면 된다. 간단한 구현이기 때문에 이런 것들은 properties 내에서 해결할 수 있다. 도망치는 게 아니다.


---
## 2.5 Redis Cluster 적용하기

Redis의 단점을 보완하기 위해선 클러스터링이 필수적이다.
따라서 현재 사용하고 있는 Redis를 클러스터링해서 적용해줄 것이다.
그러기 위해선 백엔드에서도 변경이 필요하다.

Spring boot에 Redis-Cluster를 적용하도록 하자.
이번 단계에서 캐싱도 함께 적용할 것이다.

클러스터이기에 단순히 리스닝 포트 하나만 만들고 이어주면 될 것 같지만... 그렇지 않다.

[[0.redis-clustering]]를 참고하여, redis-cluster를 사용하기 위해 도커 이미지를 사용했다는 점을 생각해보자. 이 포트들을 직접 백엔드에 등록시켜 줘야 한다.

### Redis Cluster setting

본래 RedisConfig 클래스를 만들어 직접 설정해주려 하였다.

```
@Getter  
@RequiredArgsConstructor  
@Configuration  
@ConfigurationProperties(prefix = "redis.cluster")  
public class RedisConfig {  
  private String nodes;  // "ip1:port,ip2:port,ip3:port"  
  private int maxRedirects;  
  
  @Bean  
  public RedisConnectionFactory redisConnectionFactory() {  
    // 1) 콤마로 분리해서 각 노드를 리스트로 변환  
    List<String> nodeList = Arrays.stream(nodes.split(","))  
            .map(String::trim)  
            .toList();  
  
    // 2) Redis 클러스터 설정 생성  
    RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration(nodeList);  
    clusterConfig.setMaxRedirects(maxRedirects);  
  
    // 3) 커넥션 팩토리 반환  
    return new LettuceConnectionFactory(clusterConfig);  
  }  
  
  
  // todo: 직렬화 취약점 보완 필요. json 직렬화 필요함.  
//  @Bean  
//  public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {  
//    RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();  
//    redisTemplate.setConnectionFactory(redisConnectionFactory);  
//    redisTemplate.setKeySerializer(new StringRedisSerializer());  
//    redisTemplate.setValueSerializer(new StringRedisSerializer());  
//    return redisTemplate;  
//  }  
}
```

그러나 현재 redis를 구현하기 위해선 이렇게 명시하지 않고도 properties로 빠르게 설정하는 법이 잘 나와있다.
위와 같이 힘들게 설정하지 않아도 이런 식으로 설정해줄 수 있다.

```properties
spring.data.redis.cluster.nodes=\  
  localhost:6479,\  
  localhost:6480,\  
  localhost:6481,\  
  localhost:6482,\  
  localhost:6483,\  
  localhost:6484  
spring.data.redis.cluster.max-redirects=3
```
놀랍게도, 위와 아래는 같은 설정을 한다.

여담으로로 yaml 구조에서는 propreties보다 더 가시성 좋게 설정할 수도 있었다.
```yaml
spring:
  data:
	redis:
	  cluster:
	    nodes:
	      - localhost:6479
	      - localhost:6480
	      - localhost:6481
	      - localhost:6482
	      - localhost:6483
	      - localhost:6484
	    max-redirects: 3
```
indent를 신경써야 하는 점이 불편하지만 이런 점에서는 더 좋은 것 같기도 하다.

### Caching Implement

본래 레디스를 위한 캐싱 구현을 작성하려고 하였으나, 다른 캐싱 방법 또한 구현하여 성능을 비교해야 한다.
3가지의 구현이 필요하고 내용이 길어지기 때문에 [[1.2.5.caching-implements]]로 분리하였다.

---

### 3. Github-actions workflow CI/CD


