단일 레디스는 성능이 매우 떨어진다.

단일 레디스는 가용성이 매우 심각하게 떨어지며 트래픽 대응도 약하다.
따라서 레디스 클러스터를 이용해 가용성을 높여볼 것이다.

1. 샤딩을 이용해 가용성을 높인다.
2. master-slave(또는 replica) 구조를 이용해 spof를 낮춘다.
	1. 물론 클러스터 자체가 날아가면 그것도 spof이긴 하다...!
[[3. EC2-Redis-Cluster (writing)]]

Redis Cluster 구축하기

참고해볼 것.
https://co-de.tistory.com/24
https://liltdevs.tistory.com/208
https://velog.io/@tngusqkr1/Redis-cluster-%EC%84%A4%EC%A0%95-1

[참고자료](https://velog.io/@pjh612/Docker-compose%EB%A1%9C-Redis-cluster-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-%EB%8F%84%EC%BB%A4-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%A0%91%EC%86%8D-%ED%8A%B8%EB%9F%AC%EB%B8%94-%EC%8A%88%ED%8C%85)
docker-compose를 활용해 redis cluster를 구축했다.
위 참고자료에서는 docker-network를 거치지 않고 호스트 네트워크와 도커 네트워크를 구분지었다고 한다...
호스트 ip 정보를 이용해 그냥 직접 연결해버린 것 같다.

여기선 그냥 docker networking 쓰겠다.
더 알아보니, redis-cluster 이미지의 경우 grokzen이랑 bitnami 방식으로 갈린다.
grokzen은 자동으로 한 컨테이너 안에서 여러 개를 구성해주는 것이고, bitnami는 각 클러스터 노드를 컨테이너 단위로 분리하여 작동한다.

참고로 레디스 클러스터링해도 결국 SPOF인 건 변함없다...!

먼저 docker-compose.yml부터 보자. (그 긴거)
```
networks:
  redis-cluster-compose:
    driver: bridge

services:
  redis-node-1:
    container_name: redis-node-1
    image: redis:latest
    ports:
      - 6479:6379
      - 16479:16379
    networks:
      - redis-cluster-compose
    hostname: redis-node-1
    volumes:
      - ./data/6479:/redis
    command: redis-server /redis/redis.conf
  redis-node-2:
    container_name: redis-node-2
    image: redis:latest
    ports:
      - 6480:6379
      - 16480:16379
    networks:
      - redis-cluster-compose
    hostname: redis-node-2
    volumes:
      - ./data/6480:/redis
    command: redis-server /redis/redis.conf

  redis-node-3:
    container_name: redis-node-3
    image: redis:latest
    ports:
      - 6481:6379
      - 16481:16379
    networks:
      - redis-cluster-compose
    hostname: redis-node-3
    volumes:
      - ./data/6481:/redis
    command: redis-server /redis/redis.conf

  redis-node-4:
    container_name: redis-node-4
    image: redis:latest
    ports:
      - 6482:6379
      - 16482:16379
    networks:
      - redis-cluster-compose
    hostname: redis-node-4
    volumes:
      - ./data/6482:/redis
    command: redis-server /redis/redis.conf

  redis-node-5:
    container_name: redis-node-5
    image: redis:latest
    ports:
      - 6483:6379
      - 16483:16379
    networks:
      - redis-cluster-compose
    hostname: redis-node-5
    volumes:
      - ./data/6483:/redis
    command: redis-server /redis/redis.conf

  redis-node-6:
    container_name: redis-node-6
    image: redis:latest
    ports:
      - 6484:6379
      - 16484:16379
    networks:
      - redis-cluster-compose
    hostname: redis-node-6
    volumes:
      - ./data/6484:/redis
    command: redis-server /redis/redis.conf

  redis-cluster-creator:
    image: redis:latest
    ports:
      - 6999:6999
    networks:
      - redis-cluster-compose
    command: redis-cli -p 6379 -a password --cluster create redis-node-1:6479 redis-node-2:6480 redis-node-3:6481 redis-node-4:6482 redis-node-5:6483 redis-node-6:6484 --cluster-replicas 1 --cluster-yes
    depends_on:
      - redis-node-1
      - redis-node-2
      - redis-node-3
      - redis-node-4
      - redis-node-5
      - redis-node-6

  redis-insight:
    image: redislabs/redisinsight
    ports:
      - 8001:8001
    networks:
      - redis-cluster-compose
    volumes:
      - ./data/redisinsight:/db
    depends_on:
      - redis-cluster-creator
```

짜잔! 이것의 구조는 아래와 같다.
![[redis-clustering-1.png]]

포트는 다르지만, 3개의 샤딩으로 나누고 그 아래 slave 노드가 각각 하나씩 있는 구조이다. 샤딩을 통해 가용성을 높이고 master-slave 노드로 spof를 없앤다. (물론 앞서 말했듯이, 서버 이중화 안 되어있으면 클러스터 그룹 자체도 spof이다...!)

redis.conf
귀찮아서 6379와 16379로 통일시켜줬다.
이쪽은 잘 모르니 gpt로 일단 보일러 플레이트 만들고 참고자료를 추가로 찾고있다...
```
# -------------------------------
# 기본 네트워크 설정
# -------------------------------
bind 0.0.0.0
protected-mode no

# -------------------------------
# 포트 설정
# -------------------------------
# 노드별 고유 포트 (예: 6479, 6480 등)
port 6379                     

# -------------------------------
# 클러스터 모드 설정
# -------------------------------
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000

# 클러스터 내부 통신용 포트 (data port + 10000)
cluster-announce-port 6379
cluster-announce-bus-port 16379

# 클러스터에서 다른 노드와 통신할 때 알려줄 IP
cluster-announce-ip redis-node-1

# -------------------------------
# 지속성 (옵션)
# -------------------------------
appendonly yes
appendfsync everysec
```

이슈가 생겼었는데, conf 파일에서 `#`를 한 라인에 붙여서 사용한 게 원인이었다.
```
settings=something   # like this.
```
이런 경우 설정을 인식하지 못하고 문법이 틀렸다고 출력하며 실행되지 않는다. 가끔씩 무지성 복붙하거나 문법 까먹는 경우 이런 경우가 생길 수 있으니 수정해서 해결해주자.

여기선 Windows 환경을 사용했고, docker gui를 이용했기 때문에 기본적으로 docker와 docker-compose가 설치되어 있었다. 환경 설정은 mac이나 리눅스의 경우 상이할 수 있으니 다시 한 번 확인해주자.

```bash
cd d:\your\path\tocompose
docker-compose up -d
```
docker-compose.yml 위치에서 -d로 백그라운드에서 실행해주었다.
더 많은 옵션은 [공식 문서](https://docs.docker.com/reference/cli/docker/compose/up/)를 참고하자.

