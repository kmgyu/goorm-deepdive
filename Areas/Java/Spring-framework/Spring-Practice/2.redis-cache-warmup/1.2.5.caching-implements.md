> 여기서는 캐싱을 구현할 것이다.
> 총 3가지의 구현 방법을 알아본다.

# 기초 기능 구현

캐싱을 위한 기능부터 구현해 보자.

기능 이름은 board로, 간단하게 게시판 내용을 보여주는 것이다.

아래는 캐싱을 위한 코드 스니펫의 일부분이다.
```java
// BoardService
@Cacheable("board")  
public BoardResponseDTO findById(Long id) {  
  Board board = boardRepository.findById(id).orElse(null);  
  
  if  (board == null) {  
    return null;  
  }  
  
  return BoardResponseDTO.builder()  
          .id(board.getId())  
          .title(board.getTitle())  
          .content(board.getContent())  
          .build();  
}
```

캐싱을 위한 데이터의 경우 배치 잡을 이용해 처리했다.
핸들러 메서드를 통해 트리거링하도록 하여 잘못 건드려서 실행할 때마다 작업이 생성되는 불상사를 막았다.
단일 board를 생성하는 핸들러 메서드는 구현하지 않았으니 참고.

> #todo 추후 로커스트를 통해 성능 측정 시 DB I/O도 고려를 해야 할까?
> 하하 돈이 땅에서 나오나 보구나
> 근데 궁금하긴 함. aws rds도 마이그레이션으로 초기 데이터만 추가해주자.

## 추가 세팅

새 기능 추가 시 기존 데이터와 충돌이 생길 수 있다.

본인은 이미 사용자 테이블에 1만 개의 데이터가 존재했기 때문에 한번 더 배치 잡을 실행시키고 싶지 않았다.

```properties
spring.jpa.hibernate.ddl-auto=create-only
```
해당 설정을 사용하여 기존 테이블 생성 시 충돌을 발생시켜 막고, 없는 테이블만 생성시켜주자.


---

# 캐싱 구현

이 프로젝트에서는 [공식문서](https://docs.spring.io/spring-boot/reference/io/caching.html)를 바탕으로 구현하였다.
기본적으로는 9가지의 캐싱 방식을 지원하나, 3가지의 방법만을 알아본다.

#todo JCache를 넣을까 말까 xml 쓰는데 쓰기 싫다.

1. 스프링 제공 캐시 - ConcurrentHashMap
만약 아무 설정도 하지 않을 경우, 콜렉션 중 하나인 ConcurrentHashMap을 사용하게 된다.
2. 스프링 제공 캐시 - Caffeine
ConcurrentHashMap을 제외한 Cache Provider 중 가장 간단한 방법으로, properties/yaml으로 설정해줄 수 있다.
3. 레디스를 이용한 캐시
외부 캐시 저장소 중 하나이며, 공식 문서에서도 소개되는 방법 중 하나이다.

## 1. ConcurrentHashMap

참고자료 : [java se8 공식문서](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html)
> "*Java ConcurrentHashMap은 진짜 유명한 콜렉션임*"

ConcurrentHashMap은 이름대로 thread-safe한 HashMap이다.
