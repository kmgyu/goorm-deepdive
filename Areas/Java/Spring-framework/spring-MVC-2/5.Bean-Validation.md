### Bean Validation

검증 로직을 모든 프로젝트에 적용할 수 있게 공통화 및 표준화 한 것.

@Range같은 것은 Validator에서만 검증 가능하다?

---

⇒ `implementation 'org.springframework.boot:spring-boot-starter-validation` 을 의존성에 추가하여 **`Jakarta Bean Validation`** 라이브러리를 사용하는 방법

⇒ 인터페이스로 javax.validation을 사용하고 구현체로 대부분 hibernate를 사용한다.

![[spring-mvc2-BeanValidation.png]]

```java
@Data
public class Item {

    private Long id;

    @NotBlank
    private String itemName;

    @NotNull
    @Range(min = 1000, max = 1000000)
    private Integer price;

    @NotNull
    @Max(9999)
    private Integer quantity;

    public Item() {
    }

    public Item(String itemName, Integer price, Integer quantity) {
        this.itemName = itemName;
        this.price = price;
        this.quantity = quantity;
    }
}
```

- **검증** **애노테이션**
    - @NotBlank : 빈값 + 공백만 있는 경우를 허용하지 않는다.
    - @NotNull : `null` 을 허용하지 않는다.
    - @Range(min = 1000, max = 1000000) : 범위 안의 값이어야 한다.
    - @Max(9999) : 최대 9999까지만 허용한다.

> 사용법

⇒ 검증기 생성

```java
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();
```

⇒ 엔티티에 값 주입

```java
Item item = new Item();
item.setItemName(" ");
item.setPrice(0);
item.setQuantity(10000);
```

⇒ 검증기에 엔티티 주입

```java
Set<ConstraintViolation<Item>> violations = validator.validate(item);
```

⇒ 결과 확인

```java
for (ConstraintViolation<Item> violation : violations) {
    System.out.println("violation: " + violation);
    System.out.println("violation: " + violation.getMessage());
}
```

⇒ 추후 스프링에서 해당 코드를 관리해준다. 지금은 알고만 넘어가자

```
violation: ConstraintViolationImpl{interpolatedMessage='공백일 수 없습니다', propertyPath=itemName, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.NotBlank.message}'}
violation: 공백일 수 없습니다
violation: ConstraintViolationImpl{interpolatedMessage='1000에서 1000000 사이여야 합니다', propertyPath=price, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{org.hibernate.validator.constraints.Range.message}'}
violation: 1000에서 1000000 사이여야 합니다
violation: ConstraintViolationImpl{interpolatedMessage='9999 이하여야 합니다', propertyPath=quantity, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.Max.message}'}
violation: 9999 이하여야 합니다
```

- 어느 코드에서 어떤 검증이 통과하지 못하였는지 나온다.
- 메세지로 출력하면 좀 더 알아보기 쉬운 내용으로 나온다.

⇒ JPA 사용방식

```java
Hibernate + Bean Validation 조합에서는 EntityManager.persist() 또는 merge() 할 때 검증을 수행
```

```java
•	hibernate.validator.apply_to_ddl=true
•	javax.persistence.validation.mode=auto
```

> 동작

⇒ `implementation 'org.springframework.boot:spring-boot-starter-validation` 해당 라이브러리를 추가하면 스프링이 자동으로 Bean Validator를 통합한다.

- `LocalValidatorFactoryBean`을 글로벌 인증기로 사용하며 이때 이 인증기가 어노테이션(`@Validated`)을 확인하여 검증을 한다.
- 단, 직접 등록한 인증기가 있다면 자동으로 통합되지 않는다.

⇒ 스프링에 의존하지 않고 자바 표준을 사용하고 싶다면 `@Valid` 를 사용하면 된다.

### **검증** **순서**

1. @ModelAttribute 각각의 필드에 타입 변환 시도
2. 성공하면 다음으로
3. 실패하면 typeMismatch로 FieldError 추가
4. Validator 적용

⇒ 즉, 바인딩이 안되면 검증을 안하고 오류를 반환한다.

⇒ 바인딩 성공한 필드에 한해서 검증 수행

> groups

⇒ 등록과 수정에 있어서 검증하는 조건이 다른 경우라면, 즉 요구사항이 다르다면 어떻게 조건을 걸어야 할까?

```java
@Data
public class Item {

    private Long id;

    @NotBlank
    private String itemName;

    @NotNull
    @Range(min = 1000, max = 1000000)
    private Integer price;

    @NotNull
    @Max(value = 9999)
    private Integer quantity;

    public Item() {
    }

    public Item(String itemName, Integer price, Integer quantity) {
        this.itemName = itemName;
        this.price = price;
        this.quantity = quantity;
    }
}
```

- 기존 엔티티

⇒ 만약 수정시에는 id값이 필수적으로 필요하며, 수정시 수량 제한을 걸지 않는 경우라면?

⇒ 현재는 하나의 엔티티에 정의된 어노테이션을 토대로 검증을 진행중이라 일관된 검증 절차를 따라야만 한다.

```java
// 따로 구현해주진 않는다.
public interface UpdateCheck {}

public interface SaveCheck {}
```
인터페이스를 만들어 분리해줄 수 있다.

```java
@Data
public class Item {

    @NotNull(groups = UpdateCheck.class)
    private Long id;

    @NotBlank(groups = {SaveCheck.class, UpdateCheck.class})
    private String itemName;

    @NotNull(groups = {SaveCheck.class, UpdateCheck.class})
    @Range(min = 1000, max = 1000000, groups = {SaveCheck.class, UpdateCheck.class})
    private Integer price;

    @NotNull(groups = {SaveCheck.class, UpdateCheck.class})
    @Max(value = 9999, groups = {SaveCheck.class})
    private Integer quantity;

    public Item() {
    }

    public Item(String itemName, Integer price, Integer quantity) {
        this.itemName = itemName;
        this.price = price;
        this.quantity = quantity;
    }
}
```

```java
 @PostMapping("/add")
    public String addItem2(@Validated(SaveCheck.class) @ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes)
    
 @PostMapping("/{itemId}/edit")
    public String editV2(@PathVariable Long itemId, @Validated(UpdateCheck.class) @ModelAttribute Item item, BindingResult bindingResult)
```

⇒ `@Validated`에 검증할 조건을 달아서 선택적으로 적용
`@Valid`는 groups 기능 없음.

⇒ 이제 선택적인 검증이 가능하지만, 코드가 많이 더러워진다. 그래서 실무에서 잘 쓰이진 않음.



> 방법 2. form 전송객체

⇒ 좀 더 간결하게 데이터를 주고 받을 수 있는 객체를 고안한 방법

groups를 사용하지 않는 이유 2
등록 시 폼에서 전달하는 데이터가 도메인 객체와 딱 맞지 않기 때문. 약관 정보와 같은 수많은 부가 데이터가 존재...
그래서 직접 전달받는 것이 아니라 복잡한 폼의 데이터를 컨트롤러까지 전달할 별도 객체를 만들어 전달하게 된다. 이것을 통해 컨트롤러에서 폼 데이터를 전달 받고, 이후 컨트롤러에서 필요한 데이터 사용해 도메인 객체를 생성한다.

```java
HTML Form -> ItemSaveForm -> Controller -> Item 생성 -> Repository
```

- 다음의 과정으로 데이터를 다루게 된다.

```java
@Data
public class ItemSaveForm {

    @NotBlank
    private String itemName;

    @NotNull
    @Range(min = 1000, max = 1000000)
    private Integer price;

    @NotNull
    @Max(value = 9999)
    private Integer quantity;
}
```

```java
@Data
public class ItemUpdateForm {

    @NotNull
    private Long id;

    @NotBlank
    private String itemName;

    @NotNull
    @Range(min = 1000, max = 1000000)
    private Integer price;

    private Integer quantity;
}
```

```java
@PostMapping("/add")
public String addItem(@Validated @ModelAttribute("item") ItemSaveForm form, BindingResult bindingResult, RedirectAttributes redirectAttributes)
    
Item item = new Item();
item.setItemName(form.getItemName());
item.setPrice(form.getPrice());
item.setQuantity(form.getQuantity());

Item savedItem = itemRepository.save(item);
```

⇒ 바인딩할 객체를 골라 사용하고 저장시에는 item 객체에 맞게 변형하여 저장

```java
@Data
public class Item {

    private Long id;

    private String itemName;

    private Integer price;

    private Integer quantity;

    public Item() {
    }

    public Item(String itemName, Integer price, Integer quantity) {
        this.itemName = itemName;
        this.price = price;
        this.quantity = quantity;
    }
}
```

⇒ 더 이상 엔티티 자체에 검증을 하는 것이 아닌 로직의 단계나 조건에 따라 다르게 검증을 진행한다.

---


Object Error

DTO에서 `@ScriptAssert()`를 사용해야 한다.

예시
```
@ScriptAssert(lang = "javascript", script = "_this.price * _this.quantity >= 10000", message = "총합이 10000원 넘게 입력해주세요")
```

메시지 코드
ScriptAssert.item, ScriptAssert

실무에서는 검증 기능이 해당 객체 범위를 넘어서는 경우도 종종 등장

따라서 오브젝트 오류(글로벌 오류)의 경우 @ScriptAssert을 억지로 사용하는 것보다는 오브젝트 오류 관련 부분만 직접 자바 코드로 작성되는 것이 권장된다.
기능이 약함.

```
item.getPrice != null && item.getQuantity() != null
```
이런 식으로 자바 코드로 검증하는 것이 더 낫다고 한다.


---

@RequestBody에도 BeanValidation 적용 가능.
복기해보자면 Json body 같은 API에서 자주 쓰는 형태

```java
// parameter
@RequestBody @Validated ItemSaveForm form, BindingResult bindingResult
```

잘못된 입력 시 JSON 파싱 오류 발생.
컨트롤러 호출이 되지 않는다.

form 객체로 만들어야 하는 데 도중에 오류가 생겨 폼으로 들어오지 못한다.
예외가 터져버리게 된다. 이것은 API 예외 처리에서 설명

API의 경우 3가지 케이스를 고려해야 한다.
1. 성공
2. 실패 요청 : JSON 객체 생성을 실패함. 컨트롤러로 오지도 못함. (8, 9장에서 할 것)
3. 검증 오류 요청 : JSON을 객체로 생성하는 것 성공, 검증에서 실패

validate 하면서 검증 오류 발생
bindingResult.getAllErrors() 하게되면 모든 에러를 가져온다
json으로 뿌리면 codes, arguments 등 불필요한 것들도 준다. 그래서 rejectedValue와 메시지 같은 것들의 규격을 정해서 필요한 것들만 뽑아줘야 한다.

@ModelAttirbute는 각각 필드 단위로 세밀하게 적용

`HttpMessageConverter`는 전체 객체 단위 적용됨.
따라서 메시지 컨버터 작동 성공해서 객체 만들어야 검증 어노테이션이 적용됨

그래서 Json 데이터를 객체로 변경하지 못하면 Validator도 적용할 수 없고 컨트롤러도 호출하지 못한다.
메시지 컨버터 단계 실패 시 예외 발생. 이때 원하는 모양으로 예외 처리하는 방법은 예외 처리 부분에서 다룸.