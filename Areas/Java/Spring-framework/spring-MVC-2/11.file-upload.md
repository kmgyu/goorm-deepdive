
파일 업로드 시 바이너리 데이터 전송해야함.
가장 기본적인 방법 : application/x-www-form-urlencoded

파일만 전송하는 것이 아니다.
이름, 나이 등의 추가적인 정보를 보낼 수 있다.
이때를 위해 http는 multipart/form-data라는 타입을 지원한다.

http 메시지에서 boundary라는 값을 기반으로 요청이 구분되서 보내진다.
다 같은 데이터로 본다.
더 있긴 한데 추가 정리 필요
아무튼 문자랑 바이너리를 같이 보내야 한다는 것임.

쪼개서 나누는 단위는 part

# Servlet file upload

각 파트를 나눠서 전송하는데, 사용하는 법에 대해 알아본다...

```java
@Slf4j
 @Controller
 @RequestMapping("/servlet/v1")
 public class ServletUploadControllerV1 {
    @GetMapping("/upload")
 public String newFile() {
 return "upload-form";
    }
    @PostMapping("/upload")
 public String saveFileV1(HttpServletRequest request) throws 
ServletException, IOException {
        log.info("request={}", request);
 String itemName = request.getParameter("itemName");
        log.info("itemName={}", itemName);
 Collection<Part> parts = request.getParts();
        log.info("parts={}", parts);
 return "upload-form";
    }
 }
```

parts가 바로 폼데이터를 나누는 단위 part이다.

업로드 사이즈 제한
```
spring.servlet.multipart.max-file-size=1MB spring.servlet.multipart.max-request-size=10MB
```

```
spring.servlet.multipart.enabled=false
```
다음과 같이 설정 시 multipart를 처리하지 않는다. 당연히 getParts시 텅 비어버림. 기본 값은 true

로그 확인 시 HttpServletRequest 객체가 RequestFacade를 StandardMultipartHttpServletRequest로 변환시키는 것을 확인 가능하다.

spring.servlet.multipart.enabled 활성화 시 스프링 디스패처 서블릿이 멀티파트 리졸버를 실행한다.

멀티파트 리졸버는 멀티 파트 요청일 경우 서블릿 컨테이너가 전달하는 일반적인 HttpServletRequest를 MultipartHttpServletRequest로 변환하여 반환한다. 이건 HttpServletRequest의 자식 인터페이스이고, 멀티파트와 관련된 추가기능을 제공함.

스프링 제공 기본 멀티파트 리졸버는 MultipartHttpServletRequest 구현체인 StandardMultipartHttpServletRequest를 반환함.
이제 컨트롤러에서는 MultipartHttpServletRequest를 주입받을 수 있다.
그러나 MultipartFile이라는 것을 사용하기 더 편해서 잘 사용되지는 않는다.

---

```
file.dir=/your/direction
```
파일 경로 설정

```
@Value("${file.dir}")
public String fileDir;
```
다음과 같이 클래스에서 사용할 수 있다.

```java
@Slf4j
@Controller
@RequestMapping("/servlet/v2")
public class ServletUploadControllerV2 {
    @Value("${file.dir}")
 private String fileDir;
    @GetMapping("/upload")
 public String newFile() {
 return "upload-form";
    }
    @PostMapping("/upload")
 public String saveFileV1(HttpServletRequest request) throws 
ServletException, IOException {
        log.info("request={}", request);
 String itemName = request.getParameter("itemName");
        log.info("itemName={}", itemName);
 Collection<Part> parts = request.getParts();
        log.info("parts={}", parts);
 for (Part part : parts) {
            log.info("==== PART ====");
            log.info("name={}", part.getName());
 Collection<String> headerNames = part.getHeaderNames();
 for (String headerName : headerNames) {
                log.info("header {}: {}", headerName, 
part.getHeader(headerName));
            }
 //편의 메서드
//content-disposition; filename
            log.info("submittedFileName={}", part.getSubmittedFileName());
            log.info("size={}", part.getSize()); //part body size
 //데이터 읽기
InputStream inputStream = part.getInputStream();
 String body = StreamUtils.copyToString(inputStream, 
StandardCharsets.UTF_8);
            log.info("body={}", body);
 //파일에 저장하기
if (StringUtils.hasText(part.getSubmittedFileName())) {
 String fullPath = fileDir + part.getSubmittedFileName();
                log.info("파일 저장 fullPath={}", fullPath);
                part.write(fullPath);
            }
        }
 return "upload-form";
    }
 }
```
파일 디렉토리에 파일을 저장시켜준다.

큰 용량의 파일을 업로드를 테스트 할 때는 로그가 너무 많이 남아서 다음 옵션을 끄는 것이 좋다. 
`logging.level.org.apache.coyote.http11=trace`
다음 부분도 파일의 바이너리 데이터를 모두 출력하므로 끄는 것이 좋다.
` log.info("body={}", body);`

# Spring file upload

```java
@Slf4j
 @Controller
 @RequestMapping("/spring")
 public class SpringUploadController {
    @Value("${file.dir}")
 private String fileDir;
    @GetMapping("/upload")
 public String newFile() {
 return "upload-form";
    }
    @PostMapping("/upload")
 public String saveFile(@RequestParam String itemName,
                           @RequestParam 
request) throws IOException {
 MultipartFile file, HttpServletRequest 
        log.info("request={}", request);
        log.info("itemName={}", itemName);
        log.info("multipartFile={}", file);
 if (!file.isEmpty()) {
 String fullPath = fileDir + file.getOriginalFilename();
            log.info("파일 저장 fullPath={}", fullPath);
            file.transferTo(new File(fullPath));
        }
 return "upload-form";
    }
 }
```
MultipartFile이란 것을 받아줄 수 있다.

업로드하는 HTML form에 맞춰 @RequestParam을 작성한다.
@ModelAttribute에서도 동일하게 사용할 수 있다.

MultipartFile 주요 메서드
getOriginalFilename() : 업로드 파일명
transferTo() : 파일 저장

실습 16~ 참고
Item, ItemRepository, UploadFile 생략

파일 처리 컨트롤러
```java
@Slf4j
 @Controller
 @RequiredArgsConstructor
 public class ItemController {
 private final ItemRepository itemRepository;
 private final FileStore fileStore;
    @GetMapping("/items/new")
 public String newItem(@ModelAttribute ItemForm form) {
 return "item-form";
    }
    @PostMapping("/items/new")
 public String saveItem(@ModelAttribute ItemForm form, RedirectAttributes 
redirectAttributes) throws IOException {
 UploadFile attachFile = fileStore.storeFile(form.getAttachFile());
 List<UploadFile> storeImageFiles = 
fileStore.storeFiles(form.getImageFiles());
 //데이터베이스에 저장
Item item = new Item();
        item.setItemName(form.getItemName());
        item.setAttachFile(attachFile);
        item.setImageFiles(storeImageFiles);
        itemRepository.save(item);
        redirectAttributes.addAttribute("itemId", item.getId());
 return "redirect:/items/{itemId}";
    }
    @GetMapping("/items/{id}")
 public String items(@PathVariable Long id, Model model) {
 Item item = itemRepository.findById(id);
        model.addAttribute("item", item);
        return "item-view";
    }
    @ResponseBody
    @GetMapping("/images/{filename}")
    public Resource downloadImage(@PathVariable String filename) throws 
MalformedURLException {
        return new UrlResource("file:" + fileStore.getFullPath(filename));
    }
    @GetMapping("/attach/{itemId}")
    public ResponseEntity<Resource> downloadAttach(@PathVariable Long itemId) 
throws MalformedURLException {
        Item item = itemRepository.findById(itemId);
        String storeFileName = item.getAttachFile().getStoreFileName();
        String uploadFileName = item.getAttachFile().getUploadFileName();
        UrlResource resource = new UrlResource("file:" + 
fileStore.getFullPath(storeFileName));
        log.info("uploadFileName={}", uploadFileName);
        String encodedUploadFileName = UriUtils.encode(uploadFileName, 
StandardCharsets.UTF_8);
        String contentDisposition = "attachment; filename=\"" + 
encodedUploadFileName + "\"";
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, contentDisposition)
                .body(resource);
    }
 }
```

파일 처리 클래스
```java
@Component
 public class FileStore {
    @Value("${file.dir}")
private String fileDir;
 public String getFullPath(String filename) {
 return fileDir + filename;
    }
 public List<UploadFile> storeFiles(List<MultipartFile> multipartFiles) 
throws IOException {
 List<UploadFile> storeFileResult = new ArrayList<>();
 for (MultipartFile multipartFile : multipartFiles) {
 if (!multipartFile.isEmpty()) {
                storeFileResult.add(storeFile(multipartFile));
            }
        }
 return storeFileResult;
    }
 public UploadFile storeFile(MultipartFile multipartFile) throws IOException 
{
 if (multipartFile.isEmpty()) {
 return null;
        }
 String originalFilename = multipartFile.getOriginalFilename();
 String storeFileName = createStoreFileName(originalFilename);
        multipartFile.transferTo(new File(getFullPath(storeFileName)));
 return new UploadFile(originalFilename, storeFileName);
    }
 private String createStoreFileName(String originalFilename) {
 String ext = extractExt(originalFilename);
 String uuid = UUID.randomUUID().toString();
 return uuid + "." + ext;
    }
 private String extractExt(String originalFilename) {
 int pos = originalFilename.lastIndexOf(".");
 return originalFilename.substring(pos + 1);
    }
 }
```
createStoreFileName()로 UUID를 이용해 파일 충돌이 일어나지 않도록 저장
extractExt()를 통해 확장자 별도 추출해 서버 내부 관리 파일명에도 붙여준다.