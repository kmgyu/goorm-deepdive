request에서 getParameter로 가져올 시 문자열을 가져오게됨.

@RequestParm과 같이 스프링이 중간에서 타입을 중간에 반환해주기 때문에 편리하게 사용할 수 있다.

타입 변환 예시
@RequestParma, @ModelAttribute, @PathVaraible 등...
xml 스프링 빈 정보 변환, 뷰 렌더링 등

새로운 타입을 만들어서 변환할 시 어떻게 하는가?

스프링은 확장 가능한 컨버터 인터페이스를 제공함.

# Converter

컨버터의 가장 기본적인 부분을 살펴보자.

Converter라는 이름의 인터페이스는 매우 많다.
`org.springframework.core.convert.converter.Converter`
이 경로를 기억해두자! 다른 컨버터를 사용할 수 있으니 주의할 것

String to Integer Converter 예제
```java
@Slf4j
public class StringToIntegerConverter implements Converter<String, Integer> {
 @Override
 public Integer convert(String source) {
 log.info("convert source={}", source);
 return Integer.valueOf(source);
 }
}
```

```java
class ConverterTest {
 @Test
 void stringToInteger() {
 StringToIntegerConverter converter = new StringToIntegerConverter();
 Integer result = converter.convert("10");
 assertThat(result).isEqualTo(10);
 }
 @Test
 void integerToString() {
 IntegerToStringConverter converter = new IntegerToStringConverter();
 String result = converter.convert(10);
 assertThat(result).isEqualTo("10");
 }
}
```
Integer to String Converter도 만들어볼 수 있다. 여기서는 생략했다.

## 사용자 정의 타입 컨버터

이번엔 사용자가 정의한 타입으로 변환하는 컨버터이다.
```java
@Getter
@EqualsAndHashCode
public class IpPort {
 private String ip;
 private int port;
 public IpPort(String ip, int port) {
 this.ip = ip;
 this.port = port;
 }
}
```

**@EqualsAndHashCode?**
equals와 hashcode 사용 시 모든 필드를 사용한다.
모든 필드의 값이 같다면 같은 객체를 가리킨다고 판정한다...!

```java
@Slf4j
public class StringToIpPortConverter implements Converter<String, IpPort> {
 @Override
 public IpPort convert(String source) {
 log.info("convert source={}", source);
 String[] split = source.split(":");
 String ip = split[0];
 int port = Integer.parseInt(split[1]);
 return new IpPort(ip, port);
 }
}
```

```java
@Slf4j
public class IpPortToStringConverter implements Converter<IpPort, String> {
 @Override
 public String convert(IpPort source) {
 log.info("convert source={}", source);
 return source.getIp() + ":" + source.getPort();
 }
}
```

문자를 IpPort로, IpPort를 문자로 만드는 컨버터다.

```java
@Test
void stringToIpPort() {
 StringToIpPortConverter converter = new StringToIpPortConverter();
 String source = "127.0.0.1:8080";
 IpPort result = converter.convert(source);
 assertThat(result).isEqualTo(new IpPort("127.0.0.1", 8080));
}
@Test
void ipPortToString() {
 IpPortToStringConverter converter = new IpPortToStringConverter();
 IpPort source = new IpPort("127.0.0.1", 8080);
 String result = converter.convert(source);
 assertThat(result).isEqualTo("127.0.0.1:8080");
}
```

이런 식으로 사용자 정의 타입도 컨버터를 이용할 수 있다.

> 스프링은 용도에 따라 다양한 방식의 타입 컨버터를 제공한다. 
> Converter 기본 타입 컨버터
> ConverterFactory 전체 클래스 계층 구조가 필요할 때
> GenericConverter 정교한 구현, 대상 필드의 애노테이션 정보 사용 가능
> ConditionalGenericConverter 특정 조건이 참인 경우에만 실행
> 자세한 내용은 공식 문서 참고
> https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core-convert


> 스프링은 문자, 숫자, 불린, Enum등 일반적인 타입에 대한 대부분의 컨버터를 기본으로 제공한다. IDE에서 Converter, ConverterFactory, GenericConverter의 구현체를 찾아보면 수 많은 컨버터를 확인할 수 있다


# ConversionService

타입 컨버터를 사용자가 직접 찾아서 타입 변환에 사용하는 것은 바람직하지 않다.
스프링은 개별 컨버터를 모아두고 그것들을 묶어 편리하게 사용할 수 있도록 ConversionService 기능을 제공한다.


컨버전 설명

SOLID - ISP 원칙

잘보면 인터페이스를 분리했다.
ConversionService, ConversionRegistry
각각 사용과 등록에 초점을 맞춤.

결과적으로 컨버터 사용 클라이언트는 꼭 필요한 메서드만 알게 된다.

```java
public interface ConversionService {
 boolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType);
 boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor 
targetType);
 <T> T convert(@Nullable Object source, Class<T> targetType);
 Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, 
TypeDescriptor targetType);
 }
```
인터페이스는 이렇게 생겼다.

```java
 public class ConversionServiceTest {
    @Test
 void conversionService() {
 //등록
DefaultConversionService conversionService = new 
DefaultConversionService();
        conversionService.addConverter(new StringToIntegerConverter());
        conversionService.addConverter(new IntegerToStringConverter());
        conversionService.addConverter(new StringToIpPortConverter());
        conversionService.addConverter(new IpPortToStringConverter());
 //사용
assertThat(conversionService.convert("10", 
Integer.class)).isEqualTo(10);
 assertThat(conversionService.convert(10, String.class)).isEqualTo("10");
 IpPort ipPort = conversionService.convert("127.0.0.1:8080", 
IpPort.class);
 assertThat(ipPort).isEqualTo(new IpPort("127.0.0.1", 8080));
 String ipPortString = conversionService.convert(new IpPort("127.0.0.1", 
8080), String.class);
 assertThat(ipPortString).isEqualTo("127.0.0.1:8080");
    }
 }
```
사용 예시는 위와 같다.


```java
@Configuration
 public class WebConfig implements WebMvcConfigurer {
 }
    @Override
 public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(new StringToIntegerConverter());
        registry.addConverter(new IntegerToStringConverter());
        registry.addConverter(new StringToIpPortConverter());
        registry.addConverter(new IpPortToStringConverter());
    }
```

컨버터 등록은 이런 식으로 한다.

이제 Integer 사용해보면 컨버터의 로그가 찍히는 것을 볼 수 있다.
사실 이렇게 등록하기 전에도 스프링이 내부에서 수많은 기본 컨버터를 제공하기 때문에 잘 수행된다.
컨버터는 직접 등록한 것의 우선순위가 더 높다.

```java
 @GetMapping("/ip-port")
 public String ipPort(@RequestParam IpPort ipPort) {
 System.out.println("ipPort IP = " + ipPort.getIp());
 System.out.println("ipPort PORT = " + ipPort.getPort());
 return "ok";
 }
```
이런 식으로 해줘도 잘 나온다!

처리과정
@RequestParam을 처리하는 ArgumentResolver (RequestParamArgumentResolver)가 ConversionService 사용
ConversionService가 타입을 변환

필드로 가지고 있다가 메서드 사용하는 듯



```java
 @Controller
 public class ConverterController {
    @GetMapping("/converter-view")
 public String converterView(Model model) {
        model.addAttribute("number", 10000);
        model.addAttribute("ipPort", new IpPort("127.0.0.1", 8080));
return "converter-view";
    }
 }
```

타임리프는 ` ${{...}} ` 를 사용하면 자동으로 컨버전 서비스를 사용해서 변환된 결과를 출력해준다. 물론 스프링과 통합 되어서 스프링이 제공하는 컨버전 서비스를 사용하므로, 우리가 등록한 컨버터들을 사용할 수 있다

변수 표현식 사용 시 toString이 될 수 있다...! 컨버터를 쓰고 싶다면 중괄호를 꼭 하나 더 써주자

## 폼에 적용

```java
@Controller
 public class ConverterController {
타입을 
    @GetMapping("/converter-view")
 public String converterView(Model model) {
        model.addAttribute("number", 10000);
        model.addAttribute("ipPort", new IpPort("127.0.0.1", 8080));
 return "converter-view";
    }
    @GetMapping("/converter/edit")
public String converterForm(Model model) {
 IpPort ipPort = new IpPort("127.0.0.1", 8080);
 Form form = new Form(ipPort);
        model.addAttribute("form", form);
 return "converter-form";
    }
    @PostMapping("/converter/edit")
 public String converterEdit(@ModelAttribute Form form, Model model) {
 IpPort ipPort = form.getIpPort();
        model.addAttribute("ipPort", ipPort);
 return "converter-view";
    }
    @Data
 static class Form {
 private IpPort ipPort;
 public Form(IpPort ipPort) {
 this.ipPort = ipPort;
        }
    }
 }
```

```html
<!DOCTYPE html>
 <html xmlns:th="http://www.thymeleaf.org">
 <head>
    <meta charset="UTF-8">
    <title>Title</title>
 </head>
 <body>

 <form th:object="${form}" th:method="post">
    th:field <input type="text" th:field="*{ipPort}"><br/>
    th:value <input type="text" th:value="*{ipPort}">(보여주기 용도)<br/>
    <input type="submit"/>
 </form>
 </body>
 </html>
```
이런 식으로 th:field를 사용해도 컨버전 서비스가 적용된다.


# Formatter

Converter는 입력 및 출력 타입에 제한이 없는 범용 타입 변환 기능을 제공함.
개발자 입장에서는 문자를 다른 타입 또는 다른 타입을 문자로 변환하는 케이스가 대부분임.

## Locale
숫자 표현 시 현지화 정보가 사용될 수 있음.

Converter vs Formatter
converter는 범용
formatter는 문자 특화
- converter의 특별 버전

## formatter 만들기

String print(T object, Locale locale)
객체를 문자로 변경한다.

T parse(String text, Locale locale)
문자를 객체로 변경한다.

formatter 인터페이스
```java
public interface Printer<T> {
 String print(T object, Locale locale);
 }
 public interface Parser<T> {
 T parse(String text, Locale locale) throws ParseException;
 }
 public interface Formatter<T> extends Printer<T>, Parser<T> {
 }
```

```java
@Slf4j
 public class MyNumberFormatter implements Formatter<Number> {
    @Override
 public Number parse(String text, Locale locale) throws ParseException {
        log.info("text={}, locale={}", text, locale);
 NumberFormat format = NumberFormat.getInstance(locale);
 return format.parse(text);
    }
    @Override
 public String print(Number object, Locale locale) {
        log.info("object={}, locale={}", object, locale);
 return NumberFormat.getInstance(locale).format(object);
   
```
이렇게 만들어줄 수 있다.
1,000 같은 문자열을 1000로 만드는 거

인텔리제이 테스트하기 꿀팁 ctrl + shift + t 하면 테스트 클래스 만들기 바로 가능

테스트코드는 pdf 22페이지 참고. 그냥 assertThat 해서 isEqualTo로 체크하는 거임.

AnnotationFormatterFactory라는 필드 타입이나 어노테이션 정보를 활용 가능한 포인터도 있다고 함.

## 포맷터 지원 컨버전 서비스

컨버전 서비스에는 포맷터 등록 불가능
포맷터 지원 컨버전 서비스를 통해 사용 가능
내부에서 어댑터 패턴을 사용해 Formatter가 Converter처럼 동작하도록 지원함.

FormattingConversionService
포맷터 지원 컨버전 서비스

DefaultFormattingConversionService
기본적 통화, 숫자 관련 몇가지 기본 포맷터를 추가해 제공
컨버전 서비스 관련 기능을 상속 받았기 때문에 결과적으로 컨버터도 등록 가능하기도 함.

사용할 때는 convert 사용하면 된다.


## 포맷터 적용하기

```java
 @Configuration
 public class WebConfig implements WebMvcConfigurer {
    @Override
 public void addFormatters(FormatterRegistry registry) {
 //주석처리 우선순위
//registry.addConverter(new StringToIntegerConverter());
 //registry.addConverter(new IntegerToStringConverter());
        registry.addConverter(new StringToIpPortConverter());
        registry.addConverter(new IpPortToStringConverter());
 //추가
        registry.addFormatter(new MyNumberFormatter());
   
```

기능이 겹치는 컨버터는 미리 없애준다.
포맷터가 적용되지 않기 때문

## 스프링 기본 제공 포맷터

날짜나 시간 관련 포맷터 제공해주는 것을 볼 수 있음.
그런데 포맷터는 기본 형식이 지정되어 객체의 각 필드마다 다른 형식의 포맷을 지정하기 어려움.

이 문제 해결위해 어노테이션 기반 원하는 형식 지정 사용 가능한 포맷터를 기본 제공

- @NumberFormat : 숫자 관련 형식 지정 포맷터 사용
NumberFormatAnnotationFormatterFactory
- @DateTimeFormat : 날짜 관련 형식 지정 포맷터 사용
Jsr310DateTimeFormatAnnotationFormatterFactory
이 외에도 여러가지 존재함.

```java
 @Controller
 public class FormatterController {
    @GetMapping("/formatter/edit")
 public String formatterForm(Model model) {
 Form form = new Form();
        form.setNumber(10000);
        form.setLocalDateTime(LocalDateTime.now());
        model.addAttribute("form", form);
 return "formatter-form";
    }
    @PostMapping("/formatter/edit")
 public String formatterEdit(@ModelAttribute Form form) {
 return "formatter-view";
    }
    @Data
 static class Form {
        @NumberFormat(pattern = "###,###")
 private Integer number;
        @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
 private LocalDateTime localDateTime;
    }
 }
```

```html
 <!DOCTYPE html>
 <html xmlns:th="http://www.thymeleaf.org">
 <head>
    <meta charset="UTF-8">
    <title>Title</title>
 </head>
 <body>
 <ul>
 li>
    <li>${form.number}: <span th:text="${form.number}" ></span></li>
    <li>${{form.number}}: <span th:text="${{form.number}}" ></span></li>
    <li>${form.localDateTime}: <span th:text="${form.localDateTime}" ></span></
    <li>${{form.localDateTime}}: <span th:text="${{form.localDateTime}}" ></
 span></li>
 </ul>
 </body>
```
결과 확인용 폼

컨버터를 사용하든, 포맷터를 사용하든 등록 방법은 다르지만, 사용할 때는 컨버전 서비스를 통해서 일관성 있게 사용할 수 있다.


주의?
메시지 컨버터( `HttpMessageConverter` )에는 컨버전 서비스가 적용되지 않는다. 
특히 객체를 JSON으로 변환할 때 메시지 컨버터를 사용하면서 이 부분을 많이 오해하는데, `HttpMessageConverter` 의 역할은 HTTP 메시지 바디의 내용을 객체로 변환하거나 객체를 HTTP 메시지 바디에 입력하는 것이다.

예를 들어서 JSON을 객체로 변환하는 메시지 컨버터는 내부에서 Jackson 같은 라이브러리를 사용 한다. 객체를 JSON으로 변환한다면 그 결과는 이 라이브러리에 달린 것이다. 
따라서 JSON 결과로 만들어지는 숫자나 날짜 포맷을 변경하고 싶으면 해당 라이브러리가 제공하는 설정을 통해서 포맷을 지정해야 한다. 결과적으로 이것은 컨버전 서비스와 전혀 관계가 없다. 

컨버전 서비스는 `@RequestParam`,  `@ModelAttribute` , `@PathVariable` , 뷰 템플릿 등에서 사용할 수 있다.

