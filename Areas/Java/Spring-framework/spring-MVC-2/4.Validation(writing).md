부적절한 값을 검증해주고 오류 페이지가 출력되지 않게 한다.
폼 입력 시 검증 오류 발생 시 오류화면 발생 -> 불편함. 유저 이탈

컨트롤러 역할 중 하나? HTTP 요청이 정상적인지 검증
검증 로직이 정상 로직보다 개발 난이도가 높을 수 있음.

> 클라이언트 검증, 서버 검증
> 클라이언트 검증은 조작 가능, 보안에 취약함.
> 서버만으로 검증 시, 즉각적 고객 사용성 부족
> 둘을 적절히 사용하되, 최종적으로 서버 검증은 필수이다.
> API 방식 사용 시 API 스펙을 잘 정의해 검증 오류를 API 응답 결과에 남겨주어야 함.


검증 처리
정상 흐름
PRG
실패 시?
Redirect를 하면서 검증 오류 결과를 포함한다.
검증 로직을 돌리고 상품 폼을 다시 보여줘야 함.
기존 데이터를 다 담고 실패한 정보 담은 후 재렌더링

실습에서는 검증로직 및 에러를 직접 만들어 문제점을 알아보았다.
- 중복 코드 많음
- 타입 오류 처리 불가능
- 문자 보관 불가능으로 인해 고객은 오류 발생 이해 어려움
그래서 validation 라이브러리 리팩토링하는 과정

### 필드 검증

---

⇒ 요청에서 들어온 필드의 내용을 하나씩 조건을 걸어 확인하는 방법

- 코드
    
    ```java
    @PostMapping("/add")
    public String addItem(@ModelAttribute Item item, RedirectAttributes redirectAttributes, Model model) {
    
        //검증 오류 결과를 보관
        Map<String, String> errors = new HashMap<>();
    
        //검증 로직
        if (!StringUtils.hasText(item.getItemName())) {
            errors.put("itemName", "상품 이름은 필수입니다.");
        }
        if (item.getPrice() == null || item.getPrice() < 1000 || item.getPrice() > 1000000) {
            errors.put("price", "가격은 1,000 ~ 1,000,000 까지 허용합니다.");
        }
        if (item.getQuantity() == null || item.getQuantity() >= 9999) {
            errors.put("quantity", "수량은 최대 9,999 까지 허용합니다.");
        }
    
        //특정 필드가 아닌 복합 룰 검증
        if (item.getPrice() != null && item.getQuantity() != null) {
            int resultPrice = item.getPrice() * item.getQuantity();
            if (resultPrice < 10000) {
                errors.put("globalError", "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice);
            }
        }
    
        //검증에 실패하면 다시 입력 폼으로
        if (!errors.isEmpty()) {
            log.info("errors = {} ", errors);
            model.addAttribute("errors", errors);
            return "validation/v1/addForm";
        }
    
        //성공 로직
        Item savedItem = itemRepository.save(item);
        redirectAttributes.addAttribute("itemId", savedItem.getId());
        redirectAttributes.addAttribute("status", true);
        return "redirect:/validation/v1/items/{itemId}";
    }
    ```
    

### BindingResult

---

⇒ BindingResult 인터페이스를 이용하는 방법

- BindingResult = 인터페이스
    
- 실제 구현 = BeanPropertyBindingResult (기본)
    
- 스프링이 WebDataBinder를 통해 생성하고 주입해줌
    
- 코드
    
    ```java
    @PostMapping("/add")
    public String addItemV2(@ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) {
    
        //검증 로직
        if (!StringUtils.hasText(item.getItemName())) {
            bindingResult.addError(new FieldError("item", "itemName", item.getItemName(), false, null, null, "상품 이름은 필수 입니다."));
        }
        if (item.getPrice() == null || item.getPrice() < 1000 || item.getPrice() > 1000000) {
            bindingResult.addError(new FieldError("item", "price", item.getPrice(), false, null, null, "가격은 1,000 ~ 1,000,000 까지 허용합니다."));
        }
        if (item.getQuantity() == null || item.getQuantity() >= 9999) {
            bindingResult.addError(new FieldError("item", "quantity", item.getQuantity(), false, null ,null, "수량은 최대 9,999 까지 허용합니다."));
        }
    
        //특정 필드가 아닌 복합 룰 검증
        if (item.getPrice() != null && item.getQuantity() != null) {
            int resultPrice = item.getPrice() * item.getQuantity();
            if (resultPrice < 10000) {
                bindingResult.addError(new ObjectError("item",null ,null, "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice));
            }
        }
    
        //검증에 실패하면 다시 입력 폼으로
        if (bindingResult.hasErrors()) {
            log.info("errors={} ", bindingResult);
            return "validation/v2/addForm";
        }
    
        //성공 로직
        Item savedItem = itemRepository.save(item);
        redirectAttributes.addAttribute("itemId", savedItem.getId());
        redirectAttributes.addAttribute("status", true);
        return "redirect:/validation/v2/items/{itemId}";
    }
    ```
    
    - BindingResult가 error를 저장하는 역할을 하고 있다.
    - .addError(new FieldError)로 에러를 BindingResult에 넣어준다.
    - 이때 BindingResult 객체는 model에 자동으로 Attribute되어 같이 view로 넘어감
    - 직접 Map을 통해 다루지 않아도 된다.
    - 수동으로 에러를 넣는 방법

⇒ BindingResult가 있으므로써 데이터가 넘어올때 Item에서 오류가 생겨도 오류페이지 및 코드인 400으로 넘어가지 않고(즉, 컨트롤러까지 안가는 상황) 오류내용을 객체에 담아 원하는 페이지로 넘겨줄 수 있다.(유연성)

⇒ 검증 적용법

1. `@ModelAttribute` 가 뒤에오는 객체의 미리 지정된 타입을 통해 바인딩시 스프링이 자동으로 `BindingResult`에 `FieldError`를 생성하여 넣어준다.
    - 단, 타입 매칭이 안되는 경우만 해당
2. 수동으로 넣기
3. `Validator` 사용
    - 객체에 어노테이션으로 만든 조건(@Max, @Min, @NotNull 등)을 확인하는 방법


> spring mvc에서는 이렇게 씀

`#fields`를 통해 BindingResult 접근 가능

`#fields.hasGlobalErros()`
`${#fields.globalErrors()}`
이렇게 사용

`th:errors="*{itemName}`
요런식으로 해주면 에러 있으면 보여주고 없으면 안보여줌

th:errorclass 같이 필드에 오류있으면 클래스 추가해주는 것도 있다.

인터페이스에 BindingResults 대신 Erros를 사용해줄 수도 있지만 Errors는 단순한 오류 저장, 조회 기능만 제공한다. 그러나 관례상 BindingResults를 사용하고 더 많은 기능을 저장한다.

오류 발생 시 데이터는 유지되지 않는다. 아래에 FieldError와 ObjectError에서 이 값들을 처리할 수 있다.


### FieldError

---

⇒ 오류 메세지를 생성하며 부가적인 기능을 제공하는 클래스

- 파라미터 목록
    
    - `objectName` : 오류가 발생한 객체 이름
    - `field` : 오류 필드
    - `rejectedValue` : 사용자가 입력한 값(거절된 값)
        - 여기에 담으면 인증에 실패한 값을 BindingResult를 통해 model에 담아 view로 전달할 수 있다.
    - `bindingFailure` : 타입 오류 같은 바인딩 실패인지, 검증 실패인지 구분 값
    - `codes` : 메시지 코드
    - `arguments` : 메시지에서 사용하는 인자
    - `defaultMessage` : 기본 오류 메시지

- 코드
    
```java
//검증 로직
if (!StringUtils.hasText(item.getItemName())) {
bindingResult.addError(new FieldError("item", "itemName", item.getItemName(), false, new String[]{"required.item.itemName"}, null, null));
}
if (item.getPrice() == null || item.getPrice() < 1000 || item.getPrice() > 1000000) {
bindingResult.addError(new FieldError("item", "price", item.getPrice(), false, new String[]{"range.item.price"}, new Object[]{1000, 1000000}, null));
}
if (item.getQuantity() == null || item.getQuantity() >= 9999) {
bindingResult.addError(new FieldError("item", "quantity", item.getQuantity(), false, new String[]{"max.item.quantity"} ,new Object[]{9999}, null));
}
```

- FieldError의 생성자에서 argument 필드에 미리 properties로 지정한 에러내용을 넣으면 해당 에러가 발생하여 FieldError가 생성될 때 지정한 에러내용이 들어간다.

- 미리 에러에 관련된 파일을 구성하여 관리할 수 있다.
- 이때 String[]로 받아 에러내용을 찾는 순서를 설정할 수 있다.

⇒ errors.properties

```java
required.item.itemName=상품 이름은 필수입니다.
range.item.price=가격은 {0} ~ {1} 까지 허용합니다.
max.item.quantity=수량은 최대 {0} 까지 허용합니다.
totalPriceMin=가격 * 수량의 합은 {0}원 이상이어야 합니다. 현재 값 = {1}
```

> 위에 있는 것 부가 설명

codes, arguments는 메시지를 통해서 관리하도록 분리해줄 수 있다.
codes의 경우 new String 배열로 넣어줄 수 있음.
argument? new Object 배열로 넘겨준다.
codes는 메시지에 기록된다.
```
{0}~{1} 범위
```
argument는 이렇게 {0}이나 {1}로 된 빈칸에 값을 채워주는 역할이라 보면 됨.



> RejectValue

⇒ 기존 FieldError, OrbjectError를 사용하는 방식은 작성해야할 필드가 많이 번거로운 점이 있다. 이것을 RejectValue로 개선할 수 있다.

⇒ 이 내용은 BindingResult가 이미 객체이름 : item, 필드이름 : itemName, price 등 을 알고 있기 때문에 가능하다.

- 파라미터 목록
    
    - `field` : 오류 필드명
    - `errorCode` : 오류 코드(이 오류 코드는 메시지에 등록된 코드가 아니다. 뒤에서 설명할 messageResolver를 위한 오류 코드이다.)
    - `errorArgs` : 오류 메시지에서 `{0}` 을 치환하기 위한 값
    - `defaultMessage` : 오류 메시지를 찾을 수 없을 때 사용하는 기본 메시지
- 코드
    
    ```java
    if (!StringUtils.hasText(item.getItemName())) {
        bindingResult.rejectValue("itemName", "required");
    }
    if (item.getPrice() == null || item.getPrice() < 1000 || item.getPrice() > 1000000) {
        bindingResult.rejectValue("price", "range", new Object[]{1000, 10000000}, null);
    }
    if (item.getQuantity() == null || item.getQuantity() >= 9999) {
        bindingResult.rejectValue("quantity", "max", new Object[]{9999}, null);
    }
    ```
    
- 이젠 필드명, 에러이름만 있으면 된다.
- 그렇다면 어떻게 properties에 지정된 에러를 가져올 수 있는지?
	- 에러이름을 지정하는 규칙이 있음
		- 에러이름.객체명.필드명 으로 찾아온다.

---


Message Codes Resolver 이해
단순히 required만 넣어주면 그 아래에 있는 것들 전부 줄 수 있다.
messageCodes로 MessageCodesResolver에 resolveMessageCodes("required", "item")
찍어주게 되면 해당 메시지 코드가 나온다. 배열로 반환됨
그걸 rejectValue가 대신 처리해준다

errorCode, objectName, field까지 넣어줄 수 있다.


검증 오류 코드로 메시지 코드 생성
DefaultMessageCodesResolver는 기본 구현체

주로 ObjectError, FieldError와 함께 사용

rejectValue(), reject()는 내부에서 해당 인터페이스 사용. 여기에서 메시지 코드 생성
오류코드를 자동으로 생성
th:errors 실행될 때 메시지 코드 순서대로 돌아가면서 찾아준다.

오류 코드 관리 전략?
레벨1, ~ 레벨4와 같이 관리해줄 수 있다.
레벨이 높아질 수록 범용적인 것
정말 중요한 메시지는 필요할 때 구체적으로 작성

코드에서는 required만 작성해줘도 우선순위에 따라 순서대로 찾아준다?
구체적인 것에서 덜 구체적인 순서로 찾음. 메시지 1번 없으면 2번 찾고, 없으면 3번...

ValidationUtils이라는 기능도 있음.
.rejectIfEmptyOrWhitespace() 이런 거
위에 거는 Empty, 공백 같은 단순한 기능 제공해줌.


typeMismatch
스프링 타입 오류 발생 시 자동으로 넣어준다.
스프링이 설명하는 메시지가 들어가게 됨.
직접 개발자의 에러메시지에 typeMismatch를 설정해줄 수 있음.
디폴트 메시지는 스프링이 만들어서 못건드리지만 메시지 프로퍼티스는 설정해줄 수 있다!
메시지는 하나만 주던가 여러개 주던가 해줄 수도 있다.

메시지 생성 전략은 BeanValidation에서 더 활용 가능

### 검증로직의 분리

---

⇒ 기존 방식대로 코딩을 한다면 컨트롤러에서 모든 검증에 관련된 코드를 다루고 약간의 성공에 관련된 코드내용이 있는데 이것을 개발, 유지보수하기에 불편한 구조로 되어있어 분리해보겠다.

> Validator를 사용하는 방법

![[spring-mvc2-validation.png]]

⇒ 두개의 메서드로 구성

- `supports()` : 입력받은 클래스가 validation하기 위한 클래스인지 검증
    
- `validate()` : 입력받은 클래스 내부값을 검증
    
    - 이때 `Error`는 `BindingResult`의 부모 인터페이스로 `BindingResult`를 받을 수 있음
- 코드
    
    ```java
    @Component
    public class ItemValidator implements Validator {
    
        @Override
        public boolean supports(Class<?> clazz) {
            return Item.class.isAssignableFrom(clazz);
        }
    
        @Override
        public void validate(Object target, Errors errors) {
            Item item = (Item) target;
    
            if (!StringUtils.hasText(item.getItemName())) {
                errors.rejectValue("itemName", "required");
            }
            if (item.getPrice() == null || item.getPrice() < 1000 || item.getPrice() > 1000000) {
                errors.rejectValue("price", "range", new Object[]{1000, 10000000}, null);
            }
            if (item.getQuantity() == null || item.getQuantity() >= 9999) {
                errors.rejectValue("quantity", "max", new Object[]{9999}, null);
            }
    
            //특정 필드가 아닌 복합 룰 검증
            if (item.getPrice() != null && item.getQuantity() != null) {
                int resultPrice = item.getPrice() * item.getQuantity();
                if (resultPrice < 10000) {
                    errors.reject("totalPriceMin", new Object[]{10000, resultPrice}, null);
                }
            }
        }
    }
    ```
    
- 코드1
    
    ```java
    @PostMapping("/add")
    public String addItemV5(@ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) {
    
        itemValidator.validate(item, bindingResult);
    
        //검증에 실패하면 다시 입력 폼으로
        if (bindingResult.hasErrors()) {
            log.info("errors={} ", bindingResult);
            return "validation/v2/addForm";
        }
    
        //성공 로직
        Item savedItem = itemRepository.save(item);
        redirectAttributes.addAttribute("itemId", savedItem.getId());
        redirectAttributes.addAttribute("status", true);
        return "redirect:/validation/v2/items/{itemId}";
    }
    ```
    
    ⇒ 컨트롤러에선 이제 검증 결과만 받아 동작을 수행한다.
    
    - 다만 이것은 아직 Validator의 기능을 제대로 사용하지 않는다.
- 코드2
    
    ```java
    @InitBinder
    public void init(WebDataBinder dataBinder) {
        dataBinder.addValidators(itemValidator);
    }
    ```
    
    ⇒ 컨트롤러에 다음의 코드를 작성하여 validation 기능을 하는 itemValidator를 WebDataBinder라는 객체에 넣어 사용한다.
    
    - 이러면 컨트롤러가 동작할때마다 검증기를 바인딩해준다.
    
    ```java
    @PostMapping("/add")
    public String addItemV6(@Validated @ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model)
    ```
    
    ⇒ 동작하는 메서드에 `@Validated` 를 달면 동작시마다 검증을 한다.
    
    - 왜 이렇게 하는것인가?? → 구현체로 만들었으니 불러다쓰면 되지 않나?
    
    ```java
    @InitBinder
        public void init(WebDataBinder dataBinder) {
            dataBinder.addValidators(itemValidator1);
            dataBinder.addValidators(itemValidator2;
            dataBinder.addValidators(itemValidator3);
            ...
            dataBinder.addValidators(itemValidator99999);
        }
    ```
    
    ⇒ 만약 객체마다 입력값 및 데이터를 검증하는 방법이 달라 검증기가 무수히 많은 상황이라면 각 메서드별로 직접 코드에 점근하여 셋팅을 해야한다.
    
    - 만약 이렇게 `WebDataBinder`, `@Validator` 를 이용하면 검증기의 등록, 어노테이션의 셋팅으로 검증과정을 설정할 수 있다.
        
    - 동작
        
        - 여러 객체 타입이 온다면: 예시) `@Validated @ModelAttribute Item item`
        
        ```java
        @Override
        public boolean supports(Class<?> clazz) {
            return Item.class.isAssignableFrom(clazz);
        }
        ```
        
        ⇒ Validator를 상속받아 구현한 검증기(구현체)의 supports()에서 객체를 다룰 수 있는지 확인하여 가능한 검증기를 사용하게 되는 방식이다.
        
    - 글로벌설정
        
    
    ```java
    @SpringBootApplication
    public class ItemServiceApplication implements WebMvcConfigurer {
    
    	public static void main(String[] args) {
    		SpringApplication.run(ItemServiceApplication.class, args);
    	}
    	
    	@Override
    	public Validator getValidator() {
    		return new ItemValidator();
    	}
    }
    ```
    
    ⇒ 다음과 같이 스프링 컨테이너에 셋팅하여 글로벌로 적용하는 방법도 있다.

