서블릿 필터

공통 관심 사항 때문에 필요하다.
로그인 안한 사용자는 items 이런 곳에 들어오면 안된다.
로그인 하지 않은 사용자들도 버튼 눌러서 들어갈 수 있다!

컨트롤러에서 로그인 여부 체크하는 로직을 만들면 되지만, 상품 등록, 상세, 전체 핸들러에 로직을 다 추가해줘야 한다!
개발자는 반복 작업이 싫다. 심지어 로직이 변경이 되면 이것들을 다 수정해줘야 한다.

이런 여러 로직에서 공통으로 관심 있는 것을 공통 관심사라고 한다.
여기선 인증에 대한 관심을 가지고 있다.

스프링 AOP로도 해결 가능하다.
그러나 서블릿 필터, 인터셉터 사용이 좋다. (이것에 대한 이유는?)
웹 관련 공통 관심사 처리 시에는 HTTP 헤더나 URI 정보가 필요한데, 서블릿 필터나 스프링 인터셉터는 `HttpServletRequest`를 제공한다.

그 외에도 수많은 웹 관련 부가기능도 제공해줌
aop는 그냥 어떤 게 호출되고 이 정도만 알 수 있다.

# 서블릿 필터 소개
서블릿이 지원하는 수문장

필터 특성은 다음과 같다.
```
HTTP request - WAS - filter - servlet - controller
```
필터 적용 시 필터 호출 뒤 다음 서블릿이 호출됨.
모든 고객이 요청 로그 남기는 요구사항 있다면 필터 사용하면 됨

특정 URL 패턴에 적용 가능.
`/*`이런 것.

스프링 사용 시 여기서 말하는 서블릿은 디스패치 서블릿으로 생각하면 됨.


필터 제한
필터에서 적절하지 않은 요청이라고 판단하면 거기서 끝낼수도 있다.
그래서 로그인 여부 체크하기 좋다.

필터 체인
```
WAS - 필터1 - 필터2 - 필터3 - ...
```
위와 같이 중간에 필터 자유롭게 추가 가능


필터 인터페이스
필터 인터페이스 구현, 등록 시 서블릿 컨테이너가 필터를 싱글톤 객체로 생성 및 관리

`init()`
필터 초기화 메서드, 서블릿 컨테이너 생성 시 호출

`doFilter()`
고객 요청 올 때마다 해당 메서드 호출, 필터 로직 구현

`destory()`
필터 종료 메서드, 서블릿 컨테이너 종료 시 호출

---

모든 요청에 대해 로그를 남기는 필터를 직접 만들어 확인해보자

Filter를 implement 해준다.

구현 메소드 3가지
init, doFilter, destroy

doFilter시 서블릿 request, response, FilterChain을 받는다.
try 문을 사용해서 chain.doFilter를 해줘야 한다.
그래야 다음 필터로 넘어감.

필터 등록하기

스프링 부트 사용 시 아래와 같이 빈등록해주면 된다.
WebConfig 클래스
FilterRegistrationBean logFilter() 빈등록
```
FilterRegistrationBean<Filter> filterRegistrationBean;
filterRegistrationBean.setFilter(new LogFilter());
filterRegistrationBeana.setOrder(1);
filterRegistrationBean.addUrlPatterns("/*");
return filterRegistrationBean;
```
setFilter
등록 필터 지정

setOrder
필터 순서 지정. 낮을수록 우선순위 높음

addUrlPatterns
필터 적용할 URL 패턴 지정. 한 번에 여러 패턴 지정 가능

트랜잭션을 로그로 남긴다
엄청나게 유저가 많으면 기록이 어렵다!

logback mdc로 http 요청 시 같은 요청 로그에 모두 같은 식별자를 남겨줄 수 있다.

---

이제 인증 체크하는 필터 만들어주자

LoginCheckFilter 클래스 만들어준다!

사실 세 개 다 구현해줄 필요는 없다.
인터페이스 보면 default 키워드 들어가있음.
> 이거 들어가면 굳이 구현 안해줘도 됨

기본
doFilter에서 일단 request 가져와서 requestURI 가져온다. (중간에 서블릿 request를 http 서블릿 request로 형변환)


whiltelist
권한 없어도 들어올 수 있는 String 배열로 url 등록을 미리해준다.

isLoginCheckPath 메서드 만들어주자
화이트 리스트의 경우 인증 체크가 없음. 체크해주기

PatternMatchUtils.simpleMatch() 를 통해 간단하게 체크 가능

필터에서는 무조건 try로 필터링 해준다!

인증 필요할 시 로직
reqeust에서 getSession()으로 HttpSession을 가져온다.
로그인하지 않은 경우, 로그인으로 redirect시켜야 한다.

httpResponse.sendRedirect(/login?redirectURL=requestURI);
return;

아니면? doFilter

catch시 throw e로 톰캣까지 에러를 던져야 함.

finally에는 종료 표시하는 log를 넣어주자.


또 빈등록해준다. 이름만 loginCheckFilter로 해줌.
setOrder는 2

UrlPatterns? 다먹여서 필터 호출 시 필터의 화이트리스트는 안바뀌니까 걍 `/*`로 다 걸어준다. WebConfig는 그냥 필터만 씌워주는 용도인듯?
이러면 성능 깎이는 거 아님? 성능은 바다에 모래알 수준으로 깎인다고 함.

> 이것도 프로젝트 따라서 다를지도

로그인 시 `/items`로 가고 싶다. 근데 지금은 홈으로 감.
그것도 추가해주자.

컨트롤러에서 기존 메서드를 변경해준다.

매개변수 추가.
`@RequestParam(defaultValue = "/") String redirectURL`

`redirect:/` -> `redirect: + redirectURL`
추가로 위와 같이 리턴 값을 바꿔주면 됨.

화이트 리스트? 인증 필터 적용하도록 홈, 회원가입, 로그인 화면, css 같은 리소스 접근할 수 있어야 한다. 이런 경로들은 인증과 무관하게 항상 허용 해줘야 함. 나머지 경로는 모두 인증 체크 로직 적용

return; -> 필터 내부에서 이거 해주면 필터를 더 진행하지 않기 때문에 그냥 거기서 요청이 끝나버림.



스프링 인터셉터는 제공하지 않는 강력한 기능도 제공함.
chain.doFilter(request, response);
호출 시, request, response를 다른 객체로 바꿔줄 수 있다. 서블릿Request, response를 구현한 다른 객체를 만들어 넘기면 해당 객체가 다음 필터 또는 서블릿에서 사용한다.
잘 사용하는 기능은 아니니 참고만 해두라고 함.

---

# 스프링 인터셉터

웹과 관련된 공통 관심사 효과적 관리
서블릿 필터는 서블릿이 제공
스프링 인터셉터는 스프링 MVC가 제공

적용되는 순서, 범위, 사용 방법이 다르다.

interceptor flow
```
http request - was - filter - servlet - spring interceptor - controller
```

디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전 호출됨
스프링 mvc가 제공하는 기능이기 때문에 디스패처 서블릿 이후 등장하게 된다. 스프링 mvc 시작점이 디스패처 서블릿이라고 이해하면 좋음
스프링 인터셉터에도 url 패턴 적용 가능. 서블릿 url 패턴과 다르고 매우 정밀하게 설정 가능.

여기도 제한 걸어줄 수 있다.

스프링 인터셉터 체인
필터와 동일하기 인터셉터 단계에서 인터셉터를 체인형태로 걸어줄 수 있다.
로깅, 로그인 여부 인터셉터를 각각 추가 가능.

서블릿 필터보다 편리하고 정교하고 다양한 기능 제공

preHandle, postHandle, afterCompletion
세가지 메서드 구현하면 됨

컨트롤러 호출 전
호출 후, 요청 완료 이후
세가지로 구분됨.

preHandle 호출 (컨트롤러, 정확히는 핸들러 어댑터 호출 전 호출)
핸들러 어댑터 ~ 핸들러
postHandle 호출 (컨트롤러, 정확히는 핸들러 어댑터 호출 후 호출됨.)

뷰 렌더링 후 afterCompletion 호출

컨트롤롤러에서 예외 상황 발생시?

이때 postHandle은 호출되지 않음.
afterCompletion은 항상 호출된다.

평소는 ex가 null인데 afterCompletion 시 예외사항이 생긴다.

그래서 결론적으로 afterCompletion은 예외 사항을 처리해줄 때를 위해 만들어진 것이라고 생각해주면 될 것 같다.
비동기랑도 엮어서 설명할 수 있지 않을까?



---

요청 로그 남기기

LogInterceptor

preHandle에서 requestURI, uuid를 만들어준다.

postHandle, afterCompletion에 넘겨줘야 하는데 못넘겨준다.
클래스 변수 만들어주면 싱글톤처럼 돼서 큰일난다.

그래서 logId로 받아주면 된다.

request.setAttribute("logId", uuid)
logId의 경우 상수로 클래스에 선언해서 LOG_ID 넣어주면 됨.

logId는 그럼 afterCompletion에서 requeset.getAttribute(LOG_ID)로 받아줄 수 있다.

> 원리가 뭔지는 모르겠다....


핸들러도 여기서 써줄 수 있다.

handler instanceof HandlerMethod
이것에서 알 수 있듯 핸들러는 핸들러 메서드를 쓴다!
호출할 컨트롤러의 모든 정보가 포함되어 있다.
그래서 preHandle은 logId, requestURI, handler를 찍어줄 수 있다.

그리고 리턴해줘야 한다. return true 해준다.
false는 여기서 끝나는 거고, 계속 흐름 가려면 true 해주면 된다.

postHandle은 modelAndView를 찍어줄 수 있다.

afterCompletion은 logId, requestURI, handler, ex(평소에는 null)
ex가 null인지에 따라서 에러를 찍어줄 수 있다.

이런 인터셉터는 WebConfig에서 등록해준다.


WebMvcConfiurer  implements를 표기해주고 addInterceptors를 구현해주면 된다.

```
registry.addInterceptor(new LogInterceptor())
		.order(1)
		.addPathPatterns("/**")
		.excludePathPatterns("/css/**", "/*.ico",d "/error");
```

order
우선순위
낮을 수록 높다.

addPathPatterns
서블릿이랑 패턴이 좀 다름.
위에는 하위는 전부 다 라는 뜻

excludePathPatterns
여기는 인터셉터를 적용하지 않는다.

핸들러 정보는 어떤 핸들러 매핑 사용하는가에 따라 달라짐..

나머지는 pdf 참고

PathPattern은 매우 정밀하게 지정해줄 수 있다!
? 처럼 한 문자 일치
`*` / 경로 안에서 0개 이상의 문자 일치
`**` 경로 끝까지 0개 이상의 문자 일치
이 외에도 많이 있다.

---

인증 체크

LoginCheckInterceptor

HandlerInterceptor 상속(구현)

preHandle 만 써주면 된다. 핸들러만 인터셉터 할끄니까~~~


HttpSession session = request.getSession으로 세션 가져온다.

인증체크
미인증? 리디렉션 처리로 날려버리자.
httpResponse.sendredirect()

화이트 리스크 체크 같은 번거로운 건 하지 않는다.
인터셉터 등록할 때 이미 끝내기 때문

인터셉터 등록은 똑같다.

```
registry.addInterceptor(new LoginCheckInterceptor)
.order(2)
.addPathPatterns("/**")
.excludePathPatterns("/css/**", "/*.ico", "/error", ...etc)
```

서블릿 필터, 스프링 인터셉터 모두 웹과 관련된 공통 관심사를 해결하기 위한 기술이다.
특별한 문제가 없다면 인터셉터를 사용하는 것이 좋다.

---

다음으로는 ArgumentResolver를 활용해보자.

1편의 요청 매핑 핸들러 어댑터 구조에서 설명된 바 있다.

@Login Member loginMember
이런식으로 하면 자동으로 쏙 들어오게 만들어주는 친구...

너는 로그인이 된 푸렌-즈구나!

사실 이것은 내가 만든 커스텀 어노테이션이다.
그래서 @ModelAttribute처럼 동작한다.

우리가 만든 ArguementResolver처럼 만들어줘야 한다.

HandlerMethodArgumentResolver를 상속받아서 구현시키자.

supportsParameter에 파라미터 정보가 넘어온다.


parameter.hasParameter(Login.class)로 해당 패러미터에 내가 찾는 어노테이션 있는지 확인

Member.class.isAssignableFrom(parameter.getParameterType());
member(우리 엔티티) 얘가 우리 타입인지 검사한다.
그 후 &&로 이 두개 boolean 타입 묶는다. 반환해준다.


resolveArguement
HttpServletRequest로 reqeust 뽑아내줌.
webRequest.getNativeRequest()

getSession 해준다.

세션이 null이면 null 반한
있으면 session에서 getAttribute로 가져온다.

이제 등록 해주면 된다!

addArgumentResolvers해서 return resolvers.add(new 우리가만든ArgumentResolver()) 해주면 된다!!!

캐시를 계속 타서 로그가 계속 뜨지는 않는다고 함(??)

