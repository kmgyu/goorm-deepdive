
서블릿 예외 처리

2가지 유형 존재
- Exception (예외)
- response.sendError (Http 상태 코드, 오류 메시지)

# 1. Exception
---

자바 직접 실행
자바 메인 메서드 실행 시 main이라는 이름의 쓰레드 실행됨
실행 도중 예외 잡지 못하고 처음 실행한 main() 메서드를 넘어서 예외 던져질 시, 예외 정보를 남기고 해당 쓰레드는 종료됨.

웹 애플리케이션
웹 앱은 사용자 요청별로 별도 쓰레드 할당, 서블릿 컨테이너 내부에서 실행
앱에서 예외 발생시 try - catch로 예외 잡아 처리 시 문제 없음.

예외 잡지 못하고 서블릿 밖으로까지 예외 전달 시 동작 방식을 알아본다.

**오류 발생 흐름**
```
WAS <- filter <- servlet <- interceptor <- controller (exception)
```

```properties
server.error.whitelabel.enabled=false
```
다음과 같이 꺼둬야 확인 가능

test code
```java
@GetMapping
public void runEx() {
	throw new RuntimeException("exception");
}
```

http status 500 - internal server error 반환

페이지가 없을 시 404 반환

톰캣이 줄 수 있는 페이지를 찾아서 준다. white label을 꺼놔서 톰캣이 줄 수 잇는 것으로 준다!

# 2. response.sendError
---

**오류 발생 흐름**
```
WAS(sendError 호출 기록 확인) <- filter <- servlet <- interceptor <- controller (response.sendError())
```

오류 발생 시 `HttpServletResponse`가 제공하는 `sendError` 메서드 사용 가능.
즉시 예외 호출이 아닌, 서블릿 컨테이너에게 오류 발생을 전달 가능.
Http 상태 코드 및 오류 메시지 추가 가능

`response.sendError(http status code)`
`response.sendError(http status code, error message)`

```java
@GetMapping
public void error404(HttpServletResponse response) throws IOException{
	response.sendError(404, "404 error");
}
```

> **참고사항**
> 메서드 자체가 IOException을 던지도록 되어있어 테스트 메서드 작성 시 throws IOException을 붙여주어야 함.

메시지들은 기본적으로 숨겨진다.



# 3. 오류 페이지 제공
---

WAS는 예외 발생 시 해당 예외를 처리하는 오류 페이지 정보를 확인함.
`RuntimeException`이 WAS까지 전달된다면, WAS는 오류 페이지 정보 확인.
해당 오류의 오류 페이지로 지정된 url에 페이지를 요청함.

**오류 페이지 요청 흐름**
```
WAS '/error-page/500' request -> filter -> servlet -> interceptor -> controller(/error-page/500) -> View
```

정리
1. 예외 발생, WAS까지 전파
2. WAS는 오류 페이지 경로 찾아 오류 페이지 호출
	1. 페이지 경로로 필터, 서블릿, 인터셉터, 컨트롤러가 모두 다시 호출됨.


과거에는 `web.xml`을 통해 오류화면 등록. 현재는 스프링 부트를 통해 서블릿 오류 페이지 등록 가능.

```java
import org.springframework.boot.web.server.ConfigurableWebServerFactory;
import org.springframework.boot.web.server.ErrorPage;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;

@Component 
public class WebServerCustomizer implements WebServerFactoryCustomizer {
	@Override
	public void customize(ConfigurableWebServerFactory factory) {
		ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error page/404");
		ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");
		ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error page/500");
		factory.addErrorPages(errorPage404, errorPage500, errorPageEx);
	}
}
```

오류 발생 시 이를 처리할 컨트롤러 연동

```java
@Slf4j
@Controller
public class ErrorPageController {
	@RequestMapping("/error-page/404")
	public String errorPage404(HttpServletRequest request, HttpServletResponse response) {
		log.info("errorPage 404");
		return "error-page/404"; 
	}
	
	@RequestMapping("/error-page/500")
	public String errorPage500(HttpServletRequest request, HttpServletResponse response) {
		log.info("errorPage 500");
		return "error-page/500";
	}
}
```

뷰는 생략한다.

## 오류 정보 제공

ErrorPageController에 다음 코드를 추가한다.

```java
//RequestDispatcher 상수로 정의되어 있음 
public static final String ERROR_EXCEPTION = "javax.servlet.error.exception"; 
public static final String ERROR_EXCEPTION_TYPE = "javax.servlet.error.exception_type"; 
public static final String ERROR_MESSAGE = "javax.servlet.error.message"; 
public static final String ERROR_REQUEST_URI = "javax.servlet.error.request_uri"; 
public static final String ERROR_SERVLET_NAME = "javax.servlet.error.servlet_name"; 
public static final String ERROR_STATUS_CODE = "javax.servlet.error.status_code";

// ....

@RequestMapping("/error-page/404") 
public String errorPage404(HttpServletRequest request, HttpServletResponse response) {
	log.info("errorPage 404");
	printErrorInfo(request); // 다음과 같이 printErrorInfo 삽입입
	return "error-page/404";
}

private void printErrorInfo(HttpServletRequest request) {
	log.info("ERROR_EXCEPTION: ex=", request.getAttribute(ERROR_EXCEPTION));
	log.info("ERROR_EXCEPTION_TYPE: {}", request.getAttribute(ERROR_EXCEPTION_TYPE));
	log.info("ERROR_MESSAGE: {}", request.getAttribute(ERROR_MESSAGE));
	//ex 의 경우 NestedServletException 스프링이 한번 감싸서 반환
	log.info("ERROR_REQUEST_URI: {}", request.getAttribute(ERROR_REQUEST_URI));
	log.info("ERROR_SERVLET_NAME: {}", request.getAttribute(ERROR_SERVLET_NAME));
	log.info("ERROR_STATUS_CODE: {}", request.getAttribute(ERROR_STATUS_CODE));
	log.info("dispatchType={}", request.getDispatcherType());
} 
```

그러나 이런 식으로 WebServerCustomizer부터 ErrorPage 추가, ErrorPageController를 만드는 과정은 매우 번거로웠다.

스프링 부트는 이런 과정을 모두 기본으로 제공한다.
- `ErrorPage`를 자동으로 등록한다. /error 경로를 기본 오류 페이지로 설정
	- 상태코드와 예외를 설정하지 않으면 기본 오류 페이지로 사용된다.
	- 서블릿 밖으로 예외 발생 시, resonse.sendError(...)가 호출되면 모든 오류는 /error를 호출하게 된다.
- BasicErrorController라는 스프링 컨트롤러를 자동으로 등록
	- ErrorPage에서 등록한 /error를 매핑해서 처리하는 컨트롤러

`ErrorMvcAutoConfiguration` 클래스가 오류 페이지를 자동으로 등록

> WebServerCustomizer는 @Component 주석처리해줄 것.

개발자는 BasicErrorController에서 제공하는 룰과 우선순위에 따라 아래와 같이 리소스를 등록하기만 하면 된다.

**뷰 선택 우선순위**
1. 뷰 템플릿
	- resources/templates/error/500.html 
	- resources/templates/error/5xx.html
2. 정적 리소스( `static`, `public`  ) 
	- resources/static/error/400.html
3. 적용 대상이 없을 때 뷰 이름(`error`)
	- resources/static/error/404.html
	- resources/static/error/4xx.html
	- resources/templates/error.html

상태 코드 이름의 뷰 파일을 넣어주면 된다.
구체적일 수록 우선순위가 높다.

BasicErrorController가 제공하는 기본 정보들


BasicErrorController 컨트롤러는 다음 정보를 model에 담아서 뷰에 전달한다. 뷰 템플릿은 이 값을 활용해서 출력할 수 있다.

* timestamp: Fri Feb 05 00:00:00 KST 2021
* status: 400 
* error: Bad Request 
* exception: org.springframework.validation.BindException 
* trace: 예외 trace 
* message: Validation failed for object='data'. Error count: 1 
* errors: Errors(BindingResult) * path: 클라이언트 요청 경로 (`/hello`)

그러나 오류 관련 내부 정보를 고객에게 노출하는 것은 좋지 않다.
따라서 해당 오류 정보를 model에 포함할지의 여부를 선택 가능하다.

application properties
```properties
server.error.include-exception=true 
server.error.include-message=on_param 
server.error.include-stacktrace=on_param 
server.error.include-binding-errors=on_param
```

기본 값이 never인 부분은 다음 3가지 옵션을 사용 가능함.
never, always, on_param
순서대로 사용 안함, 항상 사용, 파라미터 있을 시 사용

on_param은 디버그 시 문제 확인 위해 사용 가능. 운영 서버에서는 권장되지 않음.

`?message=&errors=&trace=`
위와 같이 http 요청 시 파라미터를 전달하면 해당 정보들이 model에 담겨서 템플릿에 출력된다.


추가 관련 옵션
`server.error.whitelabel.enabled=true` : 오류 처리 화면을 못 찾을 시, 스프링 whitelabel 오류 페이지 적용
`server.error.path=/error` : 오류 페이지 경로, 스프링이 자동 등록하는 서블릿 글로벌 오류 페이지 경로와 `BasicErrorController` 오류 컨트롤러 경로에 함께 사용된다

확장 포인트
ErrorController 인터페이스를 상속받아 구현하거나 `BasicErrorController`를 상속받아 기능을 추가하면 된다.

# 4. 필터 예외 처리
---

오류 페이지 출력 시 WAS 내부에서 다시 호출이 발생함.
내부적으로 오류 페이지 호출 시 필터나 인터셉터 호출되는 것은 비효율적

따라서 내부적인 오류 페이지 출력 요청인지 구분해줘야 한다.
이걸 위해 `DispatcherType`이라는 추가 정보를 제공한다.

### DispatcherType

REQUEST, ERROR, FORWARD, INCLUDE, ASYNC 등의 값이 존재하는 enum 클래스

```java
@Slf4j 
public class LogFilter implements Filter { 
	@Override 
	public void init(FilterConfig filterConfig) throws ServletException { 
	log.info("log filter init"); 
	} 
	@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { 
	HttpServletRequest httpRequest = (HttpServletRequest) request;
	String requestURI = httpRequest.getRequestURI();
	String uuid = UUID.randomUUID().toString();
	try { 
	log.info("REQUEST [{}][{}][{}]", uuid, request.getDispatcherType(), requestURI);
	chain.doFilter(request, response);
	} 
	catch (Exception e) { 
	throw e; 
	} 
	finally { 
	log.info("RESPONSE [{}][{}][{}]", uuid, request.getDispatcherType(), requestURI); 
	} 
	} 
	@Override public void destroy() { 
	log.info("log filter destroy"); 
	} 
}
```


logFilter에서 총 두 번 호출됨.
request 한번, exception으로 다시 올라올 때 한번
throw 시 was까지 올라가서 에러를 처리하게 됨.

```java
@Configuration 
public class WebConfig implements WebMvcConfigurer { 
	@Bean 
	public FilterRegistrationBean logFilter() { 
		FilterRegistrationBean<Filter> filterRegistrationBean = new 
		FilterRegistrationBean<>();
		filterRegistrationBean.setFilter(new LogFilter());
		filterRegistrationBean.setOrder(1);
		filterRegistrationBean.addUrlPatterns("/*");
		filterRegistrationBean.setDispatcherTypes(DispatcherType.REQUEST, 
	DispatcherType.ERROR);
	 return filterRegistrationBean;
    }
 }
```

setDispatcherType를 빼게되면 오류 페이지 내려갈 땐 안찍힌다
기본 값이 DispatcherType.REQUEST이기 때문. 따라서 클라이언트 요청이 있는 경우만 필터가 적용됨.
오류 페이지 경로도 필터 적용할 것이 아니면 기본 값 사용하면 됨.

오류 페이지 전용 필터 적용 시 DispatcherType.ERROR 지정해줘야 됨.

# 5. 인터셉터를 통한 예외처리
---

```java
@Slf4j public class LogInterceptor implements HandlerInterceptor { public static final String LOG_ID = "logId"; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String requestURI = request.getRequestURI(); String uuid = UUID.randomUUID().toString(); request.setAttribute(LOG_ID, uuid); log.info("REQUEST [{}][{}][{}][{}]", uuid, request.getDispatcherType(), requestURI, handler); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info("postHandle [{}]", modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { String requestURI = request.getRequestURI(); String logId = (String)request.getAttribute(LOG_ID); log.info("RESPONSE [{}][{}][{}]", logId, request.getDispatcherType(), requestURI); if (ex != null) { log.error("afterCompletion error!!", ex); } } }
```

excludePathPatterns 기능 제공.
해당 기능으로 에러 페이지 혹은 그 하부 경로를 제외시킬 수 있다.
이를 통해 중복 실행을 방지한다.

대신 디스패쳐 타입 세팅 불가

전체 흐름 정리
`/hello` 정상 요청
```
WAS(/hello, dispatchType=REQUEST) -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러 -> View
 ```
`/error-ex` 오류 요청
필터는 DispatchType으로 중복 호출 제거 (`dispatchType=REQUEST`)
인터셉터는 경로 정보로 중복 호출 제거( `excludePathPatterns("/error-page/**")` )
 ```
1. WAS(/error-ex, dispatchType=REQUEST) -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러
2. WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)
3. WAS 오류 페이지 확인
4. WAS(/error-page/500, dispatchType=ERROR) -> 필터(x) -> 서블릿 -> 인터셉터(x) -> 컨트롤러(/error-page/500) -> View
 ```
