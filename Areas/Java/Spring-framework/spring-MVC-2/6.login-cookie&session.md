이번 실습 프로젝트 구조는 domain이랑 web이랑 분리해둠
도메인은 웹과 관련된 코드를 다 들어내서 의존성이 존재하도록 하면 안된다고 함.

간단하게 분리해주면 되지만, 몇몇 복잡한 케이스들이 존재
form을 웹에다 두고, 리포지토리 같은 데서 form을 참조하게 될 시 웹을 참조하게 되는 것.

예제에서는 리포지토리를 해시맵으로 빠르게 테스트만 함.

회원가입, 로그인 각각 구현
Optional 컬렉션으로 한번 래핑해준다.
findBy~~ 뒤에 filter()를 붙여서 맞는지 확인하고 orElse()로 if else문 압축이 가능하다.

글로벌 오류
아이디 또는 비밀번호가 맞지 않은 경우
Valid 같은 유효성으로 검증하기 어려움.
글로벌 에러 ObjectError 생성.

---

로그인을 성공하면 로그인 처리 후 페이지로 이동해야 한다.
쿠키를 사용하는 것을 알아본다.

Http는 stateless.
브라우저는 캐시를 통해 어떤 데이터를 저장하고 관리한다.
로그인 성공 시 서버에서 쿠키를 전달해주면 브라우저는 캐시에 저장한다.

영속 쿠키, 세션 쿠키가 있다.
세션 쿠키는 만료 날짜를 생략하는 것. 브라우저 종료 시까지만 유지
영속 쿠키는 만료 날짜까지만 유지

로그인 컨트롤러에서 쿠키를 직접 만들어본다.

Cookie 클래스를 통해 만들어줄 수 있다.
new Cookie(name, value)로 만들어주고 응답에 넣어준다.
HttpServletResponse 객체에 .addCookie()

쿠키는 패러미터가 많은데, 시간 정보를 넣지 않았기 때문에 세션 쿠키가 된다.
여기선 세션 쿠키를 사용한다.

그럼 이렇게 만들어진 쿠키를 어떻게 활용하나?
@CookieValue(name = "memberId", required = false) Long memberId
형식으로 파라미터를 설정해줄 수 있음.
이제 PK 주니까 리포지토리에서 가져올 수 있다!

물론 이렇게 인증 시스템을 만들면 보안 팀이 등에 칼을 꼽을 수 있으니 이렇게 해서는 안된다.

브라우저등에서 쿠키 조작을 가능하고, 이 때문에 위변조가 가능함.
쿠키는 탈취도 가능하다.
사용자 로컬에서, 네트워크 전송 구간에서 탈취도 가능하다.

탈취한 순간 사용자 정보를 알게된다.

한번 훔쳐가면 평생 사용 가능

대안
중요 값 노출 x, 임의 토큰 값 노출.
서버에서 토큰과 사용자 id를 매핑해서 인식. 서버에서 토큰을 관리
토큰은 해커가 임의 값을 넣어도 찾을 수 없도록 예상 불가능해야 한다.
해커가 토큰을 탈취해도 일정 시간이 지나면 사용할 수 없도록 서버에서 토큰 만료 시간을 짧게 유지한다. 해킹 감지하더라도 서버에서 해당 토큰을 강제로 제거하면 된다.


---

쿠키는 보안 이슈. 추정 불가능한 임의 식별자는 어떻게 만드나?

UUID라는 자바에서 지원하는 고유한 아이디를 만드는 기능
중복값이 나오기 매우 힘든 값

생성된 세션 id와 보관할 값을 서버의 세션 저장소에 키-값 형태로 보관

세션id를 응답 쿠키로 전달

클라이언트와 서버는 결국 쿠키로 연결되야 함.
그러나 회원과 관련된 정보는 클라이언트에 전달되지 않음.
추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달

세션 사용해 서버에서 중요한 정보 관리
- 쿠키 값 변조 -> 예상 불가능 ID 사용
- 쿠키 보관 정보가 없으므로 ID 탈취당해도 개인정보 탈취 불가
- 쿠키 탈취 후 사용? -> 서버에서 세션 만료 시간을 짧게 준다.

> JWT와 차이점은 클라이언트가 정보를 저장하는 거어엇
> 그래서 보안이 더 취약함.

그럼 리프레시 토큰을 통해 액세스 토큰을 재발급받게 되는데... 리프레시 토큰만 보내지 않는 것인가?

UUID.randomUUID().toString()

컴포넌트 SessionManager에서 createSession, getSession, findCookie, expire를 만든다.
findCookie를 통해 쿠키에서 세션ID을 갖고온다. getSession을 통해 세션을 가져온다. expire를 통해 만약 findCookie에서 찾지 못할 경우 제거한다.
일종의 목업임. 볼때마다 느끼지만 현업에서도 테스트할 때 이렇게 허술하게 만드는 건가? 

---

V2 만들기

직접 만든 세션을 적용한다.
SessionManager를 컨트롤러에 넣는다.
getSession으로 member 세션 가져오기만 하면 된다.
addAttribute로 폼에 넣어주면 된다!

세션 관리자가 저장 정보 조회, 회원 정보 없으면 로그인 안된 것으로 처리함.

> MVC에서나 이렇지, JSON 쓰면 달라진다. 하하하

세션을 일정 시간 사용하지 않으면 해당 세션을 삭제하는 기능을 만들어보자.

---

서블릿은 세션을 위해 HttpSession이라는 기능 제공
우리가 직접 만든 SessionManager와 똑같은 방식으로 동작한다.

SessionConst라는 인터페이스를 만들어서 LOGIN_MEMBER라는 값을 설정해줌.

createSession하는 부분을 아래와 같이 바꿈.

```java
// 세션 있으면 있는 세션 반환, 없으면 신규 세션 생성
HttpSession session = reqeust.getSession();
// 세션에 로그인 회원 정보 보관
session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember);
```

세션 create 옵션
request.getSession(true)
- 세션 있으면 기존 세션 반환
- 없으면 새 세션 생성 및 반환

reqeust.getSession(false)
- 세션이 있으면 기존 세션 반환
- 세션 없으면 새 세션 생성 안함. null 반환

setAttribute 로 여러개의 세션 정보 저장 가능

지우는 법?
request.getSession시 false하면 만들지 않는다.
만약 가져온 세션이 null이 아닐 시, session.invalidate() 해주면 세션 및 관련 정보를 날려준다.

JSESSIONID라고 무언가 붙어있는 것을 확인할 수 있다.

request를 패러미터로 받아서 뭔가 하는 것이 불편할 것.
따라서 스프링 지원 기능으로 바꿔보자

@SessionAttribute(name = SessionConst.LOGIN_MEMBER, required=false) Member loginMember

다음과 같은 패러미터를 넣어줄 수 있다. 번거로운 과정을 생략할 수 있다!

로그인 첫 시도 시 JSESSIONID가 url에서 노출되는 것을 볼 수 있다.
location과 Set-Cookie 두가지가 쿠키를 사용한다.

url에 있는 값을 이용해서 세션을 보존해주는 것인데... 이걸 계속 포함해야 하기 때문에 거의 사용하지 않는다.
서버 입장에서는 웹 브라우저가 쿠키 지원하는지 최초에는 판단하지 못하므로 쿠키값과 url에 jsessionid도 함께 전달한다.

properties에 다음과 같이 입력해 항상 쿠키를 통해 세션 유지를 하도록 설정해줄 수 있다.
```
server.servlet.session.tracking-modes=cookie
```

---

세션 정보와 타임아웃 설정하기


세션의 정보 먼저 확인해본다.

기본 제공 데이터들 (83번 강의 보면 forEach 쓰는 다른 코드도 있다.)
```
session.getId()
session.getMaxInactiveInterval()
session.getCreationTime()
session.getLastAccessedTime()
session.isNew()
```
순서대로
세션 id
유효시간
생성 일시
최근 접근 시간
새로 생성되었는지 여부


타임아웃 설정
세션은 사용자가 로그아웃 직접 호출 해 session.invalidate()가 호출되는 경우 삭제된다. 대부분 사용자는 로그아웃 선택하지 않고, 그냥 브라우저를 종료한다. HTTP는 비연결성이므로 서버 입장에서는 해당 사용자가 브라우저를 종료한 것인지 아닌지 인식할 수 없다. 따라서 서버에서 세션 데이터를 언제 삭제해야 하는지 판단하기 어렵다.

이 경우 남아있는 세션을 무한정 보관시 문제 발생
- 세션 관련 쿠키 탈취 시 오랜 시간 지나도 해당 쿠키로 악의적 요청 가능
- 메모리에 저장되므로 나중에는 엄청난 양의 세션을 관리해야 함.


**세션 종료 시점**
어떻게 설정할까?
생성 시점으로부터 30분. 그런데 계속 활동하다 30분 마다 로그인해줘야 하는 번거로움 발생.
대안은 서버 최근 요청 시간 기준으로 30분 정도만 유지시키기.
이렇게 하면 서비스 사용 계속 할 시 세션 생존시간이 30분으로 계속 유지된다.
번거로움이 사라진다. HttpSession은 이 방식을 사용한다.


세션 타임아웃 설정
properties에서 설정해줄 수 있다.
`server.servlet.session.timeout=1800` (30분)
글로벌 설정은 분 단위로 설정해야 한다.

세션 타임아웃 발생
세션 타임아웃 시간은 해당 세션과 관련된 JSESSOINID를 전달하는 HTTP 요청이 있으면 현재 시간으로 다시 초기화된다. 이렇게 초기화되면 세션 타임아웃으로 설정한 시간동안 세션을 추가로 사용할 수 있다.

`session.getLastAccessedTime()` : 최근 세션 접근 시간

`LastAccessedTime` 이후로 timeout 시간이 지나면, WAS가 내부에서 해당 세션을 제거한다.

서블릿이 HttpSession이 제공하는 타임아웃 기능 덕분에 세션을 안전하고 편리하게 사용할 수 있다.
실무 주의점?
세션에는 최소한의 데이터만 보관
사용자 수 `*` 보관한 데이터 용량으로 메모리 사용량이 급격하게 늘어나 장ㅇ로 이어질 수 있다.
세션 시간을 너무 길게 가져가면 메모리 사용 누적될 수 있으므로 적당한 시간 선택 필요. 기본이 30분임.

---

로그아웃한 사용자는 세션 필요 페이지에 들어가면 안됨.
다음 장에서는 필터, 인터셉터를 통해 로그인 안된 사용자 거르기를 해본다.
