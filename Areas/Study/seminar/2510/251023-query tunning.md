준영님 발표

인덱스의 유형
클러스터링 인덱스
테이블 실제 데이터가 인덱스 순서대로 저장

특징
- 한 테이블당 하나
- 범위 검색, 정렬, 순차 접근 빠름.
- PK 컬럼 주로 사용


논클러스터링 인덱스
인덱스만 별도 저장, 실제 데이터는 다른 위치. 인덱스는 데이터의 포인터를 가리킴
특징
- 한 테이블에 여러 개 가능
- 특정 컬럼 검색, join, where 조건에 유리
- 정렬은 클러스터링만큼 빠르지 않음.

CQRS
명령과 조회의 책임을 분리하는 소프트웨어 아키텍처 패턴

- 커맨드 : 데이터 변경 작업(CUD)을 처리
- 쿼리 : 데이터 조회(R) 작업만 처리
웹 측면은 Command, Query 분리 패턴이 유용하다.

정규화를 많이 할 수록 쓰기는 더 쉬워지나 읽기가 더 어려워지기 때문에 전체 읽기 성능에 영향을 미침.
대부분의 웹 기반 어플리케이션은 읽기 요청이 많다.

구현 방법?
1. 읽기와 쓰기 컨트롤러를 나눈다.

@ConditionalProperty
havingValue의 true false 여부를 통해 구별한다.

---

# B-Tree(균형) vs FullText index vs hash index

## B-Tree

검색, 삽입, 삭제 연산이 O(log n) 안에 수행되도록 설계됨.
MySQL에서 가장 일반적

사용할 때 좋은 곳?
정확한 값 검색 자주 일어날 때
범위 검색 필요할 때
like 접두사 검색에 유리할 때
> 단, 접미사 검색 시 비효율적

## Full-Text index
특정 단어(키워드) 검색 시 최적화된 인덱스

MySQL InnoDB, MyISAM에서 지원하는 기능
긴 텍스트 검색에 특화됨
자연어 검색 지원.
B-Tree와 다르게 범위 검색, 정렬보다 텍스트 검색과 관련성 순위에 강점 존재

따라서 사용하기 좋은 곳은
- 텍스트 포함 검색
- 자연어 검색, 관련성 순위 검색
- 긴 문자열 컬럼에서 like 검색 비효율적일 때
- 여러 단어 검색 시

## Hash index

키 값을 고정 길이 해시 값으로 변환, 이를 기반으로 데이터를 빠르게 조회.


- 주로 메모리 기반 스토리지에서 사용

장점
등호 검색 속도 매우 빠름
메모리 사용 효율적

범위 검색 불가
충돌 발생 시 비효율적



## 단일 인덱스 vs 복합 인덱스

인덱스 저장 위해 추가적 저장 공간 필요
조회 속도는 빨라지나 나머지 쓰기 연산들은 성능 저하 발생.
복합 인덱스는 두 개 이상 컬럼 조합. 따라서 더 느려질 것임.



---

조인 및 서브쿼리 최적화

1. 조인 순서 변경
2. 서브 쿼리 -> 조인 변환
3. IN vs EXISTS vs JOIN 비교
4. Derived Table (파생 테이블) 최적화
with 문으로 파생 테이블 생성? alias도 파생 테이블 만드나?
오버헤드랑 메모리 추가 소모한다고 함.
5. InnoDB vs MEMORY vs MyISAM
MyISAM은 트랜잭션을 지원하지 않고 잠금단위가 테이블. 읽기 중심 시스템에서 사용한다고 함!


Buffer Pool, Query Cache 활용
버퍼 풀은 InnoDB의 핵심 캐시로, 데이터/인덱스 페이지를 메모리에 저장한다. 클수록 디스크 I/O가 감소하여 성능이 향상된다고 함.


InnoDB Row-level Lock과 MVCC 이해
Row-level lock? 행단위 잠금으로 동시성 향상
MVCC : 트랜잭션 간 일관성 유지 및 읽기/쓰기 충돌 최소화


통계 및 파티셔닝
- ANALYZE TABLE로 통계 갱신
	이걸 토대로 성능 분석 가능
- 파티셔닝
	테이블을 특정 기준으로 분할 가능
- 히스토그램 통계 기반 옵티마이저 제어


# CTE (Common Table Expression)

개념?
쿼리 내 임시 결과 집합을 이름으로 정의해 재사용할 수 있다.
with 키워드로 선언. 재귀 쿼리 등에서 유리하다.


# 실행 계획 분석

EXPLAIN, ANALYZE로 실행 계획 분석
- 어떻게 쿼리를 실행할지 계회을 보여주는 도구
- EXPLAIN : 실행 전 계획만
- EXPLAIN ANALYZE : 실제 실행 후 수행 시간, 행 수 까지


# 쿼리 구조 개선

- SELECT `*` 지양, 필요 컬럼만 조회
- DISTINCT, GROUP BY, ORDER BY 최소화
- LIMIT, OFFSET 최적화 (커서 기반 페이징)
- CTE 활용



---

> offset이 문제가 되는 경우?
> 전 페이지의 가장 마지막에 있던 상품이나 정보가 다음페이지로 넘어갔는데 동일하게 첫번째로 나오는 경우가 있음.
> 커서는 이걸 조금 더 최적화해줄 수 있다.

> CQRS
> 컨트롤러 나누기?
> 시스템이 커지게 되면 아키텍처 구조에서 이걸 도입 시킨다.
> 읽기랑 쓰기를 분리하고 프록시로 연결하는 식으로 구조화하는 것이 있음.
> 스프링 시큐리티 같은 것도 nginx 프록시 서버 앞에다가 달아버리고 역할 분리를 명확하게 하는 방식


> 재귀 CTE?
> 여러 테이블이 엮여 있어서 참조를 엄청나게 해야한다고 할 때, 이걸 어떻게 해야 됨?
> 이런 것에 대한 동작이 어떻게 되는지?
> 복잡한 서브 쿼리를 단순하게 재사용 가능한 목적은 좋지만, 실시간성이 필요하거나 변경이 되야하는 것, 또는 요청이 많은 것이 있다면 그렇게 좋은 방법은 아님.
> 그렇다면 실시간성이나 많은 요청 감당하기에 적합한 테이블은?
> DB 캐싱도 물론 방법이지만 다른 방법도 존재한다. 미리 뷰테이블 같은 것으로 쿼리를 작성하여 특정 집합을 만들어줄 수 있다.
> 반복적으로 사용하거나 실시간성에서 더 좋은 성능을 발휘할 수 있다.
> 뷰도 근데 좀 느리지 않나? CTE의 경우는 계층적 데이터 탐색을 위한 경우이기 때문에 트리 전체 탐색이라 그래도 뷰가 더 빠르다고 함.


neo4j라는 것이 있음.
그래프 기반 탐색을 가능하게 해준다.
그림처럼 나타내게 해주고 관계 같은 것에 치중한 DB 구조
