민성님 발표

가비지 컬렉션

장애 사항이 나왔을 때 가비지 컬렉션을 통해서 분석을 해야 한다.
따라서 오늘 할 내용이 중요할 수 있다!

> 자바는 메모리 관리하는 경우는 없다.
> JVM이 대신 해결해주는 데, 어떤 게 차이점일까?

C의 경우
malloc()처럼 명시해줄 수 있음.

메모리 생명주기를 개발자가 관리하게 되면?
맹글링 포인터
메모리 해제된 영역을 가리킬 수 있다.

메모리 누수
사용되지 않는 메모리 할당 해제가 제대로 이뤄지지 않을 수 있다.

보일러 플레이트 코드
비즈니스 로직 코드보다 메모리 할당, 해제에 대한 코드가 더 많이 자리 잡을 수 있다.

오류 발생 가능성
숙련된 개발자도 실수 발생 가능성 존재

메모리 이중 해제
이미 해제된 메모리를 또 해제할 수 있고, 오류 발생 가능

---

자바 메모리 구조 JVM 메모리 구조

Execution Engine
런타임에서 실제 코드 실행을 담당하기에 중요한 부분

메서드 / 스택 / 힙 영역을 가진다.
메서드에는 상수 풀, static, 클래스 정보
스택 영역에는 실행하는 클래스들...
힙 영역에는 객체 인스턴스들이 들어간다.

# GC

JVM이 메모리 힙 영역에서 더 이상 사용되지 않는 점유된 메모리를 제거

용어

- Stop the world
	- GC 작업 담당 스레드 외에 모든 실행이 정지된다.
- GC 튜닝
	- GC로 인한 정지 상태 최소화

java 7즈음에 perm(permenant)라는 영역이 제거되었다고 함.

young 영역, old 영역을 합쳐 힙 영역이라 부름

young은 Eden, S0, S1이 들어감
비율은 2:1?

## Old, Young의 구조

weak generational hypothesis
약한 가설 기반 구조
1. 대부분 객체는 금방 접근 불가능
객체 생성 및 사용 시 블럭 단윙에서 동작
특수한 경우 제외 접근 불가 상태가 된다.
아무도 사용하지 않는 메모리 공간만 차지하는 상태가 되는 것
2. 오래된 객체에서 젊은 객체로의 참조는 아주 드물게 발생한다.
객체 생성 및 로직 수행 후 대부분 사용되지 않음.
DTO 사용 시 요청에서 한번 사용 후 다음 요청에서 새롭게 생성하는 것. 그 예시
싱글톤 같은 경우는 특수한 케이스


## GC 알고리즘

Reference Counting Algorithm
각 개체마다 Reference Count가 존재.
카운트가 0이 되면 GC 대상이 되는 방식

순환 참조의 경우 0이 되지 않는 문제 존재

Mark and Sweep Algorithm
Root Set(RSet)에서 Reference를 추적해 참조 상황을 파악

Root는 GC가 시작하는 출발점이 되는 참조들의 집합

Root 종류
1. Stack Scanning
2. Method Area Scanning
3. JNI References
4. System References
5. Thread
다 찾아볼 것!

1.Mark
Root로부터 Reference 하는 대상(객체)에 Mark 작업
2.Sweep
마킹되지 않는 객체를 메모리에서 삭제
이후 마킹 정보 초기화

동작 프로세스

```
GC start - STW - Mark - Sweep - STW 해제
```

STW 동작 시 시스템이 일시적으로 멈춘다.
이걸 줄이기 위한 것이 튜닝
Compaction 작업이 없어 Fragmentation이 해결되지 않아 OOM 발생할 수 있다.


메모리 단편화 현상!
이걸 개선한 것?

Mark and Compact Algorithm
```
GC start - STW - Mark - Sweep - Compact - Reference update - STW 해제
```

Compact : memory 압축 작업

Compact 시키면서 주소 값을 변경하게 된다.
기존 참조하는 객체들에 주소 값을 업데이트 시키는 것임!

오버헤드가 조금 더 생기지만 OOM 문제를 해결한다.

공통 특징
전체 힙 영역을 하나로 취급
나머지 3가지정도 특징 존재

## Generational Algorithm

현대적 방법
최대한 간단하게 알아본다.

1. 처음 객체 생성 시 Eden 영역에 생성
2. Minor GC 수행 (에덴 꽉찰 시)
	- 미사용 객체 제거
	- 사용되는 객체는 S0, S1로 이동
	- 이동해야하는 객체 크기가 survival 영역 크기보다 크면 old로 바로 이동
3. S0, S1 중 한 공간에만 객체가 존재하게 함
	- 객체 존재 영역을 From, 존재하지 않은 영역을 To 라고 함.
	- 기존 Survival (From) 영역이 가득 차면 다른 Sruvival(To)로 보내고 기존 영역 초기화

> 복사하는 과정에서 추가적인 메모리가 필요하기 때문에, 오버헤드를 줄이기 위해 미리 비워놓은 공간 하나를 추가로 증설하는 것.

5번의 단계 존재




GC 종류
1. serial
cpu 하나로 young, old를 연속적 처리
오래 걸리며 mark-and-compact algorithm 사용
STW 발생
2. parallel
자바 8 기본 GC 방식
GC 작업 병렬 처리, STW가 더 짧다.
3. parallel compacting
기존 parallel 방식에서 old 처리 알고리즘을 개선(다른 거 사용)
4. concurrent mark-sweep(CMS)
어플리케이션 Thread, GC Thread가 동시에 실행되어 STW 최소화
Compaction 작업 안함
5. Garbage First(G1)
현대에는 이걸 사용함.
전체 힙 영역을 region이라는 영역으로 분할해 동작
- Eden, young, old 등 모든 영역이 region으로 관리됨
region 크기는 고정
homonogous : region 크기 50% 초과하는 큰 객체를 위한 공간
Available, Unused : 아직 사용되지 않는 region
큰 메모리에서 사용하기 적합
Compaction도 진행
- 리전 단위 분리를 통해 다른 GC 압축과 달리 동시성 보장.

동작 프로세스
Initial Mark
Root Region Scan
Concurrent Mark
Remark
Cleanup
Copy

6. Z
Z page라는 영역을 사용해 G1의 Region과 다르게 2mb 배수 단위 동적으로 동작
STW 시간이 10ms 미만을 목표로 하는 방법
힙 크기 커져도 STW 시간이 증가하지 않음

저장 자체를 효율적으로 해서 GC 가능성 자체를 줄이는 방법
GC 했음에도 힙 객체들이 전부 참조될 시 OOM 발생

해결하기 위해...
참조를 강한 참조, 부드러운(soft) 참조, 약한 참조 분류를 한다.

Strong Reference는 수거 대상 제외
Soft는 수거될수도 있고 아닐수도 있고
Weak는 무조건 GC 수거 대상. 그 연관 객체들도 다 수거

개발자가 최적화할 수 있는 여지 존재

결국 GC 시 STW가 발생할 수 있어 문제 발생 가능.
데이터 처리가 많은 경우 더욱 문제

0.1초에 트랜잭션 178개 처리한다면, 프로그램이 0.1초만 멈추는 것도 치명적이다.

> 해결책

기존 Young, Old Generation 영역의 비율은 2:1.
이걸 임의로 설정해 개선할 수 있다.
빨리 사라지는 객체가 많으면 Young을 키우는 것이 장점이 될 수 있다. 오래 살아있는 객체가 많다면 Old.



일정 비율 도달 시 GC 발동하는가?

설정 영역이 특정 비율 넘기거나, OOM 발생할 때...
GC 용량 설정해주는 것도 있고 시간으로도 세팅 가능.
미리 메모리를 정리해두는 설정도 있어서 강제 GC를 해줄 수도 있음.

> Survivor 리전 나눠서 저장하게 되는데, Generation Algoritm에서는 Copy 작업을 하게된다.
> 1:1 매칭 같은 것을 해서 복사 시 고정을 시켜둔다던지, 복사할 때 사용하는 region이 있는가?

