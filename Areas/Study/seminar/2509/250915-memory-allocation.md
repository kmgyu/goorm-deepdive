민성님 발표

메모리 할당 방식

연속 메모리 할당
메모리 상에 프로세스들이 연속적으로 할당되는 방식

커널영역 이후 프로세스 A,B,C,D 등의 사용자 영역

스와핑
컨텍스트 스위칭에서 언급되었던 것

공간이 꽉 차서 현재 잠깐 중단된 프로세스를 보조기억장치로 보내고 현재 실행해야 하는 프로세스를 적재하는 방식

`vm_stat`을 통해 메모리 통계를 확인 가능함.

관리하는 것에 페이지 방식도 있다.

더 구체적인 메모리 할당 방식
OS가 프로세스를 실행시키다 보면 빈공간이 생긴다.
할당하려고 봤을 때 빈 공간의 크기가 다양함. 연속된 공간에 저장해야 활용하기 좋다.
first-fit, best-fit, worst-fit 세 가지 방법 이때 나온다.
first-fit : 검색 최소화, 빠른 할당, 구현 복잡도 낮음
best-fit : 효율적 메모리 공간 사용, 전위 탐색. 속도 느림
worst-fit : 프로세스 자체가 연속적으로 확장이 필요한 경우 대비 예비 공간 확보.

단점 : 외부 단편화
총 빈 공간이 100mb여도, 20, 50, 30 이렇게 분리되어있어서 실제로 100mb 프로세스를 넣을 수 없음.

이런 것들은 메모리 자원 낭비로 이어짐.
메모리 스왑, 3가지 적재 방식 모두 동일

해결책?
메모리 압축
메모리를 재배열하여 프로세스 사이의 빈공간을 없앤다.
오버헤드 발생, 압축 과정 중 프로세스 중단이 발생한다.
> 연속 메모리 할당 방식이 아니라면?
> 불연속 메모리 할당 방식은 메모리 압축이 필요한가?

가상 메모리
프로그램 일부만 메모리에 적재

페이징
동일한 프로세스를 일정한 크기로 조각내어 저장하는 방식
메모리가 부족한 공간에서 동작하는 것을 가능하게 함.

> 스레드는 어떻게 작동을 하나?

불연속적으로 적재된 페이지는 어떻게 사용?
페이지 테이블을 통해 사용
메모리 상에는 불연속, cpu 상에서는 연속적
> 그럼 불연속 메모리 할당아닌가?

페이지 테이블은 메모리에 직접 올린다고 함.

그럼에도 불구하고 내부 단편화 존재
공통 페이지 크기보다 작은 페이지가 존재하여 공간적으로 낭비된다.
> 극복 방법은?

각 프로세스마다 존재하는 페이징 테이블은 어떻게 관리될까?
cpu 내부의 프로세스 테이블 베이스 레지스터 존재
메모리의 프로세스 페이지 테이블에 각각 조회함.
단점으로 두 번 이상 메모리 접근

개선
TLB : cpu에서 페이지 테이블을 제공하는 캐시

자주 참조 영역을 메모리 페이지 테이블에서 일부 가져와 캐싱해 사용
캐시 히트 시 1번, 미스시 2번 메모리 접근

논리주소 - 물리주소
논리 : 페이지 번호와 변위로 구성
물리 : 프레임 번호와 변위로 구성

그렇다면 변위(offset)이 같을까? -> 같다. 프레임과 페이지는 같은 크기이기 때문

페이지 엔트리 테이블
페이지 번호, 프레임 번호 외에도 유효비트, 보호 비트, 참조 비트, 수정 비트 등 다양한 비트 존재

여기까지 페이징 관리 방식

---

페이징의 이점
fork()를 통한 자식 프로세스 생성

fork 방식도 두가지로 나뉨
#todo 집중해서 몼씀
쓰기 시 복사


바깥 페이지 내부 페이지 이런식으로 논리주소로 관리를 할 수 있는 이점 존재
페이징을 작게 만들어서 큰 파일을 관리하기 쉬워진다.
그러나 관리가 복잡해진다.

요구 페이징

페이지 교체 알고리즘
FIFO 
에이징 정책, Page Fault 시 어떻게 교체할 것인가


프레임 할당

스레싱( #todo 영문 적을 것)
페이징으로 인한 오버헤드가 많아져서 프로세스 실행보다 커짐. 결국 성능 저하 이슈

보통 메모리 부족, 나쁜 페이지 교체 알고리즘으로 인해 발생
스레시 홀드 라고도 한다고 함.

동시 실행 프로세스 수를 늘리는 것이  cpu 이용률을 늘리는 것은 아님
정책 선정, 메모리 이용률이 부족하게 되면 이런 것이 일어남

page fault 빈도?
할당 프레임 수, 페이지 폴트율로 상한선과 하한선을 표기해 어떤 정책과 알고리즘을 사용해야 하는지 선정하게 됨.

균등 할당, 비례 할당, 작업 집합 모델 등...

> 정책, 알고리즘의 결정은 누가 하나?
> 환경에 따라 선택 가능. CPU, 컴퓨터 OS 상태에 따라 실시간으로 할당된 프레임 수, page fault 율을 뽑아낼 수 있다.

페이지 프레임 단위에 따라 오버헤드 차이가 생김.
컴파일러나 인터프리터에서 이런 페이징 최적화 방식이 존재함
arm 아키텍처의 경우 모바일 프로세스에서 사용하는 셋이 있는데 요즘은 상향 평준화가 되었다. 5년 이전까지는 성능 차이가 존재했음.
그 예시로 삼성 아키텍처의 칩셋은 intel이 들어간 적이 없었음.

> 발전 방식으로 설명하시는 것으로 보임.


> 그림자료는 직접 만드시나? 책에서 가져오시는 건가?


개발자 입장에서 어떻게 하는 게 개발할 시 장점이 있을까?
스와핑, 페이징 개념 정도는 알면 좋지 않을까.


> 스레드는 어떻게 관리됨?

프로세스 하나하나를 실행시키는 작업 단위를 하나씩 물고 있다.
하나당 하나씩 할당 받는다.
멀티 쓰레드라면 여러명이 여러개를 할당 받는다?

정책 상 연산이 많이 필요할 경우?
파이썬하는데 이미지 프로세싱, 암호화 처리과정, 컴파일링 과정 필요
이때 멀티 스레딩 기술 적용하면? 좋다.
> 내가 원한 답은 이게 아니야!!!
> 사실 나도 내가 원하는 답을 잘 몰랐었다.
> 메모리에서 스레드의 컨텍스트. 스택 포인터 같은 건 어떻게 관리되는지 물어봤어야 함.


> 이렇게 머리아픈거 오랜만인듯
> 어떻게 작년이랑 똑같이 날 머리아프게 할 수 있지?

고정 분할이면서 세그먼테이션 쓸 수도 있고, 가변 분할이면서 페이징 쓸수도 있었던 거같은데

