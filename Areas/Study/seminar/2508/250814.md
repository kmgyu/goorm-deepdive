스프링 프레임워크 빈 스코프 내용


빈 생명주기

스코프
싱글톤
프로토타입
웹 스코프

프로토타입 빈

요청하면 만들어줌
반환하면 스프링 컨테이너가 관리를 안해준다.

싱글톤, 프로토타입 병행 시?
싱글톤은 stateless. 프로토타입을 담게 되면 문제가 생긴다.
프로토타입은 stateless하지 않기 때문.

해결하는 법

Dependency Lookup
getBean()의 동작
싱글톤? 이미 생성된 빈 반환
프로토타입? 매번 새로운 빈 생성후 반환
Request/Session/WebSocket? 웹 요청/세션 시작 시점에 생성, 그 범위 내에서 재사용
하기 힘듬

ObjectProvider, ObjectFactory
간단한 DL 인터페이스

JSR-300
자바 표준 기능. 프레임워크 비종속적
라이브러리라서 따로 받아와서 사용해야함.


Provider라는 타입의 객체로 반환을 받게된다.
이 방식은 lazy 생성을 가능하게 한다.


웹스코프

request
session
applicaton
websocket

총 4가지의 스코프 존재.


Provider는 만들어지는 당시에는 프록시 객체를 만들어준다.
요청될 시 Lazy하게 빈을 주입해줌.


스프링이 request scope를 어떻게 처리할가?
HTTP 요청 처리 시, DispatcherSurvlet이 요청을 받아 쓰레드 로컬 같은 요청 전용 저장소에 정보를 넣는다.
@Scope빈은 사실 내부적으로 RequestContextHolder라는 객체에 의존
- HTTP 요청 시작 시 Spring이 RequestAttributes를 ThreadLocal에 저장
- 요청이 끝나면 해당 ThreadLocal을 정리(빈 소멸자 호출)
즉 코드가 어느 요청 안에서 실행되는지는 ThreadLocal에 저장된 요청 컨텍스트를 보고 판단한다.

새 인스턴스 생성시점
ObjectProvider.getObject() 호출 시
1. Provider가 스프링 컨테이너에게 오브젝트 달라 요청
2. 스프링 컨테이너는 해당 클래스 스코프 확인
	- @Scope("request")이므로? ThreadLocal에 담긴 요청 컨텍스트에서 조회
3. 해당 요청 컨텍스트에 빈 인스턴스 없으면 새로 생성, 컨텍스트에 저장
4. 같은 요청 안에서 이후 재사용, 요청 끝나면 제거(@PreDestroy 호출)

요청별 다른 동작 이유?
ThreadLocal은 쓰레드별 다른 저장 공간을 가짐.
요청 A와 요청 B가 각각 다른 쓰레드에서 처리 시, 서로의 request scope 빈을 절대 공유하지 않음.


프록시?
@Scope에서 ProxyMode를 적용 가능.
TARGET_CLASS/INTERFACE

어떻게 동작하나?
아무튼 CGLIB이 클래스 기반 프록시 객체를 만들어준다.
다형성을 충족한다. 원본이든 아니든, 개발자 입장에선 몰라레후

쓰레드 로컬은 지금 쓸수있는 빈, 못쓰는 빈, 만들 수 있는 빈 등의 Context를 관리한다.

쓰레드 당 쓰레드 로컬은 하나만 쓸 수 있을 듯?
비동기 처리 같이 요청이 여러 개가 들어오면 어떻게 하지?
-> contextholder처럼 thread context를 유지하는 전략이 존재한다.
context propagation이라는 이름만 들어도 AI가 떠오르는 라이브러리? 전략? 존재한다. 머리가 지끈지끈해~

ObjectProvider안에 iterator있음
왜 있어??? 너 왜 거기서나오니
그거 통해서 빈 팩토리에서 beanProvider 생성하고...
열심히 만들어서 반환해준다.


