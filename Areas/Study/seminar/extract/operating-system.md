# Operating System

## OS 기본 개념

### 정의와 주요 기능
- 시스템 자원과 동작 관리
- CPU, 메모리, IO, 디스크 등 하드웨어 자원 관리

### 사용자 모드와 커널 모드
- **사용자 모드**: 일반 프로그램 실행 위치
- **커널 모드**: 운영체제 실행 모드
  - 모든 시스템 자원 접근 가능, 높은 권한으로 작동
  - 시스템 제어하는 중요 작업

### 시스템 콜
- 커널 모드에서만 실행할 수 있는 보안이 요구되는 명령을 특권 명령
- 사용자 프로그램이 특권명령 실행위해 OS에게 이명령 대신해줄 것을 요청
- 이게 시스템 콜

### 트립
- 사용자모드 - 커널모드 - 사용자모드 과정
- 번호가 함수 인자 등등이 레지스터등에 담겨 도달
- 시스템 콜 핸들러가 전달받은 시스템 번호 확인뒤에 해당함수 호출
- 커널 함수가 실행마치면 결과값이나 에러코드가 레지스터에 저장, 반환
- CPU는 사용자모드로 전환

## 입출력 처리

### 동기 vs 비동기
- **동기**: 입출력 명령 결과 기다리는 동안 다음 명령 수행하지 않고 기다림
- **비동기**: 입력 후 기다리지 않고 다음 프로세스 시행

## 프로세스 관리

### 프로세스 정의
- 실행중인 프로그램
- 프로세스 상태: new, ready, running, blocked, terminated, suspended

### 프로세스 상태 전환
- **terminated zombie**: 자식 프로세스가 부모 프로세스에게 종료 신호를 알렸을 때, 부모가 인지할 시 terminated로 넘어감
- **blocked**: CPU가 할당되었는데 작업을 못한 상태, IO 작업 실행중
- **suspended**: 당장 사용하지 않는 프로세스를 통째로 디스크로 쫓아냄, 이렇게 통째로 뜯겨나간 상태

### 멀티 스레딩
- 응답성 향상
- 자원 공유
- 비용절감
- 병렬처리로 성능 향상
- 스레드 간 공유자원이 문제

## CPU 스케줄링

### 정의
- CPU에 어떤 프로세스 할당할 지 결정하는 과정

### 성능 척도
- **CPU 이용률**: 전체 시간 중 CPU 일하는 시간
- **처리량**
- **대기시간**
- **응답시간**
- **소요시간**

### 스케줄링 방식
- **선점**: SRTF, priority, 라운드 로빈
- **비선점**: FCFS, SJF

### 스레드 및 프로세스 중 우선순위
- IO가 먼저임
- 즉각적인 반응이 우선이기 때문
- 대기시간동안 CPU가 놀아야하기 때문에 빨리 주는거임
- 그 와중에도 꾸겨넣는 애들이 인터럽트
- 빨리빨리 해야하는 애들은 뭐가 있을까?
- 시스템 오류 같은 거

### IO 완료 시 처리
- IO 완료 시 대기큐에 완료 상태로 들어감
- 준비큐, 대기큐 나뉨
- 준비큐: CPU 준비
- 대기큐: IO 완료
- 자기 차례 되면 CPU 들어가고... 반복
- 그래서 컨텍스트 스위칭 후 대기하는 건 준비큐에 들어감

### 다단계 피드백 큐
- 제일 많이 쓰는 건 다단계 피드백 큐
- 각 큐마다 우선순위가 정해져 있어서 필요한 것들부터
- 우선순위 높은 큐만 들어가지면 기아상태 들어갈 수 있음
- 에이징 시켜서 숫자 한번씩 올려줌

## 프로세스 동기화

### 경쟁 상태 (Race Condition)
- 두 개 연산이 동시에 공유 자원 접근 시 결과가 일관성을 받지 못하는 상태
- 두 조건 충족 시 발생:
  - 공유 자원 사용
  - 동시성

### 크리티컬 섹션
- 두개 이상의 프로세스나 스레드가 동시 접근하면 안되는 공유자원을 사용하는 코드 영역
- 공유자원 데이터 일관성을 보장받기 위해 한 번에 하나의 프로세스 또는 스레드만 크리티컬 섹션을 실행할 수 있도록 제어해야 함
- 여러 프로세스가 크리티컬 섹션 접근 시 경쟁상태 발생
- 상호 배제, 진행조건, 유한 대기

### 세마포어
- 공유자원 접근 동기화위해 사용
- P연산, V연산
- Busy-Wait, Block/Wakeup

## 컨텍스트 스위칭

### 컨텍스트란?
- 프로세스나 스레드가 실행을 이어가려면 알아야할 현재 상태 스냅샷
- 프로그램 카운터
- 스택 포인터
- 메모리 관리정보
- PCB나 TCB에 저장하여 보관

### 필요한 이유
- CPU를 여러 실행 단위가 공유
- 어떤 실행단위가 입출력 대기로 쉬는 동안 다른 작업이 CPU 사용해야 시스템 처리량 상승
- 선점 스케줄링으로 인한 응답성 확보 위해서도 필요

### 언제 발생?
- 인터럽트 발생
- 시스템 콜 호출

### 동작 방식
- 스레드마다 별도 스택 가짐

## 메모리 관리

### 스와핑
- 공간이 꽉 차서 현재 잠깐 중단된 프로세스를 보조기억장치로 보내고 현재 실행해야 하는 프로세스를 적재하는 방식
- `vm_stat`을 통해 메모리 통계를 확인 가능함
- 앱자체가 거대하거나, 메모리가 가득찼거나, 이때 디스크에 갖다 넣어줌
- 가상 메모리 같은 것

### 어떤 프로세스를 메모리에 우선적으로 적재해야 하는가?
- 실행에 필요한 코어, 커널?
- 캐시 히트 높은 곳

### 메모리 할당 중요함
- 페이징 내용도 있음, 정처기에서 나왔던 것... 페이지 fault 딥다이브 함 해봐야 할듯? 복잡함

## 메모리 할당 방식

### 연속 메모리 할당
- 메모리 상에 프로세스들이 연속적으로 할당되는 방식
- 커널영역 이후 프로세스 A,B,C,D 등의 사용자 영역

### 더 구체적인 메모리 할당 방식
- OS가 프로세스를 실행시키다 보면 빈공간이 생김
- 할당하려고 봤을 때 빈 공간의 크기가 다양함, 연속된 공간에 저장해야 활용하기 좋음
- **first-fit**: 검색 최소화, 빠른 할당, 구현 복잡도 낮음
- **best-fit**: 효율적 메모리 공간 사용, 전위 탐색, 속도 느림
- **worst-fit**: 프로세스 자체가 연속적으로 확장이 필요한 경우 대비 예비 공간 확보

### 단점: 외부 단편화
- 총 빈 공간이 100mb여도, 20, 50, 30 이렇게 분리되어있어서 실제로 100mb 프로세스를 넣을 수 없음
- 이런 것들은 메모리 자원 낭비로 이어짐
- 메모리 스왑, 3가지 적재 방식 모두 동일

### 해결책: 메모리 압축
- 메모리를 재배열하여 프로세스 사이의 빈공간을 없앰
- 오버헤드 발생, 압축 과정 중 프로세스 중단이 발생함
- 연속 메모리 할당 방식이 아니라면? 불연속 메모리 할당 방식은 메모리 압축이 필요한가?

## 가상 메모리

### 정의
- 프로그램 일부만 메모리에 적재

### 페이징
- 동일한 프로세스를 일정한 크기로 조각내어 저장하는 방식
- 메모리가 부족한 공간에서 동작하는 것을 가능하게 함

### 불연속적으로 적재된 페이지는 어떻게 사용?
- 페이지 테이블을 통해 사용
- 메모리 상에는 불연속, CPU 상에서는 연속적
- 그럼 불연속 메모리 할당아닌가?

### 페이지 테이블
- 메모리에 직접 올린다고 함
- 그럼에도 불구하고 내부 단편화 존재
- 공통 페이지 크기보다 작은 페이지가 존재하여 공간적으로 낭비됨
- 극복 방법은?

### 각 프로세스마다 존재하는 페이징 테이블은 어떻게 관리될까?
- CPU 내부의 프로세스 테이블 베이스 레지스터 존재
- 메모리의 프로세스 페이지 테이블에 각각 조회함
- 단점으로 두 번 이상 메모리 접근

### 개선: TLB
- CPU에서 페이지 테이블을 제공하는 캐시
- 자주 참조 영역을 메모리 페이지 테이블에서 일부 가져와 캐싱해 사용
- 캐시 히트 시 1번, 미스시 2번 메모리 접근

### 논리주소 - 물리주소
- 논리: 페이지 번호와 변위로 구성
- 물리: 프레임 번호와 변위로 구성
- 그렇다면 변위(offset)이 같을까? → 같다, 프레임과 페이지는 같은 크기이기 때문

### 페이지 엔트리 테이블
- 페이지 번호, 프레임 번호 외에도 유효비트, 보호 비트, 참조 비트, 수정 비트 등 다양한 비트 존재

## 페이징의 이점

### fork()를 통한 자식 프로세스 생성
- fork 방식도 두가지로 나뉨
- 쓰기 시 복사
- 바깥 페이지 내부 페이지 이런식으로 논리주소로 관리를 할 수 있는 이점 존재
- 페이징을 작게 만들어서 큰 파일을 관리하기 쉬워짐
- 그러나 관리가 복잡해짐

### 요구 페이징
- 페이지 교체 알고리즘
- FIFO
- 에이징 정책, Page Fault 시 어떻게 교체할 것인가

### 프레임 할당

### 스레싱
- 페이징으로 인한 오버헤드가 많아져서 프로세스 실행보다 커짐, 결국 성능 저하 이슈
- 보통 메모리 부족, 나쁜 페이지 교체 알고리즘으로 인해 발생
- 스레시 홀드 라고도 함

### 동시 실행 프로세스 수를 늘리는 것이 CPU 이용률을 늘리는 것은 아님
- 정책 선정, 메모리 이용률이 부족하게 되면 이런 것이 일어남

### page fault 빈도?
- 할당 프레임 수, 페이지 폴트율로 상한선과 하한선을 표기해 어떤 정책과 알고리즘을 사용해야 하는지 선정하게 됨
- 균등 할당, 비례 할당, 작업 집합 모델 등...

### 정책, 알고리즘의 결정은 누가 하나?
- 환경에 따라 선택 가능, CPU, 컴퓨터 OS 상태에 따라 실시간으로 할당된 프레임 수, page fault 율을 뽑아낼 수 있음

### 페이지 프레임 단위에 따라 오버헤드 차이가 생김
- 컴파일러나 인터프리터에서 이런 페이징 최적화 방식이 존재함
- ARM 아키텍처의 경우 모바일 프로세스에서 사용하는 셋이 있는데 요즘은 상향 평준화가 됨
- 5년 이전까지는 성능 차이가 존재했음
- 그 예시로 삼성 아키텍처의 칩셋은 intel이 들어간 적이 없었음

### 스레드는 어떻게 관리됨?
- 프로세스 하나하나를 실행시키는 작업 단위를 하나씩 물고 있음
- 하나당 하나씩 할당 받음
- 멀티 쓰레드라면 여러명이 여러개를 할당 받음

### 정책 상 연산이 많이 필요할 경우?
- 파이썬하는데 이미지 프로세싱, 암호화 처리과정, 컴파일링 과정 필요
- 이때 멀티 스레딩 기술 적용하면? 좋음
- 메모리에서 스레드의 컨텍스트, 스택 포인터 같은 건 어떻게 관리되는지 물어봤어야 함

### 고정 분할이면서 세그먼테이션 쓸 수도 있고, 가변 분할이면서 페이징 쓸수도 있었던 거같음

## #todo
- OS의 가상화 기술
- OS의 보안 메커니즘
- OS의 파일 시스템 최적화
- OS의 네트워킹 스택
- OS의 드라이버 개발
- OS의 실시간 시스템 지원
- OS의 멀티코어 최적화
- OS의 에너지 효율성 관리
