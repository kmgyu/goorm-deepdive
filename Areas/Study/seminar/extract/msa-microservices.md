# MSA & Microservices

## MSA 기본 개념

### 넷플릭스의 MSA 기술
- SRP랑 연관지어서 생각하면 되는데, 실제로도 기반한 아이디어
- 서비스의 기능 자체가 거대해지기 때문에 하나하나의 기능을 서비스로 운영함

### MSA 아키텍처
- 게이트웨이 앞단, 컨테이너 통신할 수 있는 곳에서 위치할 수 있을듯
- 논리적으로 동일한 서비스, 물리적으로 분리된 서버
- 이 간극을 빠르고 정확하게 동기화하기 위해 메시징큐를 사용함
- 데이터 이관 과정에서도, 사용자간 통신에서도 사용될 수도 있고, 다양한 메시징큐가 이렇게 사용됨

## 대규모 트래픽 제어

### 기업에서 대규모 트래픽 제어 방법
- **넷플릭스**: MSA 기술
- **카카오**: API 트래픽 보호 전략 (API gateway + rate limiting)

### Spring Cloud Gateway
- 인증 필터가 실행돼 유효한 토큰 확인 후 API로 전달
- Security와의 차이점? 인증 및 보안 처리에 대한 스펙
- 여기는 Gateway에 대한 스펙

### CDN (Content Delivery Network)
- 각 로컬 서버가 내용을 대신 전달해줌
- 각 로컬에 컨텐츠를 분산 저장

## 서비스 메시

### Istio
- 쿠버네티스 위에서 서비스 메시를 구현하는 오픈소스 플랫폼

### 오케스트레이션
- 스케일링 등

### 서비스 메시
- 마이크로서비스들을 자동으로 관리해주는 플랫폼

## Kafka

### Apache Kafka
- 분산형 이벤트 스트리밍 플랫폼
- 대용량 데이터를 빠르고 안정적으로 주고받는 메시지 시스템

### Kafka 핵심 구성요소
- **브로커**: 메시지 저장, 프로듀서/컨슈머 요청 처리
- **토픽**: 메시지 구분 단위, 데이터 흐름 이름표
- **파티션**: 카프카 브로커 내부 토픽을 나눈 조각, 병렬 처리 가능
- **프로듀서**: 메시지를 토픽에 발행
- **컨슈머**: 토픽 메시지를 구독하고 처리
- **컨슈머 그룹**: 여러 컨슈머를 묶어 메시지를 나눠 받게 함
- **주키퍼**: 클러스터 관리, 브로커 상태 감시, 리더 선출

### Zookeeper
- Kafka는 분산 시스템, 여러 브로커가 클러스터를 이루고 데이터와 메타데이터를 분산 저장
- 클러스터 상태를 관리하고 조율하는 역할이 Zookeeper
- 카프카 2.8 이상부터는 KRaft mode에서는 주키퍼가 없어도 됨
- 근데 레거시에서는 필요함, 웬만해선 쓰는 편이 좋을 듯

### Kafka 작동 방식
- 대기열 + 게시-구독 모델 결합
- 가장 잘 알려진 예시가 카프카
- 옵저버 패턴 아님?

### Kafka vs RabbitMQ
- 전반적으로 메시징 큐를 사용하고 비슷한 점이 많음
- 래빗 MQ는 소비 시 삭제해야 하고, 차이점이 많음
- 패러다임이 다르다고 봐야하지 않을까?
- 프로토콜도 다양함

### 이벤트 기반 서비스
- MSA는 서비스의 여러가지 기능을 작게 쪼갬
- 카프카는 기능을 시행해서 어떤 변경사항이 생기면 효율적으로 다른 서비스에 알리는 역할

### REST API vs 이벤트 기반
- **REST API**: 프론트(클라이언트)에서 정확한 자원과 주소를 알아야 함, 그래서 즉각적으로 동작
- **이벤트 기반**: 프로듀서와 컨슈머가 있어서 카프카는 프로듀서가 생성하고 컨슈머는 꺼내감, 바로바로 동작할 필요가 없음
- 이벤트는 일단 카프카 넣어두고 생기면 누가 가져갈지 모름
- 토픽만 정해두고 누군가 필요한 녀석들이 동작하도록 하는 컨셉

### 이벤트 기반의 장점
- 느슨한 결합
- 서비스에 의존성을 가지지 않게 됨
- 동일한 토픽에서 동일한 동작이 가능함
- 우리 자바 아니라 파이썬 서버 할거야 → 됨

### MSA 환경에서 메시징 큐가 필요한 이유
- 각 서비스 간 데이터 통신을 위해 존재함
- topic 단위로 발행
- 발행 단위가 있고, 컨슈머는 본인이 받을 토픽을 정함
- 컨슈머가 그걸 가져가서 각 서버에 분배시켜줌
- 이렇게 되면 던져놓고 다른 작업할 수 있게 됨 → 비동기
- 쿠버네티스랑도 연결됨
- 동기화를 위해 큐를 씀
- 천둥번개쳐서 제주도 서버 날아감 → 서울 서버로 페일오버라던지...

### Kafka 데이터 처리
- **데이터 크기**: 몰라용
- **데이터 포맷**: 스트링으로 가는것인가?
- TCP/IP 기반임, 이거나 HTTP 같은 것은 바이트코드로 직렬화되서 들어옴
- 직렬화랑 역직렬화되서 들어오지 않을까?
- 포맷은 제대로 지정되어 있지 않지만, JSON, XML 등 지정 가능
- 실제로 내부적으로는 바이트 코드로 주고받음

### Kafka 실습
- docker-compose 사용
- zookeeper랑 kafka 브로커 이미지 써서 해줌
- 리스너 포트 세팅으로 뭐든지 다들어 대나무숲(아님) 포트를 설정해줄 수 있음
- 유레카, api게이트웨이, 유저-서비스 서버 실습했던 것을 꺼냄
- 카프카 의존성을 추가함
- 카프카 프로듀서, 컨슈머 생성도 해줘야 함
- 프로듀서는 보통 이 토픽에 이 메시지 보냄 이런 거 만들어줌
- 컨슈머는 특정 토픽을 구독함, 메시지 받고 처리함

### Kafka 고급 기능
- **분산 데이터 스토어**: 실시간 스트리밍 데이터를 수집, 처리하는 데 최적화
- **스트리밍 데이터**: 수천 개 데이터 원본에서 연속적으로 생성되는 데이터

#### 주요 기능
- 레코드 스트림 게시 및 구독
- 레코드 생성 순서대로 저장
- 레코드 스트림 실시간 처리

### AWS에서 Kafka 지원
- AWS 적용해서 확장시켜볼까 라는 생각을 갖고 있음

### 로우 시스템 구현 추천
- 여러 애플리케이션이 상호작용을 할 텐데 중앙에서 클러스터링 연결을 해줄텐데, 이걸 어떻게 할 건지
- 카프카를 통해 여러 애플리케이션이 왔다리갔다리 메시지 컨슈밍

### Kafka 컨셉
- 레이스 컨디션, 트랜잭션에서 예외처리 최대한 안되는 것?
- 이게 왜 이렇게 설계되었는지 알아보면 좋은 공부가 될 듯

## Kubernetes

### Docker Compose
- 도커라고 하는 건 개별적 컨테이너
- 컴포즈는 한 번에 실행시켜주는 방식
- 쿠버네티스 동작 시키려면 제원같은 YAML이 있는데, 도커도 도커컴포즈 YAML이 있음
- 백, 프론트, nginx 같은 게 있음
- 도커 파일은 각각에 대한 제어가 있음
- 각각 어떤 환경에서 돌릴 건지
- 코드 실행 방식, 돌릴 이미지, 로드 버전 같은 것도 지정가능
- 도커 컴포즈는 이 도커 파일들을 하나의 서비스로 묶어줌
- 개별 환경에 대한 IP, Port 연결 세팅
- 접근 환경의 네이밍스페이스, 버저닝(여기서도 가능)도 넣고
- 옵션 넣기도 가능, 만약 죽을 경우 재실행시켜준다던가...
- 컨테이너 실행 순서를 지정하는 것도 가능
- 쿠버네티스는 더 큰 개념

### Pod
- 쿠버네티스 최소 실행 단위
- 하나 이상의 컨테이너를 담는 그냥 더 큰 컨테이너 같은 것 같지만
- 포드 안의 컨테이너는 IP랑 스토리지를 공유함

### 미니큐브
- 쿠버네티스 편하게 만들어줌
- 보다는 그래픽으로 나온 게 더좋음
- 도커 대시보드, 쿠버네티스 대시보드 같은 GUI가 있음
- 이런 거 한 번씩은 사용할 필요
- 아키텍처 전반에 대한 이해가 필요함
- 로직 실행 이해 필요함

### Kubernetes 배포
- 이미지를 도커로 담아서 배포함
- 그게 좋아서 도커 쓰는데, 컨테이너 너무 많아짐
- 이게 많아지면 관리해주는 얘가 쿠버네티스

### Kubernetes YAML 설정
- 배포시 YAML을 두개를 쓰는데 용도가 달라서 두개를 씀
- **Deployment**: 배포 환경, 포드 몇 개? 서비스 몇 개 띄울 건지 등?
- **Service**: 고정 IP/포트 제공하면서 게이트웨이 역할을 해줌
- Service는 일종의 프록시 서버 역할을 해주는 것 같음

### Kubernetes 기능
- 쿠버네티스에 올리면 관리를 해줌
- **오케스트레이션**
- **오토 스케일링**
- **롤링 업데이트 & 롤백**
- **서비스 디스커버리 & 로드 밸런싱**: 클러스터 내부 DNS 제공
- **셀프 힐링**: 노드 문제, 포드 죽음 자동 재시작
- **스토리지 오케스트레이션**: 스토리지를 관리하는 거임, 서비스가 아니라 스토리지도 오케스트레이션
- **설정 관리**
- **네임스페이스**
- **모니터링 & 로깅**
- **확장성과 클라우드 연동**

### Kubernetes HPA 기능
- **Pod**: 쿠버네티스 가장 작은 배포 단위
- HPA를 이용해 pod를 오토스케일링함

## 모니터링

### Prometheus & Grafana
- **Prometheus**: 오픈소스 모니터링 및 경고 플랫폼
- **Grafana**: 데이터 시각화 도구
- CPU 로드율 80% 넘으면 슬랙으로 알람가게 설정할 수도 있음
- 터지기 전에 대응하도록 모니터링
- 구글 애널리틱스도 있음, 트래픽 기반으로 통계내는 데이터 시각화 도구도 있음

## 비동기 처리

### GPT에 질문 던져놓으면 시간 오래걸림
- 던지고 백단은 자기일, 메시징큐가 그거 받아서 대답을 백단에 전달
- 서버 바깥에도 메시징큐를 위치시킬 수도 있음

## #todo
- MSA의 서비스 간 통신 최적화
- MSA의 데이터 일관성 보장 방법
- MSA의 서비스 디스커버리 패턴
- Kafka의 파티셔닝 전략
- Kafka의 컨슈머 그룹 관리
- Kubernetes의 네트워킹 정책
- Kubernetes의 보안 정책
- MSA의 장애 복구 및 재해 복구
