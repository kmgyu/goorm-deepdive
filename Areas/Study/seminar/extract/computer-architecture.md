# Computer Architecture

## 컴퓨터 장치 유형

### 정보 표현과 저장

### CPU 기억장치의 접속
- **시스템 버스**: 세가지 유형 존재
  - 주소
  - 데이터
  - 제어

## CPU 기본 구조

### 구성 요소
- **ALU**: 산술 논리 연산 장치
- **레지스터 세트**: CPU 내부의 작은 저장 공간들
- **제어 유닛**: 명령어 해석 및 실행 제어

## 명령어 실행

### 명령어 사이클
- 한 개 명령어 실행 시 필요한 전체 프로세스
- **기본 명령어 사이클**: 인출과 실행으로 나뉨

## CPU 내부구조

### 주요 레지스터들
- **Program Counter (PC)**: 다음에 실행할 명령어의 주소를 저장
- **Accumulator (AC)**: 연산 결과를 임시 저장
- **명령어 레지스터(IR)**: 현재 실행 중인 명령어를 저장
- **메모리 주소 레지스터(MAR)**: 메모리 접근 시 주소를 저장
- **메모리 버퍼 레지스터(MBR)**: 메모리와 CPU 간 데이터 전송 시 임시 저장

## 인출 사이클 (Fetch Cycle)

### 상세 과정
1. 현재 PC 내용을 CPU 내부버스를 통해 MAR로 전송
2. 그 주소가 지정하는 기억장치 위치로부터 읽혀진 명령어가 데이터버스 통해 MBR로 적재, PC 내용 1더함
3. MBR 명령어 코드가 명령어 레지스터인 IR로 이동

## 실행 사이클 (Execute Cycle)

### 상세 과정
- 명령어 코드를 해독하고 필요한 연산들을 수행함
- 특정 시나리오를 통해 동작 방식을 알아봤음

## 인터럽트 사이클

### 인터럽트
- 다른 모듈들이 프로세서의 정상 처리를 중단할 수 있는 메커니즘
- 실행 도중 CPU 실행 처리 순서 중단, 다른 동작 우선 실행
- **인터럽트 서비스 루틴**: 인터럽트 처리를 위해 수행하는 프로그램 루틴

### 인터럽트 종류
- **program**: 프로그램 오류로 인한 인터럽트
- **timer**: 타이머에 의한 인터럽트
- **io**: 입출력 완료에 의한 인터럽트
- **hardware failure**: 하드웨어 오류로 인한 인터럽트

## 명령어 파이프라인

### 2단계 파이프라인
- Fetch, Execute를 계속함
- 실행이 인출보다 오래걸려서 전체 파이프라인이 손해 발생

### 4단계 파이프라인
- 그래서 이걸 4단계 파이프라인으로 더 세분화시킴
- 명령어 인출, 명령어 해독, 오퍼랜드 인출, 실행 단계로 만듦

## 멀티코어

### 코어
- 각 코어는 시스템 버스와 캐시 만을 공유

## 어셈블리어 분석

### disassembling을 통해 어셈블리 출력해보면
- 순서나 주소값이 주르륵 나와있음
- 그걸 접근할 때 주소값을 실제로 입력하는 얘는 MAR을 통해 함

### 보안성 문제
- 만약 해킹을 위해 침입했다, 코드가 순서대로 되어있으면 해석하기 쉬움
- 이를 해결하기 위한 방법이 무엇인가?

### 해결 방법
- **간접 주소 지정방식**
- **offset 지정 방식**: 오프셋? 랜덤 난수를 이용해 메모리에 저장해둔다?
- 보안성을 높이기 위한 방식?
- 오프셋을 관리하는 레지스트리가 별도로 존재함

## 컴파일러 최적화

### 컴파일러마다 어셈블러를 최적화하는 방법들이 다름
- 얼마나 딥하게 할겨? 어셈블러까지만 배워보면 될듯

## #todo

- CPU의 캐시 메모리 계층 구조
- CPU의 분기 예측 메커니즘
- CPU의 슈퍼스칼라 아키텍처
- CPU의 SIMD 명령어 처리
- CPU의 가상화 지원 (VT-x, AMD-V)
- CPU의 전력 관리 기술
- CPU의 멀티스레딩 (SMT/Hyperthreading)
- CPU의 메모리 일관성 모델
