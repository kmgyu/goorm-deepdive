# Caching

## 캐시 관리 정책

### 캐시 크기 관리
- 캐시 크기가 아주 커지게 되면 오버헤드가 커짐
- TTL(Time to Live) 또는 우선순위 등으로 죽일 수 있음

### 캐시 어사이드 (Cache Aside)
- 애플리케이션이 직접 캐시를 관리하는 패턴
- 애플리케이션이 DB를 접근하기 전에, 먼저 캐시를 확인하고 필요한 경우에만 DB를 조회하는 방식
- 데이터를 어떻게 조회할 지에 대한 전략
- 데이터는 레디스에 저장되지 않고 DB에 저장
- DB에서 조회 전에 레디스에 있는지 확인
- DB로부터 데이터를 조회하고 응답, 레디스에 저장
- 다시 요청 시, 레디스로부터 바로 가져옴

### 캐시 히트, 캐시 미스
- **캐시 히트**: 캐시에서 데이터를 찾은 경우
- **캐시 미스**: 캐시에서 데이터를 찾지 못한 경우

### Write Around
- 데이터를 어떻게 쓸 지에 대한 전략
- 레디스 조회 시 데이터 없으면 DB에 저장해주는 방식
- 쓰기 작업을 캐시에는 미반영, DB에만 반영

## Redis

### 기본 개념
- **Redis**: Remote Dictionary Server의 약자
- 인메모리에 모든 데이터를 저장해 굉장히 빠름

### Redis 주요 사용사례
- 캐싱
- 세션관리
- 실시간 분석 및 통계
- 메시지 큐
- 속도제한
- 실시간 채팅 및 메시징

### Redis의 장점
- 자료에 나옴 (구체적인 내용은 #todo)

### Redis 특성
- In-Memory InnoDB 형태로 저장되서 더 빠름
- 다운되면 죽으니까 특수한 처리하지 않으면 날아감
- key-value 및 해시 트리를 이용한 빠른 접근(부수적인 속도 향상 기능)

### Redis 캐싱 전략
- 조회가 많은 데이터를 미리 저장
- 메인 메모리에서 사본 만들고 빠르게 날리기
- Redis에서 로그인 시 사용자 정보를 가져와 DB 접근 없이 빠르게 응답을 제공
- 메인 서버로의 부하를 분산시킴

## 캐시 한계점 및 해결방법

### 한계점
- **캐시된 데이터, DB 데이터 불일치 가능** (일관성 보장 불가)
- **캐시 저장 공간이 적음** (사용 공간이 주저장장치라 상대적으로 적음)

### 해결방법
- **TTL 설정**으로 대부분 해결 가능
- 어쩔 수 없는 부분, Trade off가 발생함
- 자주 변하는 것, 자주 변하지 않는 것의 적절한 선택이 필요

### 정합성 체크
- 사용자가 요청을 해서 변경이 될 때 정합성 체크
- **방법 1**: fetch 같은 작업이 이뤄질 시(변경) redis와 DB 모두 반영하는 방법
  - redis는 업데이트 됨, DB는 모종의 이유로 업데이트 안됨 같은 정합성 문제 발생 가능
- **방법 2**: DB에 먼저 쓰기, DB에서 리턴을 받아와 확실하게 저장된 것을 REDIS에 써줌
  - 리소스가 비싸다, 저울질이 필요함
- **방법 3**: DB에 넣어주고 처리 끝나면 redis에 요청 쏴주면 값 바꾸기
  - 클라이언트가 redis로 왔다리 갔다리보다 빨라짐
  - DB가 관리하거나 레디스가 관리해주면 되서 클라는 신경 쓸 필요가 없음
  - 가운데에서 장애 생기면 안전장치가 필요함

## Redis 성능 및 최적화

### Redis가 정상 동작 시 항상 동일한 성능을 낼 수 있을까?
- 아닐 것 같음
- **메모리 히트인 경우**: 빨리 가져올 수 있고, 정상적인 동작
- **주저장장치에서 작동**: 저장공간이 휘발성 = 초기에 비어있음
- **콜드 스타트**: 그래서 시작할 때 조금 손해를 봄

### 콜드 스타트 해결책
- 메모리에 있던 걸 디스크로 로드한다? 결국 DB를 활용하니 손해를 봄
- **미리 세팅**: Redis 특징 중에 하나로 있음
- 메시징 큐에서 모두 적용할 수 있음, 콜드 스타트의 해결책으로만은 아님, 장애상황 대응을 위한 기술

### 영속성 옵션
- 메모리 날아가는 걸 방지하는 기술
- 서버 죽으면 기존 DB나 로컬에 저장하고 재시작 시 메모리에 다시 업로드 해줌
- 메모리 히트가 될 수 있는 상황이라면 꺼내줄 수 있는 상황
- 중요 데이터, 많이 쓰는 데이터, 특정한데 가공하는 데 시간 많이드는 데이터(AI 이미지 등)은 영속성을 만들어서 장애상황 생길 시 빠르게 만들어주는 역할
- 서버 장애 생길 시 다른 연산작업 필요가 없다는 장점

## Redis 내부 구조

### 해싱
- Redis는 해싱은 쓰는데 B-트리는 몰루
- 해싱은 키값이 같은 경우를 어떻게 관리하냐?
- **해시 충돌을 체인법으로 관리** (일반적인 현대적 관리방법)

## 캐시 무효화

### 캐시를 무효화해야 되는 경우
- 캐시를 저장해야 하는 경우도 있지만, 캐시를 무효화해야되는 경우도 있음
- 기존 캐시를 죽이거나 무조건 하나 더 받아와야된다거나, 업데이트해줘야 됨
- 모종의 케이스로 이름이 변경되는 사진 등

### 보안성
- 캐시 안에 쿠키 안에 토큰 같은 것들
- 토큰이 무효화시켜야 하는 정책이 있을 수 있음
- 토큰 자체에 넣는 만료시간? 그건 캐시에서 지우는 게 아님

### 캐시에서 무효화하는 방법
- **해시화**
- 서버 자체에서 브라우저단으로 보내버리는 경우도 있음
- "너 이거 죽여" 캐시 가지고 있으면 알람 가게끔 해서 서버단에서 브라우저단으로 요청 보냄

### JWT 토큰 탈취시의 대응방안
- 토큰을 다 죽여버려야 하는데, 강제로 요청 보내서 브라우저단에서 삭제시키는 것
- 이 경우 사용자가 삭제를 안하게 됨

## 캐시 전략

다양한 캐시 정책
- 먼저 갔다 생으로 넣어주기 (캐시-어사이드?)
- 양쪽에 다 반영하기
- 등등 다양함

캐시를 서버라는 거대한 크기로 만들어서 지역성을 이용하는 방법


## #todo

- Redis의 클러스터링 및 샤딩 전략
- Redis의 메모리 최적화 방법
- Redis의 백업 및 복구 전략
- 캐시의 분산 환경에서의 일관성 보장
- 캐시의 압축 및 직렬화 최적화
- 캐시의 모니터링 및 메트릭 수집
- 캐시의 보안 및 접근 제어
- 캐시의 성능 튜닝 및 벤치마킹
