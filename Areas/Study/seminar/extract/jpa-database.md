# JPA & Database

## JPA 기본 개념

### 영속성 컨텍스트의 캐시 (1차 캐시)
- 생명주기와 범위가 정해져 있음
- 생명주기는 엔티티 매니저가 살아있는 동안 유지됨 (트랜잭션 단위와 동일)
- 엔티티 매니저가 닫히면서 영속성 컨텍스트는 자동으로 사라짐
- 보통의 웹 애플리케이션에는 요청 단위 트랜잭션을 사용하기 때문에 트랜잭션이 끝날 때마다 자연스럽게 1차 캐시가 비워짐

### 인덱싱
- 데이터베이스에서 빠른 검색을 위해 사용하는 자료구조
- 일반적으로 B-Tree, Hash 구조를 사용해서 테이블의 특정 컬럼에 대해 색인을 만듦
- 인덱싱이 없다면 원하는 데이터를 찾기 위해 전체 테이블을 풀스캔해야 하지만, 인덱싱을 통해 해당 위치를 빠르게 찾을 수 있음

### B-Tree
- 데이터베이스나 파일시스템에서 많이 쓰이는 트리 기반 자료구조
- 이진탐색트리는 한 노드가 최대 2개의 자식을 가질 수 있지만, B-Tree는 여러개의 자식을 가질 수 있음

## JPA에서의 락

### 낙관적 락 (Optimistic Lock)
- "동시에 수정하지 않을거라고 낙관"하는 방식
- 데이터를 읽을 때는 락을 걸지 않고 수정할 때 충돌을 감지해서 막음
- 보통 엔티티에 @Version 필드를 둬서 사용

#### 동작 원리
1. 트랜잭션 A가 엔티티를 읽고 version=1을 가져옴
2. 트랜잭션 B도 같은 엔티티를 읽고 version=1을 가져옴
3. A가 엔티티를 수정하고 커밋 → version이 2로 증가
4. B가 나중에 커밋하려고 하면, DB의 version=2와 B가 기억한 version=1이 달라서 **OptimisticLockException** 발생

### 비관적 락 (Pessimistic Lock)
- "동시에 수정할 가능성이 있다고 비관"하고 데이터를 읽을 때부터 락을 걸어버리는 방식
- JPA에서는 @Lock 어노테이션이나 엔티티매니저의 LockMode를 통해 사용

#### 동작 원리
- SELECT를 할 때부터 DB에 `for update` 같은 구문으로 락을 걸어서, 다른 트랜잭션이 그 데이터를 수정하거나 읽기(락 모드에 따라 다름) 못 하게 함
- 그래서 **동시에 접근하는 상황 자체를 차단**함

#### 종류
- `PESSIMISTIC_READ`: 읽기 잠금 → 다른 쓰기/갱신을 막음
- `PESSIMISTIC_WRITE`: 쓰기 잠금 → 읽기/쓰기 둘 다 막음
- `PESSIMISTIC_FORCE_INCREMENT`: 읽기 잠금 + 버전 강제 증가

### 락 사용 시나리오

#### 낙관적 락을 쓰는 경우
1. 충돌이 드물다고 예상되는 경우
2. 읽기 위주의 시스템에서
3. 동시성(성능)을 최대한 높이고 싶을 때
4. 충돌이 나더라도 롤백하거나 다시 시도하면 되는 상황

#### 비관적 락을 쓰는 경우
1. 충돌이 자주 일어난다고 예상될 때
2. 데이터가 한번에 정확히 처리되어야 하는 상황일 때
3. 동시 수정이 일어나면 안되는 비즈니스 로직일 때
4. 충돌이 나면 롤백하기 보단 애초에 다른 트랜잭션이 접근하지 못하게 막아야 할 때

## 분산 트랜잭션

### 하나의 트랜잭션 범위에서 여러 DB로 쿼리를 날릴 수 있을까?
- 원칙적으로 일반적인 JPA 환경에서는 어려움
- 보통 스프링에서 @Transactional을 쓰면 단일 데이터소스에 대해서만 트랜잭션을 관리
- JPA가 관리하는 영속성 컨텍스트도 특정 DB 커넥션 하나를 기반으로 해서 어려움

### JTA (Java Transaction API)
- 자바 애플리케이션이 트랜잭션을 시작하고, 커밋하고 롤백할 수 있게 해주는 표준 인터페이스
- 하나의 DB뿐만 아니라 여러 리소스에 걸친 분산 트랜잭션도 관리 가능

#### JTA의 동작 절차
1. `UserTransaction.begin()` → 트랜잭션 시작
2. 여러 DB나 자원을 이용한 작업 수행
3. `commit()` 호출하면 **2단계 커밋(2PC)** 수행:
   - 1단계: 각 자원에게 준비(prepare) 요청
   - 2단계: 모두 OK면 commit, 하나라도 실패면 rollback

## JPA 연관관계

### FK 받는 쪽이 관리하는 이유
- 매핑하기 힘들기 때문
- 피대상자는 연관 관계가 없고, FK쪽은 인용하기 때문에 DB에서는 단방향
- 그래서 양방향 만드려면 매핑을 하나 더 시켜줘야 함

### N:M 관계
- 데이터가 많아서 빠른 읽기를 만드는 곳은 서브 테이블 만들어서 양방향 매핑도 함

## PostgreSQL

### 특징
- 오픈소스 RDBMS 유형 중 하나
- 트랜잭션, ACID 지원
- 스키마 지원

### 구조
- 클라이언트/서버 모델 사용
- 서버는 DB 파일 관리, 클라이언트 앱 연결 수용
- 각 커넥션에 대해 새 프로세스를 fork

### 기본 명령어
```bash
brew services start postgresql@15
```

### 사용자 생성
```sql
create user jung with password '1234';
```

### 데이터 타입
- `SERIAL` → `AUTO_INCREMENT`와 같음
- `JSONB` → PostgreSQL도 JSON 지원, BSON 형태
- 검색, 필터링, 수정, 인덱스 활용에 용이

### JSON 연산자
- `->` : 단순 JSON 객체
- `->>` : 텍스트 반환

### 배열 지원
- `ANY(tags)`: tags 배열 안에 특정 문자 같은 데이터 포함되어있는지 검사 (like와 비슷)

### 고급 기능
- **update + insert (insert on conflict)**: 삽입 도중 유니크 값 중복으로 인한 충돌 시, 업데이트와 삽입을 동시에 할 수 있음

### 기업에서 많이 쓰는 이유
- JSON 활용 가능
- 성능도 더 좋음
- 일반적 SQL에서는 JSON 지원을 안함
- 배열 삽입, update, insert 동시에 한다던지 같은 여러 기능을 지원

### ORDBMS
- JSON, 배열 쓰는 것
- 객체지향 개념을 강하게 지원해야 ORDBMS라고 분류
- MySQL, MariaDB는 지원을 제대로 해주지는 않음

## #todo
- JPA의 N+1 문제 해결 방법
- JPA의 지연 로딩과 즉시 로딩 최적화
- JPA의 커스텀 쿼리 작성 방법
- JPA의 벌크 연산 처리
- JPA의 엔티티 그래프 활용
- PostgreSQL의 고급 인덱싱 전략
- PostgreSQL의 파티셔닝
- PostgreSQL의 복제 및 클러스터링
