캐시 관리?
캐시는 다루는 정책이 아주 중요하다.

만약에 캐시 크기가 아주 커지게 되면 오버헤드가 커진다.

캐시-어사이드
내가 캐시에서 한번 확인하고 없으면 다시 올려준다 방식

이밖에도 정책이 매우 많음.
먼저 갔다 생으로 넣어주기, 양쪽에 다 반영하기 등... 다양함.

TTL(Time to Live) 또는 우선순위 등으로 죽일 수 있음.

---

스프링은 자바 코드를 조작하기가 어렵기 때문에 바이트 코드를 조작해서 싱글톤을 구현한다.

---
빈 객체 관리
자동자동은 충돌, 수동 자동은 수동이 자동을 오버라이딩 한다.

Component 같은 어노테이션은 등록할 빈만 따로 달아준다.
Autowired는 의존성 있는 놈만 이 빈이랑 요 빈이랑 연결해줘라임.
좀 목적이 다름.

---
GPT?
@Component 계열 애노테이션들(@Component, @Service, @Repository, @Controller)은 **컴포넌트 스캔**을 통해서 자동으로 스프링 빈으로 등록됩니다.  
→ 즉, 패키지 스캔 범위 내에 클래스가 있으면 자동으로 빈 등록.  
반면에, @Bean은 **명시적으로 빈을 등록**하는 방법이고, 보통은 @Configuration이 붙은 설정 클래스 안에서 메서드에 붙여 사용합니다.  
→ 개발자가 직접 빈 생성 로직을 작성해서 빈 등록.


## 캐시 어사이드란 무엇인가???

캐시 어사이드란 애플리케이션이 직접 캐시를 관리하는 패턴을 의미한다.애플리케이션이 DB를 접근하기 전에,먼저 캐시를 확인하고 필요한 경우에만 DB를 조회하는 방식이다

## 영속성 커넥스트의 캐시(1차 캐시)에 생명주기가 있을까??

영속성 컨텍스트의 캐시는 무한하지않고,생명주기와 범위가 정해져있다

생명주기는 엔티티 매니저가 살아있는동안 유지된다 트랜잭션단위와 동일함

## 캐시에 있는걸 비우는 과정도 필요하지 않을까 어떻게비울까??

엔티티 매니저가 닫히면서 영속성 컨텍스트는 자동으로 사라진다.보통의 웹 어플리케이션에는 요청 단위 트랜잭션을 사용하기 때문에 트랜잭션이 끝날때마다 자연스럽게 1차캐시가 비워진다

## 인덱싱이란 무엇인가??

데이터베이스에서 빠른 검색을 위해 사용하는 자료구조이다 일반적으로 B-Tree,Hash구조를 사용해서 테이블의 특정 컬럼에 대해 색인을 만든다

인덱싱이 없다면 원하는 데이터를 찾기위해 전체테이블을 풀스캔해야하나 인덱싱을통해 해당위치를 빠르게 찾을수있다

B-Tree는 데이터베이스나 파일시스템에서 많이쓰이는 트리기반자료구조로 이진탐색트리는 한노드가 최대 2개의 자식을 가질수있지만 이친구는 여러개의 자식을 가질수 있다

## JPA에서의 락

동시에 같은데이터를 수정하면 안되는 상황을 제어하기 위한 기술이다

- 낙관적락

“동시에 수정하지 않을거라고 낙관”하는 방식으로 데이터를 읽을땐 락을 걸지 않고 수정할때 충돌을 감지해서 막아버린다 보통 엔티티에 @Version필드를 둬서 사용한다

- **동작 원리**
    1. 트랜잭션 A가 엔티티를 읽고 version=1을 가져옴
    2. 트랜잭션 B도 같은 엔티티를 읽고 version=1을 가져옴
    3. A가 엔티티를 수정하고 커밋 → version이 2로 증가
    4. B가 나중에 커밋하려고 하면, DB의 version=2와 B가 기억한 version=1이 달라서 **OptimisticLockException** 발생
- 비관적 락

“동시에 수정할 가능성이 있다고 비관”하고 데이터를 읽을때부터 락을 걸어버리는 방식으로 JPA에서는 @Lock어노테이션이나 엔티티메니저의 LockMode를 통해 사용한다

- **동작 원리**
    - SELECT를 할 때부터 DB에 `for update` 같은 구문으로 락을 걸어서,
        
        다른 트랜잭션이 그 데이터를 수정하거나 읽기(락 모드에 따라 다름) 못 하게 함.
        
    - 그래서 **동시에 접근하는 상황 자체를 차단**한다.
        
- **종류**
    - `PESSIMISTIC_READ`: 읽기 잠금 → 다른 쓰기/갱신을 막음
    - `PESSIMISTIC_WRITE`: 쓰기 잠금 → 읽기/쓰기 둘 다 막음
    - `PESSIMISTIC_FORCE_INCREMENT`: 읽기 잠금 + 버전 강제 증가

낙관적 락을 쓰는경우

1. 충돌이 드물다고 예상되는경우
2. 읽기 위주의 시스템에서
3. 동시성(성능)을 최대한 높이고 싶을 때
4. 충돌이 나더라도 롤백하거나 다시 시도하면 되는 상황

비관적 락을 쓰는 경우

1. 충돌이 자주일어난다고 예상될때
2. 데이터가 한번에 정확히 처리되어야하는 상황일때
3. 동시 수정이 일어나며 안되는 비즈니스 로직일때
4. 충돌이 나면 롤백하기보단 애초에 다른 트랜잭션이 접근하지 못하게 막아야할때

## 하나의 트랜잭션 범위에서 여러 DB로 쿼리를 날릴수 있을까??

원칙적으로 일반적인 JPA환경에서는 어렵다

보통 스프링에서 @Transactional을 쓰면 단일 데이터소스에 대해서만 트랜잭션을 관리한다

JPA가 관리하는 영속성 컨텍스트도 특정 DB커넥션 하나를 기반으로 해서 어렵다

하지만 불가능한게 아니라 분산 트랜잭션이라는 개념을 사용하여 해결할수있다 JTA가있다

JTA란 Java Transaction API로 자바 애플리케이션이 트랜잭션을 시작하고,커밋하고 롤백할수 있게 해주는 표준 인터페이스이다 하나의 DB뿐만 아니라 여러 리소스에 걸친 분산 트랜잭션도 관리가능하다

JTA의 동작 절차

1. `UserTransaction.begin()` → 트랜잭션 시작
2. 여러 DB나 자원을 이용한 작업 수행
3. `commit()` 호출하면 **2단계 커밋(2PC)** 수행:
    - 1단계: 각 자원에게 준비(prepare) 요청
    - 2단계: 모두 OK면 commit, 하나라도 실패면 rollback