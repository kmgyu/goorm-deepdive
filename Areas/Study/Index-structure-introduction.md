# 데이터베이스 - 인덱스 개론

데이터베이스 인덱스의 개념부터 알고리즘, 유형별 특징 및 효율적인 설계 방안에 대해 알아본다.

## 목차
1. 인덱스 기본 개념
2. 핵심 알고리즘
3. 인덱스 유형
4. 실무적 활용

---

# 1. 인덱스 기본 개념
## 인덱스의 특징
- select 검색 속도를 크게 향상시킨다.
- DB 크기의 약 10% 내외의 추가 공간이 필요하다.
  실제 비율은 인덱스 구조, 데이터 특성에 따라 달라진다.
- 인덱스 생성 시 시간이 걸린다.
- insert, update, delete 같은 데이터 변경 쿼리가 잦은 경우 page split(또는 index split)이 빈번해져 성능이 악화될 수 있다.
- 데이터 조회에는 성능이 증가하나, 데이터 변경이 자주 일어나면 오히려 성능이 감소한다.

## 데이터 페이지란?
**데이터 페이지**는 데이터베이스 시스템이 데이터를 디스크에 저장하고 관리하는 **가장 기본적인 단위**입니다. 데이터베이스는 데이터를 한 번에 한 바이트씩 읽거나 쓰는 대신, 효율적인 I/O(입출력) 작업을 위해 **고정된 크기의 블록 단위**로 데이터를 처리합니다. 이 블록을 '페이지' 또는 '블록'이라고 부릅니다.

- **구조:** 데이터 페이지는 보통 **페이지 헤더**, **데이터 본문(row data)**, **페이지 트레일러** 등으로 구성됩니다. 페이지 헤더에는 페이지 번호, 체크섬 등 페이지 관리에 필요한 정보가 담겨 있으며, 데이터 본문에 실제 데이터 레코드(행)들이 저장됩니다.
    
- **크기:** 페이지 크기는 데이터베이스 시스템마다 다르며, MySQL의 InnoDB 스토리지 엔진은 기본적으로 **16KB** 페이지를 사용합니다.
    

데이터베이스 시스템은 인덱스를 통해 필요한 데이터가 포함된 페이지를 찾은 후, 해당 페이지 전체를 메모리로 불러와 작업을 수행합니다.

## 인덱스 스플릿(index split)이란?
**인덱스 스플릿**은 B-Tree 계열 인덱스에서 **새로운 데이터를 삽입(insert)**할 때 발생하는 현상입니다. 인덱스 페이지에 더 이상 새로운 키를 저장할 공간이 없을 때, 데이터베이스 시스템은 해당 페이지를 **두 개의 페이지로 쪼개는 작업**을 수행합니다.

- **원인:** B-Tree는 데이터의 정렬 순서를 유지하기 때문에, 새로운 데이터가 특정 위치에 삽입되어야 합니다. 만약 해당 페이지가 이미 가득 찼다면, 새로운 데이터를 위한 공간을 확보하기 위해 페이지를 분할해야 합니다.
    
- **과정:**
    1. 새로운 데이터가 들어올 공간이 없는 페이지를 찾습니다.
    2. 해당 페이지에 있던 기존 데이터의 절반을 **새로운 페이지**로 옮깁니다.
    3. 새로운 페이지를 인덱스 트리에 연결하기 위해 부모 노드에 새로운 인덱스 키와 페이지 정보를 추가합니다.
        
- **문제점:** 인덱스 스플릿은 **추가적인 디스크 I/O 작업**을 유발하고, B-Tree의 **트리 높이를 증가**시켜 전체적인 검색 성능을 저하시킬 수 있습니다. 특히 `INSERT`, `UPDATE`, `DELETE`와 같은 데이터 변경 작업이 빈번한 경우, 잦은 스플릿으로 인해 인덱스의 성능이 악화될 수 있습니다.
    

이러한 성능 저하를 방지하기 위해 데이터베이스는 주기적인 **인덱스 재구성(rebuild)** 작업을 통해 인덱스 페이지들을 다시 정렬하고 공간을 최적화하는 과정을 거칩니다.

---

# 2. 핵심 알고리즘


# 인덱스 알고리즘 종류
- B-Tree 인덱스 알고리즘 (보편적 방식)
- Hash 인덱스 알고리즘
- Fractal-Tree 인덱스 알고리즘 (비교적 최근)

B-Tree 사용 시, 데이터는 계층적으로 정렬되어 검색 속도를 극대화하게된다.

## B-Tree 인덱스 알고리즘

![[B-tree.png]]
*[image from](https://mangkyu.tistory.com/286)*


B-Tree 인덱스는 컬럼 값을 변형하지 않고 원래 값을 이용해 인덱싱한다.

B-Tree 는 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태이다.

트리 구조의 가장 하위에는 리프 노드라고 하고 트리구조에서 루트노드도 아니고 리프노드도 아닌 중간의 노드를 브랜치 노드라고 한다. 

### 특징
**균일성**
b-tree는 어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다.
즉, 조회 과정의 길이 및 비용이 균등하다.
어떤 데이터를 조회하든지 루트부터 리프 페이지를 모두 거쳐야 하기 때문에 데이터가 적은 테이블 등에서는 단순 조회로 데이터를 조회 시 조회 속도가 더 느린 단점이 있다.

**균형트리**
B-tree는 루트로부터 리프까지의 거리가 일정한 트리구조이다.
트리 중에서는 특히 성능이 안정화 되어있는 유형이다.

B-tree는 초기 생성 당시 균형 트리이나, 테이블 갱신(insert/update/delete)의 반복을 통해 서서히 균형이 깨지고, 성능이 악화된다.
어느 정도 자동으로 균형을 회복하는 기능이 있으나, 갱신 빈도가 높은 테이블에 작성되는 인덱스의 경우 인덱스 재구성을 통해 트리 균형을 되찾는 작업이 필요하다.
![stable tree image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fb9BMy3%2FbtqBTL7abid%2FAAAAAAAAAAAAAAAAAAAAAFxuiFggbiA_C_2C-ML1WucSdq6hQQ7L41orGNxRaR9w%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DVPKlT96keBoTa9wEXIj0T7UFcyY%253D)

insert 연산 시 시간 복잡도는 O(log N)이기 때문에 데이터 양에 비례해 효과가 상승한다.


## B+tree 인덱스 알고리즘
B-tree의 확장 개념이자, MySQL의 DB 엔진인 InnoDB가 사용하는 알고리즘이다.

![[B+tree.png]]
[image from](https://engineerinsight.tistory.com/336)

B-tree의 경우, internal 또는 branch 노드에 키와 데이터를 담을 수 있다.
B-tree의 경우 브랜치 노드에 키만 담아두고, 데이터는 담지 않는다.
오직 리프노드에만 키와 데이터를 저장하고, 리프 노드끼리 연결 리스트(Linked List)로 연결되어 있다.

### 특징
리프 노드를 제외하고 데이터를 담아두지 않아 더 많은 키를 수용 가능.
하나의 노드에 더 많은 키들을 담을 수 있기에 트리 높이는 더 낮아진다. (캐시 히트율 상승)

풀 스캔 시, B+트리는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색으로 모든 데이터를 조회 가능하다. B-tree의 경우 모든 노드를 확인해야 한다.

### 실제 구현에서의 차이
MySQL의 엔진인 InnoDB에서는 더 복잡하게 구현된다.
같은 레벨의 경우 double Linked List 사용, 자식 노드와는 Single Linked List로 연결된다.
키키의 범위마다 찾아가야할 페이지 넘버(포인터)가 있는데, 해당 페이지 넘버를 통해 곧바로 다음 노드로 넘어간다.
그리고 리프 노드에 다다랐을 때 디스크에 존재하는 데이터의 주소값을 구할 수 있고, Double Linked List를 통해 탐색도 가능하다. 



## Hash 인덱스 알고리즘

Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.

하지만 값을 변형해서 인덱싱하므로, 해시 인덱스는 동등 비교 검색에는 최적화돼 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용 할 수 없다. 

주로 인메모리 DB 에서 사용하는 인덱스 종류다. 

> Tip
> **인메모리 DB 란?**  
> 메모리가 디스크 스토리지의 메인 메모리에 설치되어 운영되는 DB 다. 알티베이스, Oracle Timestan, SAP Hana DB 등이 이 분류에 속한다.

![[hash table.png]]
[image from](https://hudi.blog/ds-hash-table/)



해시 인덱스의 장점으로는 실제 키값과는 관계없이 인덱스 크기가 작고 검색이 빠르고 원래의 키값을 저장하는 것이 아니라 해시 함수의 결과만을 저장하므로 키 컬럼의 값이 아무리 길어도 실제 해시 인덱스에 저장되는 값은 4~8바이트 수준으로 상당히 줄어든다.

그래서 타 인덱스 대비 조회 속도가 매우 빠르다. 

그러나 위와는 반대로, 각 해쉬값에 주소값을 배정하는 인덱스의 특징에 따라 범위로 조회하는 작업은 느리다.

또한 범위로 묶어서 보관하는 인덱스가 아니므로 데이터 개수가 증가 함에 따라 범위로 묶어서 보관하는 인덱스보다 더 큰 저장공간을 필요로 한다.



## **Fractal-Tree 알고리즘 (TokuDB)**

Fractal-Tree 알고리즘은 B-Tree의 단점을 보완하기 위해 고안된 알고리즘이다.

값을 변형하지 않고 인덱싱하며 범용적인 목적으로 상요할 수 있다는 측면에서 B-Tree와 거의 비슷하지만 데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게 설계된 것이 특징이다.

![[Fractal-Tree.png]]

[image from](https://gywn.net/2014/05/fractal-index-in-tokudb/)

> Lazy Propagation Segment Tree의 아이디어와 닮아있음.
> 세그먼트 트리가 In-memory 연산을 위한 자료구조라면 프랙탈-트리 알고리즘은 디스크 I/O를 위한 것이라는 것이 차이점이다.
> 버퍼 공간도 노드에 포함된 공간이다. 메모리에 올라올 때는 캐싱된 구조로 활용된다.
> 페이지들이 버퍼 풀(메모리 캐시)에 올라와서 실제 연산은 메모리에서 이루어지고 DB로 플러시.. 으윽...


### 메시지 지연 전파 기법
**프랙탈 트리**는 B-Tree의 잦은 `page split` 문제를 해결하기 위해 고안된 알고리즘입니다. 이 방식은 **쓰기(write) 성능**을 크게 향상시키는 **'메시지 지연 전파'** 기법을 사용합니다. B-Tree는 새로운 데이터가 들어올 때마다 제자리를 찾아 즉시 삽입(insert)해야 하므로, 페이지가 가득 차면 `page split`이 발생해 I/O 비용이 증가합니다.

프랙탈 트리는 이 문제를 해결하기 위해, 삽입 또는 삭제 연산을 **'메시지(message)'** 형태로 **버퍼(buffer)**에 잠시 저장해둡니다. 각 노드(node)는 마치 우체통처럼 메시지를 담아두는 작은 버퍼를 가지고 있습니다.

1. **메시지 전파:** 새로운 데이터가 들어오면, 이 데이터는 즉시 디스크에 쓰여지는 것이 아니라, 해당 데이터가 속할 범위의 노드에 메시지로 저장됩니다.
    
2. **버퍼링과 일괄 처리:** 메시지가 계속 쌓이다가 노드의 버퍼가 가득 차면, 버퍼의 메시지들을 **한꺼번에(batch)** 하위 노드로 '전파'합니다. 이 과정에서 여러 개의 메시지가 하나의 I/O 작업으로 처리되므로, 디스크에 접근하는 횟수가 크게 줄어듭니다.
    
3. **병합:** 하위 노드로 전달된 메시지는 기존 데이터와 병합(merge)되거나, 다시 해당 노드의 버퍼에 쌓입니다. 이 과정을 통해 삽입/삭제 작업이 페이지 분할 없이 효율적으로 이루어집니다.
    

이러한 지연 전파 방식 덕분에 프랙탈 트리는 빈번한 데이터 변경 작업이 발생하는 환경에서 B-Tree보다 훨씬 뛰어난 성능을 보입니다. 즉, 개별적인 쓰기 요청을 모아서 한 번에 처리하는 **'일괄 처리'** 개념을 트리 구조에 적용한 것입니다.


### write 성능 개선을 위한 buffering 기법
B-트리와 달리 프랙탈 트리 인덱스는 각 노드에 버퍼가 있어 삽입, 삭제 및 기타 변경 사항을 중간 위치에 저장할 수 있습니다. 버퍼의 목표는 각 쓰기가 많은 양의 유용한 작업을 수행하도록 디스크 쓰기를 예약하여 각 디스크 쓰기가 디스크의 소량 데이터를 변경할 수 있는 B-트리의 최악의 성능을 방지하는 것입니다.B-트리와 마찬가지로 프랙탈 트리 인덱스는 큰 블록의 데이터를 읽고 쓰는 시스템에 최적화되어 있습니다

메시지 지연 전파와 유사하다.

# 인덱스 타입 종류

Primary(클러스터) 인덱스와 Secondary(보조) 인덱스로 나뉜다.

각 인덱스의 특징이 존재하여, 사용처가 나뉜다.


## **클러스터 인덱스(Primary Index)**

- 특정 나열된 데이터들을 일정 기준으로 정렬해주는 인덱스다. (ex : 영어사전)  
    그래서 클러스터형 인덱스 생성 시에는 데이터 페이지 전체가 다시 정렬된다.
- 하지만 이러한 정렬 특징 때문에, 이미 대용량의 데이터가 입력된 상태라면 클러스터형 인덱스 생성은 심각한 시스템 부하를 줄 수 있다.
- **한개의 테이블에 한개씩만 만들 수 있다** (ex : Primary Key)
- 본래 인덱스는 생성 시 데이터들의 배열정보를 따로 저장하는 공간을 사용하나, 클러스터 인덱스는 따로 저장하는 정보 공간을 적게 사용하면서 테이블 공간 자체를 활용한다.  
    인덱스 자체의 리프 페이지가 곧 데이터이기 때문에 인덱스 자체에 데이터가 포함되어있다고 볼 수 있다.
- 보조 인덱스 보다 검색 속도는 더 빠르다.   
    하지만 입력/수정/삭제는 더 느리다.
- MySQL에서는 Primary Key가 있다면 Primary Key를 Clustered INDEX로, 없다면 UNIQUE 하면서 NOT NULL인 컬럼을, 그것도 없으면 임의로 보이지않는 컬럼을 만들어 Clustered Index로 지정한다.


### **클러스터 인덱스 생성시 페이지 변화**
클러스터드 인덱스는 인덱스 자체의 리프(leaf) 페이지가 곧 실제 데이터 페이지라는 특징이 있습니다. 즉, 인덱스를 생성하면 테이블의 모든 데이터 레코드가 물리적으로 정렬되어 저장됩니다.

- **정렬 방식**
  클러스터드 인덱스 키(예: `PRIMARY KEY`)를 기준으로 데이터가 정렬됩니다. 이는 마치 사전이 가나다순으로 정렬되어 있어 특정 단어를 빠르게 찾을 수 있는 것과 같습니다.
    
- **페이지 변화**
  인덱스 생성 시, 테이블의 실제 데이터 파일이 인덱스 구조에 맞게 재정렬됩니다. 이 때문에 대용량 테이블에 클러스터드 인덱스를 생성하면 상당한 시스템 부하가 발생할 수 있습니다.
    
- **루트 페이지**
  루트 페이지는 각 하위 노드의 키 범위 구간을 저장해 검색 시 분기점을 제공합니다.

- **리프 페이지**
  리프 페이지에는 인덱스 키 값뿐만 아니라 **데이터 레코드의 모든 컬럼 값**이 함께 저장됩니다. 따라서 인덱스 탐색만으로 원하는 데이터를 바로 얻을 수 있어 조회 속도가 매우 빠릅니다.

## **보조 인덱스 (Secondary Index)**

- 이 인덱스는 논-클러스터 인덱스 (non-clustered index) 라고도 불린다. 
- 개념적으로는 후보키에만 부여 할 수 있는 인덱스다.
  실제로는 비고유(non-unique) 컬럼에도 부여 가능하다.
- 보조 인덱스의 생성시에는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다.
- 별도의 페이지에서 인덱스를 구성하니, 클러스터와는 달리 자동 정렬을 하지 않는다.
- 클러스터 인덱스의 리프 페이지는 보조 인덱스의 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소값 (RID)
- 클러스터형 보다 검색 속도는 더 느리지만 데이터의 입력/수정/삭제는 덜 느리다.
- 보조 인덱스는 여러 개 생성할 수 있다. 그러나 함부로 사용할 경우에는 오히려 성능을 떨어뜨릴 수 있다.
- 각 데이터에 대해서 고유 값 (unique) 들이 있는 목록에 생성 할 수 있는 인덱스다. (unique key)

![[B-tree-bookmark-lookup.png]]
보조 인덱스 사용 시 작동 방식
### **보조 인덱스 생성시 페이지 변화**
보조 인덱스는 데이터 페이지와 별개로 생성됩니다. 보조 인덱스의 리프 페이지는 실제 데이터가 아닌, 데이터가 위치한 주소 정보를 가리킵니다.

- **데이터 위치 정보:** MySQL의 **InnoDB** 스토리지 엔진에서 보조 인덱스의 리프 페이지는 **클러스터드 인덱스의 키 값**을 저장합니다. SQL Server에서는 **RID(Row Identifier, 또는 Record ID)**라고 하는 주소 값을 저장하기도 합니다.
    
- **탐색 과정:** 보조 인덱스로 데이터를 찾으려면 두 단계의 과정을 거칩니다.
    
    1. **보조 인덱스 탐색:** 보조 인덱스를 통해 리프 페이지에 저장된 **클러스터드 인덱스 키 값**을 찾습니다.
        
    2. **클러스터드 인덱스 탐색:** 찾아낸 클러스터드 인덱스 키 값을 이용해 다시 **클러스터드 인덱스를 탐색**하여 실제 데이터가 저장된 페이지로 이동합니다. 이를 **북마크 룩업(Bookmark Lookup)**이라고 합니다.
        
- **페이지 변화:** 보조 인덱스는 데이터 페이지를 정렬하지 않고 별도의 페이지에 인덱스를 구성하기 때문에 여러 개를 만들 수 있습니다. 하지만 그만큼 추가적인 디스크 공간을 사용합니다.
    

이러한 구조적 차이 때문에 **클러스터드 인덱스는 검색이 더 빠르지만 데이터 변경에 따른 부하가 크고**, **보조 인덱스는 검색 시 한 단계 더 거치므로 약간 느리지만 여러 개를 만들어 다양한 조건의 쿼리에 활용할 수 있습니다.**


# 인덱스 설계 핵심 TIP

인덱스의 원리를 알았으니 이제 언제 어느떄에 인덱스를 써야 효율적으로 사용한것이 되는지 설계의 핵심을 알아보자.

## 효율적인 인덱스 설계

WHERE 절에 사용되는 열 (WHERE 절에 사용되는 열이라도 자주 사용해야 가치가 있음)

SELECT 절에 자주 등장하는 컬럼들을 잘 조합해서 INDEX로 만들어두면 INDEX 조회 후 다시 데이터에서 조회할 필요가 없으므로 빠르게 검색이 가능하다.
즉 "실제 데이터 접근"의 행위 없이 인덱스에 있는 컬럼 값들로만 쿼리를 완성하는 것을 말한다.
이는 Covering Index의 개념과 관련된 것이다.

JOIN절에 자주 사용되는 열에는 인덱스의 효율이 좋음.

ORDER BY 절에 사용되는 열은 데이터 페이지가 자동 정렬됐기 때문에 클러스터형 인덱스가 유리

 > Tip
> ※ 외래키는 자동으로 외래키 인덱스 만듬

### 금지해야 할 인덱스 설계

대용량 데이터가 자주 입력되는 경우,클러스터형 인덱스의 경우 빈번한 page split이 일어나기 때문에 부하가 생긴다. 따라서 인덱스가 필요한 경우 primary(클러스터) 대신 unique만 설정하는 게 좋을 수 있다.

분포도(Selectivity, 중복되지 않는 데이터의 정도)가 높은 열은 인덱스 효과가 없다. 예를 들어 성별 열에 M, F만 있다고 하면 인덱스를 안쓰는 게 낫다.따라서 일반 보조 인덱스보다 unique 보조 인덱스가 빠른 이유가 이것이다.

자주 사용되지 않으면 성능 저하를 초래할 수 있음. (INSERT만 주구장창 하는 시스템이라면, 사용해보지도 못하고 데이터 입력에 걸리는 작업량만 많아진다)

> Tip
> 데이터의 중복도
> 중복도가 높은 경우, 인덱스를 사용하는 것이 효율이 없지는 않지만 어차피 데이터를 읽기 위해 많은 페이지를 읽어야 하는 것은 마찬가지이기 때문에 피해야 한다.
> 예를 들어 성별이라는 컬럼에 INDEX를 만들어두면 남,여 밖에 없기 때문에 중복도는 높고 분포도는 낮다. 따라서 데이터의 종류가 별로 없기 때문에, 남자를 검색할 때 절반이나 되는 ROW를 검색해야하고 결국 모든 ROW를 검색하는 table full scan이 더 나을지도 모른다. 
> index를 봤다가 데이터를 봤다가 x 100000 을 하는게 더 느릴 수 있기 때문이다. 더군다나 인덱스 관리 비용이나 INSERT 구문으로 인한 성능 저하등을 고려하면 반드시 필요하지는 않다.

### 인덱스를 사용할 때 주의할 점

데이터 변경(삽입, 수정, 삭제) 작업이 얼마나 자주 일어나는지 고려해야 함.

단일 테이블에 인덱스가 많으면 속도가 느려질 수있다. (테이블당 4~5개 권장)

검색할 데이터가 전체 데이터의 20% 이상이라면, MySQL에서 인덱스를 사용하지 않음. (강제로 사용할 시 성능 저하를 초래할 수 있음)전체 페이지의 대부분을 읽어야 하고, 인덱스 관련 페이지도 읽어야 해서 작업량이 크기 때문이다.

사용하지 않는 인덱스는 제거하는 것이 바람직함. (실무에서 사용하지 않는 보조 인덱스를 몇개 삭제했을 때 성능이 향상되는 경우도 많음)

클러스터형 인덱스는 테이블당 하나만 생성할 수 있음

테이블에 클러스터형 인덱스가 아예 없는 것이 좋은 경우도 있음

> Tip
> INDEX 손익분기점테이블이 가지고 있는 전체 데이터양의 10% ~ 15%이내의 데이터가 출력 될 때만 INDEX를 타는게 효율적이고, 그 이상이 될 때에는 오히려 테이블 전체 스캔(Table Full Scan)이 더 빠르다.

### 인덱스가 적용되지 않는 쿼리 예시

인덱스를 생성했더라도 다음과 같은 쿼리 패턴에서는 데이터베이스 최적화 프로그램이 인덱스를 사용하지 않고 테이블 전체 스캔(Table Full Scan)을 선택할 가능성이 높습니다. 이는 인덱스가 정렬된 데이터라는 특성을 활용할 수 없게 되기 때문입니다.

#### 1. 인덱스 컬럼을 가공하거나 함수/연산을 적용하는 경우

인덱스에 저장된 값은 원래의 형태 그대로이기 때문에, 쿼리에서 인덱스 컬럼에 함수나 연산을 적용하면 인덱스 값이 변형되어 올바른 순서를 찾을 수 없습니다.

- **예시:**
```SQL
-- 인덱스 컬럼에 함수 적용
SELECT * FROM employees WHERE YEAR(hire_date) = 2024;

-- 인덱스 컬럼에 연산 적용
SELECT * FROM products WHERE price * 1.1 > 1000;
```
    
위 쿼리에서 `hire_date`와 `price` 컬럼에 인덱스가 있더라도, 데이터베이스는 모든 행에 대해 함수나 연산을 수행한 후 조건을 비교해야 하므로 인덱스를 사용할 수 없습니다. 이 경우 **WHERE 절의 조건을 함수나 연산이 없는 형태로** 변경해야 합니다.
    
- **개선된 예시:**
```SQL
-- 날짜 범위로 변경하여 인덱스 사용 유도
SELECT * FROM employees WHERE hire_date >= '2024-01-01' AND hire_date < '2025-01-01';

-- 연산 결과값을 미리 계산하여 인덱스 사용 유도
SELECT * FROM products WHERE price > 1000 / 1.1;
```
        

#### 2. 인덱스 컬럼의 묵시적 형변환(Implicit Type Casting)

컬럼의 데이터 타입과 비교 대상의 데이터 타입이 다를 때 데이터베이스가 내부적으로 형변환을 수행합니다. 이 과정에서 인덱스가 무효화될 수 있습니다.

- **예시**
```SQL
-- 숫자 타입인 user_id 컬럼을 문자열과 비교
SELECT * FROM users WHERE user_id = '123';
```

`user_id` 컬럼이 숫자 타입(`INT`)임에도 불구하고 문자열(`'123'`)과 비교하면, 데이터베이스는 인덱스 키 값들을 모두 문자열로 변환한 후 비교해야 하므로 인덱스를 사용할 수 없습니다.


#### 3. 부정형 비교(Negative Comparison)

`!=`, `<>`, `NOT IN`, `NOT LIKE` 와 같은 부정형 조건은 인덱스 검색 범위가 매우 넓어지거나, 인덱스를 사용하는 것보다 전체 테이블을 스캔하는 것이 더 효율적이라고 판단될 수 있습니다.

- **예시:**
```SQL
-- 부정형 비교
SELECT * FROM orders WHERE status != 'completed';
```

이 쿼리는 `completed` 상태가 아닌 모든 주문을 찾습니다. 만약 `completed` 상태인 주문이 전체의 90%를 차지한다면, 인덱스로 10%의 데이터를 찾는 것이 유리하지만, 반대로 `completed` 상태가 10%에 불과하다면 나머지 90%를 인덱스로 찾는 것보다 테이블 전체를 스캔하는 것이 더 빠를 수 있습니다.


#### 4. LIKE `%`가 앞에 위치하는 경우

`LIKE` 연산에서 와일드카드 문자(`%`)가 검색어의 앞에 위치하면 인덱스의 정렬 순서를 활용할 수 없으므로 인덱스가 사용되지 않습니다.

- **예시:**
```SQL
-- 인덱스를 사용하지 않음
SELECT * FROM products WHERE product_name LIKE '%coffee';
```

이 쿼리는 'coffee'로 끝나는 모든 제품을 찾습니다. 인덱스는 'c'로 시작하는 키부터 'f'로 시작하는 키까지의 범위를 찾을 수 없으므로 모든 행을 스캔해야 합니다.

- **개선된 예시:**
```SQL
-- 인덱스를 사용함
SELECT * FROM products WHERE product_name LIKE 'Coffee%';
```

`%`가 뒤에 오는 경우, 인덱스는 'Coffee'로 시작하는 범위를 빠르게 찾을 수 있어 인덱스를 효율적으로 활용합니다.


### ORDER BY 와 GROUP BY에 대한 인덱스

INDEX는 ORDER BY와 GROUP BY에도 영향을 끼치는데 다음과 같은 경우에는 INDEX를 타지 않는다.

- ORDER BY 인덱스컬럼1, 컬럼2 : 복수의 키에 대해서 ORDER BY를 사용한 경우
- WHERE 컬럼1='값' ORDER BY 인덱스 컬럼 : 연속하지 않은 컬럼에 대해 ORDER BY를 실행한 경우
- ORDER BY 인덱스컬럼1 DESC, 인덱스컬럼2 ASC : DESC와 ASC를 혼합해서 사용한 경우
- GROUP BY 컬럼1 ORDER BY 컬럼2 : GROUP BY와 ORDER BY의 컬럼이 다른 경우
- ORDER BY ABS(컬럼) : ORDER BY 절에 다른 표현을 사용한 경우


# 팁 스니펫

> 정보 과다로 뇌가 녹아버릴 수 있기 때문에, 추가적인 팁은 스니펫으로 제공됩니다.

### 인덱스의 유형
Primary Index
Unique Index
Composite Index

### 설계 시 주의점
자주 사용하는 열에 추가
읽기보다 쓰기가 많다면 인덱스 개수 최소화
과도한 인덱스 사용은 성능 저하

### 추가로 알아보면 좋은 내용

트랜잭션의 4가지 속성 ACID

격리 수준


# Reference

mysql 인덱스?
https://yoon-ssi.tistory.com/131

인덱스 알고리즘의 특징 및 종류
https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

B-tree
https://zorba91.tistory.com/293

B-tree 예제
https://velog.io/@chanyoung1998/B%ED%8A%B8%EB%A6%AC

mysql b-tree
https://mangkyu.tistory.com/286