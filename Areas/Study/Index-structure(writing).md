
인덱스의 특징
- select 검색 속도를 크게 향상시킨다.
- DB 크기의 약 10%의 추가 공간이 필요하다.
- 인덱스 생성 시 시간이 걸린다.
- insert, update, delete 같은 데이터 변경 쿼리가 잦은 경우 paging이 빈번해져 성능이 악화될 수 있다.
- 데이터 조회에는 성능이 증가하나, 데이터 변경이 자주 일어나면 오히려 성능이 감소한다.

# 인덱스 알고리즘 종류
- B-Tree 인덱스 알고리즘 (보편적 방식)
- Hash 인덱스 알고리즘
- Fractal-Tree 인덱스 알고리즘 (비교적 최근)

B-Tree 사용 시, 데이터는 계층적으로 정렬되어 검색 속도를 극대화하게된다.

## B-Tree 인덱스 알고리즘


B-Tree 인덱스는 컬럼 값을 변형하지 않고 원래 값을 이용해 인덱싱한다.

B-Tree 는 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태이다.

트리 구조의 가장 하위에는 리프 노드라고 하고 트리구조에서 루트노드도 아니고 리프노드도 아닌 중간의 노드를 브랜치 노드라고 한다. 

### 특징
**균일성**
b-tree는 어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다.
즉, 조회 과정의 길이 및 비용이 균등하다.
어떤 데이터를 조회하든지 루트부터 리프 페이지를 모두 거쳐야 하기 때문에 데이터가 적은 테이블 등에서는 단순 조회로 데이터를 조회 시 조회 속도가 더 느린 단점이 있다.

**균형트리**
B-tree는 루트로부터 리프까지의 거리가 일정한 트리구조이다.
트리 중에서는 특히 성능이 안정화 되어있는 유형이다.

B-tree는 초기 생성 당시 균형 트리이나, 테이블 갱신(insert/update/delete)의 반복을 통해 서서히 균형이 깨지고, 성능이 악화된다.
어느 정도 자동으로 균형을 회복하는 기능이 있으나, 갱신 빈도가 높은 테이블에 작성되는 인덱스의 경우 인덱스 재구성을 통해 트리 균형을 되찾는 작업이 필요하다.
![stable tree image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fb9BMy3%2FbtqBTL7abid%2FAAAAAAAAAAAAAAAAAAAAAFxuiFggbiA_C_2C-ML1WucSdq6hQQ7L41orGNxRaR9w%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DVPKlT96keBoTa9wEXIj0T7UFcyY%253D)

insert 연산 시 시간 복잡도는 O(log N)이기 때문에 데이터 양에 비례해 효과가 상승한다.


## B+tree 인덱스 알고리즘
B-tree의 확장 개념이자, MySQL의 DB 엔진인 InnoDB가 사용하는 알고리즘이다.

***여기에 그림 입력***


B-tree의 경우, internal 또는 branch 노드에 키와 데이터를 담을 수 있다.
B_tree의 경우 브랜치 노드에 키만 담아두고, 데이터는 담지 않는다.
오직 리프노드에만 키와 데이터를 저장하고, 리프 노드끼리 Linked List로 연결되어 있다.

### 특징
리프 노드를 제외하고 데이터를 담아두지 않아 더 많은 키를 수용 가능.
하나의 노드에 더 많은 키들을 담을 수 있기에 트리 높이는 더 낮아진다. (캐시 히트율 상승)

풀 스캔 시, B+트리는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색으로 모든 데이터를 조회 가능하다. B-tree의 경우 모든 노드를 확인해야 한다.

InnoDB에서는 더 복잡하게 구현된다.
같은 레벨의 경우 double Linked List 사용, 자식 노드와는 Single Linked List로 연결된다.
키키의 범위마다 찾아가야할 페이지 넘버(포인터)가 있는데, 해당 페이지 넘버를 통해 곧바로 다음 노드로 넘어간다.
그리고 리프 노드에 다다랐을 때 디스크에 존재하는 데이터의 주소값을 구할 수 있고, Linked List를 통해 탐색도 가능하다. 



## Hash 인덱스 알고리즘

Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.

하지만 값을 변형해서 인덱싱하므로, 해시 인덱스는 동등 비교 검색에는 최적화돼 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용 할 수 없다. 

주로 인메모리 DB 에서 사용하는 인덱스 종류다. 

> Tip
> **인메모리 DB 란?**  
> 메모리가 디스크 스토리지의 메인 메모리에 설치되어 운영되는 DB 다. 알티베이스, Oracle Timestan, SAP Hana DB 등이 이 분류에 속한다.


***여기에 그림 입력***



해시 인덱스의 장점으로는 실제 키값과는 관계없이 인덱스 크기가 작고 검색이 빠르고 원래의 키값을 저장하는 것이 아니라 해시 함수의 결과만을 저장하므로 키 컬럼의 값이 아무리 길어도 실제 해시 인덱스에 저장되는 값은 4~8바이트 수준으로 상당히 줄어든다.

그래서 타 인덱스 대비 조회 속도가 매우 빠르다. 

그러나 위와는 반대로, 각 해쉬값에 주소값을 배정하는 인덱스의 특징에 따라 범위로 조회하는 작업은 느리다.

또한 범위로 묶어서 보관하는 인덱스가 아니므로 데이터 개수가 증가 함에 따라 범위로 묶어서 보관하는 인덱스보다 더 큰 저장공간을 필요로 한다.



## **Fractal-Tree 알고리즘 (TokuDB)**

Fractal-Tree 알고리즘은 B-Tree의 단점을 보완하기 위해 고안된 알고리즘이다.

값을 변형하지 않고 인덱싱하며 범용적인 목적으로 상요할 수 있다는 측면에서 B-Tree와 거의 비슷하지만 데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게 설계된 것이 특징이다.


***여기에 그림 입력***




# 인덱스 타입 종류

Primary(클러스터) 인덱스와 Secondary(보조) 인덱스로 나뉜다.

각 인덱스의 특징이 존재하여, 사용처가 나뉜다.



## **클러스터 인덱스 **(Primary Index)****

- 특정 나열된 데이터들을 일정 기준으로 정렬해주는 인덱스다. (ex : 영어사전)  
    그래서 클러스터형 인덱스 생성 시에는 데이터 페이지 전체가 다시 정렬된다.
- 하지만 이러한 정렬 특징 때문에, 이미 대용량의 데이터가 입력된 상태라면 클러스터형 인덱스 생성은 심각한 시스템 부하를 줄 수 있다.
- 한개의 테이블에 한개씩만 만들 수 있다 (ex : Primary Key)
- 본래 인덱스는 생성 시 데이터들의 배열정보를 따로 저장하는 공간을 사용하나, 클러스터 인덱스는 따로 저장하는 정보 공간을 적게 사용하면서 테이블 공간 자체를 활용한다.  
    인덱스 자체의 리프 페이지가 곧 데이터이기 때문에 인덱스 자체에 데이터가 포함되어있다고 볼 수 있다.
- 보조 인덱스 보다 검색 속도는 더 빠르다.   
    하지만 입력/수정/삭제는 더 느리다.
- MySQL에서는 Primary Key가 있다면 Primary Key를 Clustered INDEX로, 없다면 UNIQUE 하면서 NOT NULL인 컬럼을, 그것도 없으면 임의로 보이지않는 컬럼을 만들어 Clustered Index로 지정한다.


### **클러스터 인덱스 생성시 페이지 변화**

- 인덱싱을 하면 루트 페이지라는 것이 만들어진다.  
    루트 페이지는 각 데이터 페이지의 첫번째 데이터만 따와서 모아 매핑시키는 페이지이다.
- 그리고 데이터 페이지는 자동 정렬이 된다.
- 데이터 페이지 자체를 인덱스 페이지로 하는 특징이 있다.



## **보조 인덱스 (Secondary Index)**

- 이 인덱스는 논 클러스터 인덱스 (non-clustered index) 라고도 불린다. 
- 개념적으로는 후보키에만 부여 할 수 있는 인덱스다.   
    (후보키 : 고유 식별 번호, 주민번호 같이 각 데이터를 인식할 수 있는 최소한의 고유 식별 속성 집합)
- 보조 인덱스의 생성시에는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다.
- 별도의 페이지에서 인덱스를 구성하니, 클러스터와는 달리 자동 정렬을 하지 않는다.
- 클러스터 인덱스의 리프 페이지는 보조 인덱스의 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소값 (RID)
- 클러스터형 보다 검색 속도는 더 느리지만 데이터의 입력/수정/삭제는 덜 느리다.
- 보조 인덱스는 여러 개 생성할 수 있다. 그러나 함부로 사용할 경우에는 오히려 성능을 떨어뜨릴 수 있다.
- 각 데이터에 대해서 고유 값 (unique) 들이 있는 목록에 생성 할 수 있는 인덱스다. (unique key)

### **보조 인덱스 생성시 페이지 변화**

- 보조 인덱스 역시 루트 페이지가 만들어진다.  
    하지만 데이터 페이지에 바로 연결시키지 않고 따로 리프 페이지를 만들어서 매핑을 하고 정렬 시킨다. (RID)
- 이처럼 추가 공간이 필요하므로 마구 인덱스를 남용하면 공간 낭비로 이어질수도 있다.
- 데이터 페이지는 변화를 주지 않는다.   
    따라서 클러스터 인덱스와는 달리 여러개 생성이 가능한 이유이다.




# 인덱스 설계 핵심 TIP

인덱스의 원리를 알았으니 이제 언제 어느떄에 인덱스를 써야 효율적으로 사용한것이 되는지 설계의 핵심을 알아보자.

## 효율적인 인덱스 설계

WHERE 절에 사용되는 열 (WHERE 절에 사용되는 열이라도 자주 사용해야 가치가 있음)

SELECT 절에 자주 등장하는 컬럼들을 잘 조합해서 INDEX로 만들어두면 INDEX 조회 후 다시 데이터에서 조회할 필요가 없으므로 빠르게 검색이 가능하다.

JOIN절에 자주 사용되는 열에는 인덱스의 효율이 좋음.

ORDER BY 절에 사용되는 열은 데이터 페이지가 자동 정렬됐기 때문에 클러스터형 인덱스가 유리

 > Tip
> ※ 외래키는 자동으로 외래키 인덱스 만듬

### 금지해야 할 인덱스 설계

대용량 데이터가 자주 입력되는 경우,클러스터형 인덱스의 경우 빈번한 페이징이 일어나기 때문에 부하가 생긴다. 따라서 인덱스가 필요한 경우 primary(클러스터) 대신 unique만 설정하는 게 좋을 수 있다.

데이터 중복도가 높은 열은 인덱스 효과가 없다. 예를 들어 성별 열에 M, F만 있다고 하면 인덱스를 안쓰는 게 낫다.따라서 일반 보조 인덱스보다 unique 보조 인덱스가 빠른 이유가 이것이다.

자주 사용되지 않으면 성능 저하를 초래할 수 있음. (INSERT만 주구장창 하는 시스템이라면, 사용해보지도 못하고 데이터 입력에 걸리는 작업량만 많아진다)

> Tip
> 데이터의 중복도
> 중복도가 높은 경우, 인덱스를 사용하는 것이 효율이 없지는 않지만 어차피 데이터를 읽기 위해 많은 페이지를 읽어야 하는 것은 마찬가지이기 때문에 피해야 한다.
> 예를 들어 성별이라는 컬럼에 INDEX를 만들어두면 남,여 밖에 없기 때문에 중복도는 높고 분포도는 낮다. 따라서 데이터의 종류가 별로 없기 때문에, 남자를 검색할 때 절반이나 되는 ROW를 검색해야하고 결국 모든 ROW를 검색하는 table full scan이 더 나을지도 모른다. 
> index를 봤다가 데이터를 봤다가 x 100000 을 하는게 더 느릴 수 있기 때문이다. 더군다나 인덱스 관리 비용이나 INSERT 구문으로 인한 성능 저하등을 고려하면 반드시 필요하지는 않다.

### 인덱스를 사용할 때 주의할 점

데이터 변경(삽입, 수정, 삭제) 작업이 얼마나 자주 일어나는지 고려해야 함.

단일 테이블에 인덱스가 많으면 속도가 느려질 수있다. (테이블당 4~5개 권장)

검색할 데이터가 전체 데이터의 20% 이상이라면, MySQL에서 인덱스를 사용하지 않음. (강제로 사용할 시 성능 저하를 초래할 수 있음)전체 페이지의 대부분을 읽어야 하고, 인덱스 관련 페이지도 읽어야 해서 작업량이 크기 때문이다.

사용하지 않는 인덱스는 제거하는 것이 바람직함. (실무에서 사용하지 않는 보조 인덱스를 몇개 삭제했을 때 성능이 향상되는 경우도 많음)

클러스터형 인덱스는 테이블당 하나만 생성할 수 있음

테이블에 클러스터형 인덱스가 아예 없는 것이 좋은 경우도 있음

> Tip
> INDEX 손익분기점테이블이 가지고 있는 전체 데이터양의 10% ~ 15%이내의 데이터가 출력 될 때만 INDEX를 타는게 효율적이고, 그 이상이 될 때에는 오히려 풀스캔이 더 빠르다.

### 인덱스가 안 되는 쿼리

INDEX를 만들어 둔다고 모든 쿼리에서 INDEX를 활용하는 것은 아니다.

인덱스 입힌 컬럼을 가공

인덱스가 있는 열 이름에는 함수나 연산을 가함

인덱스 컬럼의 묵시적 형변환(같은 타입으로 비교해야함)

인덱스 컬럼 부정형 비교.

LIKE %가 앞에 위치.

### ORDER BY 와 GROUP BY에 대한 인덱스

INDEX는 ORDER BY와 GROUP BY에도 영향을 끼치는데 다음과 같은 경우에는 INDEX를 타지 않는다.

- ORDER BY 인덱스컬럼1, 컬럼2 : 복수의 키에 대해서 ORDER BY를 사용한 경우
- WHERE 컬럼1='값' ORDER BY 인덱스 컬럼 : 연속하지 않은 컬럼에 대해 ORDER BY를 실행한 경우
- ORDER BY 인덱스컬럼1 DESC, 인덱스컬럼2 ASC : DESC와 ASC를 혼합해서 사용한 경우
- GROUP BY 컬럼1 ORDER BY 컬럼2 : GROUP BY와 ORDER BY의 컬럼이 다른 경우
- ORDER BY ABS(컬럼) : ORDER BY 절에 다른 표현을 사용한 경우







인덱스 유형
Primary Index
Unique Index
Composite Index

설계 시 주의점
자주 사용하는 열에 추가
읽기보다 쓰기가 많다면 인덱스 개수 최소화
과도한 인덱스 사용은 성능 저하



MySQL은 B-Tree 기반 인덱스를 주로 사용한다.


트랜잭션의 4가지 속성 ACID

격리 수준



mysql 인덱스?
https://yoon-ssi.tistory.com/131

인덱스 알고리즘의 특징 및 종류
https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

B-tree
https://zorba91.tistory.com/293

mysql b-tree
https://mangkyu.tistory.com/286