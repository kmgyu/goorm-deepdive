체계적인 자원 관리
자원을 잘 이용해서 수많은 요청을 빠르게 처리해내는 것이 주요 과제가 되었음. 따라서 동시성과, 동시성 프로그래밍에 대해 살펴보는 챕터가 됨.

# 3.1 동시성 프로그래밍

하나의 프로세서가 여러 작업을 도시에 실행하도록 프로그래밍하는 기법
스레드를 생성해 이 스레드들이 여러 작업을 처리하도록 한다.
동시에 2개 이상의 스레드를 이용하기 때문에 멀티스레드라는 이름이 붙음.
멀티 스레드는 하나의 프로세스 내에서 자원을 공유한다는 장점 존재.

공유자원을 2개 이상의 스레드가 동시 접근 시 동시성 이슈가 생긴다.
이때 사용하는 메커니즘이 락. 특정 스레드가 사용하는 자원은 임계 구역으로 지정하여, 특정 스레드가 사용하는 동안은 다른 스레드가 사용할 수 없다.

자바에서는 동기화 블록이라는 것을 사용하여 임계 구역을 구현한다.

# 3.2 메모리 누수
## C를 위한 메모리 관리

C는 malloc, callac, free 등의 함수로 메모리를 관리한다.
메모리 제어가 가능하나, 잘못 사용 시 프로그램의 비정상적 종료, 불필요한 메모리 점유 등의 문제가 생긴다.

memory allocation
요청크기 만큼 메모리를 할당하고 해당 메모리 주소를 반환값으로 돌려준다.
이때, 반환값이 Null인지 확인해야 한다.
동적 메모리 할당 시 메모리가 부족하면 운영체제가 메모리를 할당하지 못하기 때문임.

free
메모리 할당을 해제한다. 주소를 포인팅하는 변수를 매개변수로 받아 메모리 할당을 풀어준다.

> 메모리 할당을 해제하더라도 변수에 저장된 메모리 주소는 삭제되지 않는다. 이미 해제한 메모리 주소에 데이터 읽기 혹은 쓰기 시 프로그램 비정상 종료 등 심각한 오류 발생 가능함.
> 따라서 free 함수 실행 후, Null로 초기화하면 비정상 종료 같은 오류는 발생하지 않음.

메모리 누수
프로그램 논리적 오류나, 결함 등으로 할당받은 메모리 주소를 잃어버리는 케이스 등을 통해 프로세스 종료 시점까지 메모리를 해제하지 못하는 상황

윈도우의 성능 모니터 기능 등으로 프로세스의 메모리 누수를 확인 가능하다.

## 자바를 위한 메모리 관리

자바에게는 가비지 컬렉션이 있다.
자바에서 메모리 해제의 주체는 JVM이다.
JVM이 자바 앱에서 사용하지 않는 메모리를 찾아 주기적으로 정리해주는 과정을 가비지 컬렉션이라 한다.

어떤 프로세스도 접근하지 않는 메모리는 사용하지 않는 메모리로 간주한다.

몇 가지 예제가 있다.

```java
String data = new String("data");
```

여기서 new 키워드를 이용해 문자열 객체를 생성했다.

이때, `data=null`과 같이 포인팅을 끊어주면 메모리 할당을 해제시킬 수 있을 것이다.

하지만, data2 변수가 추가적으로 data를 참조하는 상황을 살펴보자.

```java
String data = new String("data");
String data2 = data;
data = null;
```

이런 상황에서는 가비지 컬렉션이 일어나지 않는다.
`data2=null;`과 같이 메모리 참조를 모두 끊어줘야 한다.

책에선 여기서 끝냈지만, 좀 더 정리해보자.

GC는 특정 객체가 garbage인지 판단하기 위해 도달성, 도달능력(Reachable)라는 개념을 적용한다.
객체는 Reachable, Unreachable로 구분된다.
Reachable : 객체가 참조되는 상태
Unreachable : 객체가 참조되지 않는 상태, GC의 대상
아까 계속 했던 그거다.

메모리 해제 방식
1. Mark : Root Space로부터 그래프 순회를 통해, 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다
2. Sweep : 참조하고 있지 않은 객체, 즉 Unreachable 객체를 Heap에서 제거한다
3. Compaction : Sweep 후에 분산된 객체들을, Heap의 시작 주소로 모아 메모리에 할당된 부분과 그렇지 않은 부분으로 압축한다 (GC 종류에 따라서 선택적 실행)

**GC의 메모리 해제 과정 (Minor GC, Major GC)**

Minor GC

1. 어떤 새로운 객체가 생성되면, Heap의 Young 영역중 Eden Space에 할당됨
2. Eden Space가 가득차면 Minor GC가 실행
3. Reachable 객체들은 aged된 이후(age가 1씩 증가) survivor 0로 이동되고, Unreachable 객체는 메모리에서 제거됨  
    (이때 소요되는 시간은 대략 0.5s~1s)
4. 다음 Minor GC때 마찬가지로 Unreachable 객체는 메모리에서 제거되지만, eden의 reachable 객체와 survivor 0의 reachable 객체 모두가 aged 되고 survivor 1로 이동함. 따라서 survivor 1에는, age가 다른 객체들이 존재하게 됨
5. 그 다음 Minor GC가 수행되면, 마찬가지로 eden과 survivor 1의 모든 reachable 객체들은 aged 된 이후 survivor 0로 이동하게 됨  
    즉, survivor 영역에는 서로 다른 age의 객체들이 존재하고, survivor 0와 survivor 1은 동시에 객체들이 존재할 수 없음
6. 1~5가 반복되면서, reachable 객체들의 age가 age threshold(문지방)을 넘게되면, Young 영역에서 Old 영역으로 이동됨. 이렇게 young에서 old로 객체가 이동하는것을 promotion이라고 부름

Major GC

1. Minor GC가 반복되면서 Old 영역에 aged 객체가 쌓이기 시작함
2. Old 영역이 가득차면 Major GC가 실행
3. Old 영역에 있는 모든 객체들을 검사하여, Unreachable 객체를 한꺼번에 삭제하게됨. 이때 Old 영역은 Young 영역에 비해 상대적으로 큰 공간을 가지고 있어서, Minor GC에 비해 많은 시간이 걸리게 됨(일반적으로 10배 이상의 시간)

https://kdh0518.tistory.com/40

GC가 있어도 메모리 누수가 일어나는 경우도 있다.
(이건 검색을 잘못했는지 GC에 대한 이야기만 나와서 gpt에 물어봄)
1. **정적 컬렉션에 객체를 계속 담아두는 경우**
	- `cache`는 static이라 JVM 종료 전까지 살아있음.
	- 객체 참조가 남아있으니 GC 대상이 아님 → 계속 메모리 차지.
```java
public class Cache {
     private static final List<Object> cache = new ArrayList<>();
     public static void add(Object o) {
              cache.add(o); // 제거하지 않으면 계속 살아있음
	}
}
```
    

2. **리스너/콜백 해제 안함**
    
    - GUI나 이벤트 리스너에서 등록만 하고 해제하지 않으면 객체가 계속 참조된 상태로 남음.
        
    - Android에서도 `Activity`의 콜백이 해제되지 않아 `Context`가 살아남는 경우가 대표적.
        

3. **잘못된 캐싱**
    
    - WeakReference 등을 쓰지 않고, Map 같은 캐시에 무제한 저장.
        
    - 예: `HashMap<Key, Value>`에 쌓기만 하고 제거하지 않으면 GC 불가능.
        

4. **ThreadLocal 사용 시 정리 안함**
    
    `private static final ThreadLocal<MyObject> threadLocal = new ThreadLocal<>();`
    
    - 스레드 풀에서 스레드가 재사용되는데, `remove()`를 호출하지 않으면 값이 남아서 누수 발생.
        

5. **외부 리소스 해제 누락**
    
    - GC는 **메모리 객체**만 회수할 뿐, DB Connection, Socket, File 같은 외부 리소스는 직접 닫아야 함.
        
    - `try-with-resources` 또는 명시적 close()가 필요.
        

6. **순환 참조 자체는 문제 아님**
    
    - 자바 GC는 참조 그래프를 따라가며 살아있는 객체를 판별하기 때문에, A↔B 같은 순환 참조는 더 이상 루트에서 도달 불가하면 수거됨.
        
    - 따라서 순환 참조 자체는 메모리 누수 원인이 아님. (C/C++과의 차이점)

뇌절 끝

이클립스 메모리 분석 도구(memory analyze tool, mat) 등으로 메모리 분석이 가능하다.

---

## 파이썬을 위한 메모리 관리

파이썬은 레퍼런스 카운팅 방법을 이용해 메모리를 관리한다.
메모리가 참조되어 사용될 때마다, 사용되지 않을 때마다 증감 시켜준다.
레퍼런스 카운팅이 0이 될 때 더이상 참조되지 않는 메모리로 간주하고 해당 메모리 할당을 해제한다.

메모리 디버깅 도구인 tracemalloc 모듈을 이용하여 메모리 사용을 관찰한다. take_snapshot 등을 통해 현재 상태의 메모리 분석 로그(스냅샷)을 저장하고, 스냅샷의 통계를 확인할 수 있다.
메모리 할당 소스 코드 위치나 메모리 크기, 레퍼런스 카운팅 정보 등을 출력하므로 메모리를 가장 많이 사용한 객체가 무엇인지 등을 알 수 있다.

# 3.3 스레드 풀링

프로세스
스레드
멀티 스레딩

3.1을 참고하자.
작업이 생길 때마다 스레드를 생성하면 시간이 꽤 걸리니 스레드 풀을 미리 만들어 필요할 때 풀에서 끌어다 쓰는 방식이다.

가장 대표적인 예는 WAS이다.
WAS는 클라이언트로부터 요청이 들어오면 접수하고 대기 큐에 넣는다.
스레드 풀의 요청 처리 스레드가 대기 큐에서 요청을 가져와 처리하는 식으로 동작한다.

> 스레드 풀은 클라이언트 측 요청을 처리하는 거고, 커넥션 풀은 DB 연결 담당이라 또 다르다고 함...
> https://okky.kr/questions/777816
> 이 글을 보면 스레드 자체가 커넥션을 들고 있는 것이 아니라, 커넥션 자체를 들고 있다는 느낌인 것 같음.

최대 개수와 최소 개수 등을 설정할 수 있다. 책에서는 톰캣 가져왔다.

CORE_POOL_SIZE
스레드 풀이 유질할 최소 스레드 개수

MAX_POOL_SIZE
최대 스레드 풀 개수 설정

KEEP_ALIVE_TIME
할당해야 할 작업에 따라 스레드를 늘리거나 줄이게 되는 상황이 오는데, TTL처럼 일정 시간동안 지켜보다가 작업수가 감소하면 스레드를 죽인다.

> DBMS도 스레드 풀 사용한다!
> WAS 커넥션 풀이랑 DBMS 스레드 풀이 같아야 한다. CP가 더 많으면 아주 큰일난다.

