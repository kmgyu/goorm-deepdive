# 1.1. 논리적 작업의 단위, 트랜잭션

트랜잭션
- 컴퓨터로 처리하는 작업의 단위
- 트랜잭션에 속한 모든 작업의 성공적으로 완료되어야 트랜잭션의 실행이 완료된다. (All or Nothing)
ACID 특성

# 1.2 인덱스

[[Index-structure-introduction]]
> 이거나 읽어랏

# 1.3 쿼리 옵티마이저 - 실행 계획
쿼리 실행 방법에는 테이블 전체를 찾는 풀 테이블 스캔, 인덱스 스캔이 있다.
dbms는 쿼리를 최적으로 실행할 계획을 짜는데, 쿼리 옵티마이저가 최적의 실행 계획을 세우게 됨.

쿼리문 실행 시 동작 과정
1. 옵티마이저는 자신이 처리할 수 있는 형태로 쿼리문을 변환함.
2. 테이블에 대한 통계 정보를 활용, 쿼리문 실행을 위해 얼마나 많은 작업을 해야 하는지 비용 측면에서 계산함.
3. 이 계산 결과를 기반으로 최적의 실행 계획을 세움.

> 비용 계산 시 통계 테이블에 저장된 통계 정보를 활용함.
> 통계 정보는 테이블 행의 개수, 인덱스 크기, 열 값의 분포도 등이 있다.

mariaDB의 경우, EXPLAIN 키워드를 이용해 실행 계획을 확인한다.

옵티마이저는 주어진 시간 내에 여러 개의 실행 계획을 세우고 그 중 비용이 가장 낮은 방법을 택함.
만약 인덱스 스캔 비용이 풀 테이블 스캔 비용보다 크다고 판단 시, 옵티마이저는 인덱스를 선택하지 않을 수 있다.
옵티마이저는 실행 계획을 변경할 수 있도록 알려주는 기능임.

FORCE INDEX라는 키워드를 사용해 인덱스 스캔으로 실행 계획을 강제시킬 수도 있다.
```sql
explain select * from students force index(class_idx) where class = '컴퓨터공학' or class = '수학과' or class = '물리학과'; 
```

옵티마이저는 실행 계획 세울 시 힌트를 우선 고려함.

옵티마이저가 세운 실행 계획이 있더라도 이를 무시하고 힌트 지정 방식으로 실행 계획을 세운다.

직접 변경할 수 있는 장점이 있으나, 계획적이지 않은 힌트 사용은 옵티마이저의 올바른 판단을 방해해 비용이 높은 실행 계획을 세울수도 있다.

옵티마이저가 다양한 통계 정보를 활용해 알아서 실행 계획을 세울 수 있기 때문에 **옵티마이저 보다 '더 좋은' 실행 계획**을 만들 수 있는 제한적인 경우에만 사용하는 것이 좋다.

# 1.4 데이터 무결성

데이터에 결점이 없는 성질
정확하고 일관적이며, 누락 등의 문제가 없는 것

코드만 잘 작성한다고 데이터 무결성을 보장할 수는 없다.

예제 
아이디 중복 체크
아이디 중복 확인을 위한 조회 쿼리문 실행
존재 시? 이미 등록되었습니다. 반환
미존재 시, 사용 가능합니다. 반환

이는 동시성이 발생하는 상황에서의 무결성 보장을 고려하지 못한다.
이처럼 코드 작성만으로 데이터 무결성을 보장하기는 어렵다.

DBMS가 제공하는 무결성을 제대로 이해하고 활용해야하는 이유이기도 하다. 세 가지 무결성에 대해 살펴보자.

1. 개체 무결성
   특정 열에 중복된 값이 들어가지 않도록 강제한다.
   unique + not null 혹은 primary key 등으로 개체 무결성을 관리 가능하다.
2. 참조 무결성
   중복 데이터가 많으면 테이블을 분리해준다는 상황을 가정하자
   만약 참조하는 속성에 기존에 존재하지 않는 값을 넣어주면? 가리키는 값이 없으므로 문제가 생긴다
   FK를 통해 이런 문제를 관리한다.
   테이블 데이터가 변경될 시, 관련 테이블 값도 변경하도록 강제하여 참조 무결성을 유지한다.
3. 도메인 무결성
   정해진 범위에서 허용된 값만 입력하도록 보장하는 성질이다.
   dbms는 허용된 값만 받기 위해 제약 조건이라는 기능을 제공한다.
   제약조건의 경우, unique, not null, check 등이 있다.

unique 제약 조건
중복 제거 해준다. 개체 무결성과도 관련 있을 듯...
nullable하기 때문에 완전히 보장하지는 못함.

not null
테이블의 모든 열은 null을 기본적으로 허용한다고 함. 헐.
그래서 not null로 강제 가능.
blank나 empty는 애플리케이션 로직에서 처리해주어야 한다...

check 제약 조건
데이터 추가 전에 유효한 데이터인지 확인하는 제약 조건.
check문을 충족하지 못하면 삽입 에러


# 다양한 DB의 세계

RDBMS는 주류이나, 다양한 DB가 존재한다.

특징에 따라 다음과 같이 나뉨

- 열 기반(column-oriented)
- 키-값 (key-value)
- 문서 기반 (document-based)

### RDBMS
데이터를 표 형식으로 가지런히 정리해서 관리하고 이들의 관계를 중시하는 데이터 베이스

SQL을 이용해 CRUD 등의 행위를 할 수 있다.
실시간으로 방대하게 축적되는 비정형 데이터에는 적합하지 않을 수 있다.

영상, 오디오 파일, sns 업로드 글 같은 것이 그 예시이다.
비정형 데이터 사용 시 오히려 오버헤드가 발생해 noSQL과 같은 DB를 사용함.

행 중심이냐 열 중심이냐에 따라 행 지향 / 열 지향으로 나뉨.

행 지향 방식
행을 기준으로 데이터를 처리함.
OLTP 성격의 애플리케이션 개발 시 이용
online transaction processing의 약자.

열 지향 방식
열을 기준으로 데이터를 처리함.
데이터 분석 시 적합함.
OLAP (online analytical processing)에 적합.


왜 굳이 열 지향 방식을 사용하는가? 이는 하드디스크 I/O와 관련 있다.

행 기반일 경우, 행을 기준으로 연속된 데이터가 하드디스크에 저장된다.
데이터가 행을 중심으로 인접하므로 행 기준으로 데이터를 읽어오는 과정이 더 쉽다.
특정 열 데이터만 가져올 경우, 분산된 데이터를 뒤져가며 읽어와야 한다. 따라서 암을 여기저기 움직여야하고 데이터를 가져오는 시간이 오래 걸린다.

이 때문에 열 지향 데이터베이스가 개발되었다.

단점으로는 데이터를 빈번하게 추가하거나 업데이트 해야하는 애플리케이션을 개발한다면 시스템 성능이 떨어질 수 있기 때문에 OLTP 성격의 프로그램에는 적합하지 않다.
> 트레이드 오프가 너무 큰 것 같은데...? 분석을 더 많이 하면 상관없나?

대표적 열 지향 방식 DBMS로는 SAP HANA, Amazon Redshift 등이 있다.

SSD에서는 디스크 암과 같은 물리적인 요소는 없지만 I/O적 요소의 장점은 유효하다.


### 키-값 데이터베이스

데이터를 키-값 형태로 저장한다.
값에는 비정형의 데이터가 들어올 수 있다.

빅데이터가 발전함에 따라 어떻게 데이터를 빠르게 저장할 수 있을지에 관심이 쏠렸는데, 그동안 데이터 무결성과 일관성을 유지하기 위해 다양한 기술이 적용된 RDBMS엔 맞지 않았다.
데이터 형식의 자유로움을 그대로 허용하는 데이터베이스가 필요했음.
데이터 양이 어마어마하게 증가하다 보니 CPU, 메모리, 디스크 등의 하드웨어를 업그레이드하는 수직적 스케일링(스케일 업)하는 RDBMS로는 한계가 있어, 여러 대의 서버를 사용해 수평적 스케일링(스케일 아웃)이 가능한 키-값 데이터베이스에 관심이 집중되기 시작함.
키-값 데이터베이스는 데이터를 키와 값으로만 저장하기 때문에 저장 구조가 단순해 여러 서버에 걸쳐 데이터를 나눠 저장하고 처리할 수 있었다.

장점
고사양 하드웨어 요구하지 않아 구축비용 저렴
서버 확장에 한계가 없어 성능 부하 발생 시 언제든 서버를 추가해 유연하게 처리 가능

단점
데이터 일관성 깨짐
- 일시적 비일관성을 허용하는 서비스에 적합함.

레디스, 다이나모DB, 멤캐시드 등이 있다.

### 문서 기반 데이터베이스

문서가 중심인 데이터베이스
데이터가 문서 안에 키-값 형태로 저장

값 안에 또 다른 키-값 쌍 존재 가능

특징
문서마다 동일한 키를 가질 필요 없다.
값에 들어가는 데이터도 비정형적
- 값 안에 또 다른 키-값 쌍 존재 등... RDBMS면 조인해야하지만 그렇게 조회할 필요 없으니 조회 속도가 빠름.
스키마가 없음.
- 데이터를 융통성있게 저장 가능
- 데이터 변경도 용이함.

단점
데이터 일관성 깨짐
- 데이터가 한 문서에 담겨있어 데이터 조회 간편하나, 동일 데이터 중복 저장 가능성.
데이터 업데이트하려면 여러 문서를 만져야 하기 때문에 업데이트 필요 기능보다 주로 조회 목적으로 사용됨.

json, xml, bson 등의 형식 사용 가능
node.js 처럼 js 기반 프레임워크의 경우, json 형식 데이터 처리가 가능해 json 형식의 문서를 많이 사용.

몽고DB, 카우치DB, 다이나모 DB 등이 있다.