# 멀티 스레딩 챕터

---

멀티 태스킹

여러 개의 태스크를 동시에 실행하는 기법

멀티 스레딩은 병렬 작업의 아이디어를 하나의 애플리케이션 안으로 가져온 것
각각의 작업은 스레드

-> 프로세스 내에서 스레드 나누는 거

문제점
동기화. 크아아악

---

생성 및 실행
- Thread 클래스 상속
- Runnable 인터페이스 구현

Thread 클래스에 관한 것은 Javadoc이랑 티스토리에 있는 거 가져오셈

단점
단일 상속만 가능하므로 다른 클래스를 이미 상속받은 클래스는 스레드로 만들 수 없음.

Runnable 인터페이스 구현 방법
run() 하나만 정의되어 있는데, 이 인터페이스를 구현한 객체를 Thread 클래스 생성자로 넘기면 됨.
이 방법도 결국 Thread 사용한다.
Runnable에 로직을 작성하고, Thread 생성하면서 매개변수로 넣어주면 됨.

람다식을 이용한 스레드 작성
Runnable에서 run() 구현 안하고 람다식으로 넣어줌.

---

스레드 스케줄링

스레드 상태(생명주기)는 총 5가지 상태가 있다.
그림 가져오셈

스레드 우선순위
각 스레드는 우선순위 존재
MIN_PRIORITY
NORM_PRIORITY
MAX_PRIORITY
순서대로 1, 5, 10

priority는 빈 프로퍼티에 의해 setter와 getter로 접근 가능하다.

sleep()
스레드 재우기
ms 기준으로 됨.
ms, ns를 매개변수로 받는 오버로딩도 존재

join()
스레드 종료될 때까지 기다림.
특정 스레드가 작업 완료할 때까지 현재 스레드의 실행을 중지하고 기다린다.

인터럽트, yield
인터럽트?
하나의 스레드가 실행하고 있는 작업을 중지하도록 하는 메커니즘.
스레드가 인터럽트에 어떻게 반응하냐는 개발자 책임
일반적으로 스레드 종료됨.
하나의 스레드가 다른 스레드 인터럽트 호출 시, 해당 스레드를 반응 시키는 방법은 InterruptedException을 추가시키면 됨.

yield는 cpu를 다른 스레드에게 양보하는 메서드이다. 동일 우선순위 갖고 있는 다른 스레드 실행시키고자 할 때 사용됨.


데몬 스레드
demon thread. daemon이... 아니다...?
사용자 스레드에 서비스를 제공한다.
모든 사용자 스레드 종료 시 죽는다.
gc, finalizer 등 자동으로 실행되는 것들이 존재함.
jconsole을 프롬프트에 입력 시 모든 세부정보 확인 가능

자바 스레드 풀
스레드 풀은 미리 초기화된 스레드들이 모여있는 곳.
일반적으로 크기가 고정되어 있으나, 오토-스케일링 같은 튜닝 가능.
스레드 개수 < 작업 개수 인 경우, FIFO 큐에서 작업이 대기된다.

자바 API는 자바 5부터 Executor 프레임워크를 제공한다.
Executor 인터페이스와 하위 인터페이스 ExecutorService, 이들의 구현체 ThreadPoolExecutor 클래스로 이루어짐.
스레드 풀 사용시 Runnable 객체 구현하고 ThreadPoolExecutor로 보내기만 하면 관리해준다.
ThreadPoolExecutor는 보내주면 인스턴스화 해서 스레드로 실행하는 일을 담당함.

스레드 풀 사용 시 새로 생성되는 시간 절약 가능. 스레드 생성에도 상당한 비용이 소모되기 때문.
미리 생성 후, 풀링하여 사용한다.

---

동기화

스레드의 2가지 문제
스레드 간섭 (thread interference)
메모리 불일치 오류(memory consistency error)

이런 오류 막기 위한 도구
메모리를 로킹(locking)해주는 거임. 하나의 쓰레드만 쓰도록 보장...

락이 걸리고 해제되는 영역을 임계 영역(critical section)이라고 한다.
세마포어? NO! 이 방식은 뮤텍스(mutex)에 가까울 듯.
락을 가진 스레드만 접근 가능하므로... 세마포어는 변수로만 제어되니 다르다?

3가지 방법이 존재한다.
- 동기화 메소드
- 동기화 블록
- 정적 동기화

동기화는 락 또는 모니터로 알려진 방법을 사용해 구축됨.
모든 객체에는 연결된 락이 존재한다.
규칙에 따라 객체 필드에 대한 일관된 액세스가 필요한 스레드는 액세스 전 객체의 락을 획득한 다음, 작업이 완료되면 락을 해제해야 함. java.util.concurrent.locsk 패키지에 여러가지 락 구현 방법이 포함됨.

동기화 메소드의 경우, synchronized 키워드를 붙여준다.

데드락... 따흐흑...

---

스레드 간의 조정
두 개의 스레드를 이용할 때, 데이터를 공유하면 공유된 객체를 이용해 통신을 하게 되는 케이스가 있음.
데이터를 보내기 전에 가져오려고 시도하면 안되고, 데이터를 받았는지 확인하지 않고 생성하면 안됨.
그런데 이런 걸 체크할 때 스레드를 while 루프와 같이 검사하게 되면 cpu의 시간을 매우 낭비하게 된다. 이런 걸 폴링이라고 한다. (*폴링은 하나 씩 빼오는 것이 아닌지?*)

wait(), notifyAll()
조건 만족될 때까지 스레드를 일시 중지시킬 수 있다.
wait() 사용 시 다른 스레드가 어떤 이벤트 발생했다고 알려주기 전까지 스레드가 중지됨.
notifyAll()은 어떤 이벤트가 발생했다고 알려주는 메서드

주의사항
wait()에서 리턴 후 반드시 컨디션을 재검사해야됨
발생된 이벤트가 우리가 원하는 이벤트인지 알 수 없음.
InterruptedException도 발생 가능

또한, synchronized를 이용해야 한다. 락을 가지고 있다가 wait()을 사용하게 되면 해당 메모리에 대한 락을 해제하게 됨. 해제하지 않으면 아주 끔찍한 시간을 보내게 된다.

