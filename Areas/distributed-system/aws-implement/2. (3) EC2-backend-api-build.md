# EC2 백엔드 API 서버 구축하기

EC2 백엔드 API 서버는 요청을 테스트하기 위한 가장 핵심 서버이다.
앞으로도 구현 실험을 계속 할 것인 만큼 이곳은 CI/CD 파이프라인을 구축하여 빠른 배포를 할 수 있도록 만들어야 한다.

따라서 Github Actions와 Docker를 이용하여 컨테이너를 사용하는 방식으로 구현해줄 것이다.

Jenkins 써보고 싶지만 다 때가 있는 법이다. 언젠가는... 해줄 것이다!!!
Github Actions가 구현이 빠르기 때문에 선정해주었다.

파이프라인은 다음과 같이 구성한다.

1. Github에서 Commit이 발생하여 Actions가 트리거되었다.
2. Docker 이미지 빌드
	1. 어플리케이션을 Jar 파일로 빌드한다.
	2. 빌드된 Jar를 DockerFile을 기반으로 이미지를 빌드한다.
	3. Github Secrets에 저장된 DockerHub 사용자 정보를 이용하여 이미지를 push 한다.
3. AWS SSH 연결
	1. AWS 로드밸런서에 SSH로 연결한다.
	2. 로드밸런서 인스턴스에 접속한 상태에서 각각의 api 서버에 도커 이미지를 pull 해준다.
	3. 이겼다! 3부 완!

> 왜 로드밸런서에서 SSH로 접속해서 각각의 서버에 또 추가로 SSH 접속 해주는가?
> 이는 Elastic IP를 최대한 적게 쓰기 위함이다. 관리하기 힘듬.
> 이로 인해 보안 문제가 발생할 수 있지만 이미 ssh 쓰는 시점에서 보안은 물건너 갔다.


2번 까지의 Job 은 이미 구현이 된 바 있다.
아래를 참고하자.
```yml
name: Build and Push Docker Image
  
on:  
  push:  
    branches: [ scenario/* ]  
  workflow_dispatch:  
  
jobs:  
  build:  
    runs-on: ubuntu-latest  
  
    steps:  
      - name: Checkout repository  
        uses: actions/checkout@v4  
  
      - name: Set up JDK  
        uses: actions/setup-java@v4  
        with:  
          java-version: '21'  
          distribution: 'temurin'  
  
      - name: Grant execute permission for Gradle wrapper  
        run: chmod +x gradlew  
  
      - name: Build JAR with Gradle  
        run: ./gradlew bootJar  
  
      - name: Log in to DockerHub  
        uses: docker/login-action@v3  
        with:  
          username: ${{ secrets.DOCKER_USERNAME }}  
          password: ${{ secrets.DOCKER_PASSWORD }}  
  
      - name: Set safe image tag  
        id: vars  
        run: |  
          SAFE_TAG=$(echo "${GITHUB_REF_NAME}" | tr '/' '-')  
          echo "SAFE_TAG=$SAFE_TAG" >> $GITHUB_OUTPUT  
  
      - name: Build and Push Docker image  
        uses: docker/build-push-action@v6  
        with:  
          context: .  
          push: true  
          tags: |  
            ${{ secrets.DOCKER_USERNAME }}/spring_batch_instruction:${{ steps.vars.outputs.SAFE_TAG }}  
            ${{ secrets.DOCKER_USERNAME }}/spring_batch_instruction:latest
```

여기까지가 build라는 하나의 Job이었다. 우리는 여기에 추가로 Step을 추가하지 않고 새로운 Deploy라는 Job을 추가할 것이다.

```yml
deploy:  
  name: Deploy to EC2 via SSH  
  runs-on: ubuntu-latest  
  needs: build  
  steps:  
    - name: SSH Deploy  
      run: echo "Deploying..."  
  
      # 2️⃣ Connect to Load Balancer EC2    - name: SSH into Load Balancer and Deploy to APIs  
      env:  
        PRIVATE_KEY: ${{ secrets.LB_SSH_KEY }}  
        LB_HOST: ${{ secrets.LB_HOST }}  
        API1_PRIVATE_IP: ${{ secrets.API1_PRIVATE_IP }}  
        API2_PRIVATE_IP: ${{ secrets.API2_PRIVATE_IP }}  
        DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/spring_batch_instruction:${{ steps.vars.outputs.SAFE_TAG }}  
      run: |  
        echo "$PRIVATE_KEY" > key.pem  
        chmod 600 key.pem  
  
        echo "Connecting to Load Balancer EC2..."  
        ssh -o StrictHostKeyChecking=no -i key.pem ubuntu@$LB_HOST << 'EOF'  
          echo "Connected to Load Balancer"  
  
          # 내부 서버에 SSH 접속하여 Docker pull & restart  
          for SERVER in $API1_PRIVATE_IP $API2_PRIVATE_IP; do  
            echo "Deploying to \$SERVER ..."  
            ssh -o StrictHostKeyChecking=no -i /home/ubuntu/.ssh/id_rsa ubuntu@\$SERVER \  
            "  sudo docker stop backend || true && \  
               sudo docker rm backend || true && \  
               sudo docker pull $DOCKER_IMAGE && \  
               sudo docker run -d --name backend -p 8080:8080 $DOCKER_IMAGE && \  
               echo 'Deployment complete on \$SERVER'"  
          done  
  
          echo "✅ All deployments completed!"  
        EOF
```

필요한 Github Secrets는 다음과 같다.
- DOCKER_USERNAME
- DOCKER_PASSWORD
- LB_SSH_KEY
- LB_HOST
로드밸런서의 DNS 또는 IP 
- API1_PRIVATE_IP
- API2_PRIVATE_IP


---

이제 인스턴스의 세팅이다.

```bash
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
```

curl 도중에 connection timeout으로 연결하지 못할 수 있다.
일반적으로로 aws 측의 이슈이니 [사례](https://hehesim.tistory.com/307)를 참고하여 아웃바운드 규칙에 https가 없는지 확인해보자.


도커 설치 (최신 버전)
```console
 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

체크
```console
 sudo docker run hello-world
```

백엔드 api-1,2 세팅 완료

---

이제 깃헙에서 푸시해보자!

푸시 후 바로 되진 않을 것이다.
왜냐하면 DB를 세팅해주지 않았기 때문이다.
아뿔싸!