
타임리프 특징
- SSR
  타임리프는 백엔드 서버에서 html을 동적 렌더링하는 용도로 사용
- 내츄럴 템플릿
  [[8. spring-mvc-webpage]]
  참고.
- 스프링 통합 지원
  타임리프와 스프링은 자연스럽게 통합되고, 스프링의 다양한 기능을 편리하게 사용할 수 있게 지원함.

---

# text, utext

### html 엔티티
`<b>`와 같은 태그를 출력 시 문자로 표현할 수 있는 방법 필요.
이것을 html 엔티티라고 함. 특수 문자를 html 엔티티로 변경하는 것을 이스케이프 라고 한다!
th:text, `[[...]]`는 기본적으로 이스케이프를 제공한다.
`<` -> `&lt`
`>` -> `&gt`
기타 수많은 html 엔티티 존재

> 추가 내용은 검색할 것.

Unescape
이스케이프 기능을 사용하지 않으려면 utext를 사용한다.

th:utext, `[(...)]`를 이용하면 unescape 기능을 이용할 수 있다.

왜? 이스케이프 처리를 할까?
사용자가 임의로 작성한 태그들 때문에 스타일이 깨질 수 있다. (언급 안했으나 script같은 태그 넣으면 보안 문제 발생 가능. gpt는 출력 인코딩 미비에 따른 XSS로 분류할 수 있다고 한다...?)
태그도 사용하도록 의도할 경우 언이스케이스 처리를 하는 것이 맞다.

---

# Spring EL

변수 표현식? `${...}`

> 가끔씩 인텔리제이가 문법 오류를 만들 때도 있다고 함.

스프링 EL 표현식들

`${user.username}`을 하게 되면 오브젝트에서 바로 접근하는 것이 아니라, getter를 이용해서 가져온다고 한다. 그냥 getter 표현식도 가능함.
`['username']` 같은 식으로도 가져올 수 있다.

List의 경우, `[0]`처럼 인덱스 넣어서 쓸 수 있다. 필드 접근은 오브젝트와 동일

Map의 경우 `['user']`처럼 사용해준다. JS랑 유사함. 필드 접근은 이것도 동일함.

타임리프도 지역변수 선언이 가능핟.ㅏ
th:with = `fisrt=${users[0]}`
이런식으로 활용 시, first라는 지역변수를 활용할 수 있다.

---

# 기본 객체들

session 맛뵈기

request, response, session, servletContext, locale

예시
${#request}
${session.sessionData}
또는 빈도 직접 접근 가능함.

```
    // 예시: HelloWorldService 빈
    @Service
    public class HelloWorldService {
        public String hello(String name) {
            return "Hello, " + name + "!";
        }
    }
```

`${@helloService.hello('Thymeleaf')}`
이런 식으로 접근 가능하다!

---

# 유틸리티 객체와 날짜

문자, 숫자, 날짜, URI 등을 편리하게 다루는 다양한 유틸리티 객체가 존재함.

타임리프 공식문서에서 예제를 잘 설명해준다!

자바 8 날짜
LocalDate, LocalDateTime, Instant 사용 시 추가 라이브러리가 필요한데, 타임리프 라이브러리에 포함되어있다.

`#temporals` 사용 가능!
`${#temporals.format()}` 해서 포매팅도 가능하다. 기능 많음.

---

# URL 링크

`@{...}`를 사용한다

`@{/hello(param=${param1}, param2=${param2}`
param1, param2를 query parameter로 받기

`@{/hello/{param1}/{param2}(param=${param1}, param2=${param2}`
param1, param2를 path variable로 받기

`@{/hello/{param1}(param=${param1}, param2=${param2}`
섞어 쓰기. param1은 패스, 2는 쿼리...

---

# 리터럴

리터럴은 소스 코드 상에서 고정된 값을 말하는 용어다.
리터럴로 문자, 숫자, 불린, null 과 같은 것이 있다.

타임리프에서 문자 리터럴은 항상 작은 따옴표로 감싸야 한다.
`'hello!'`
근데 항상 `'`로 감싸는건 너무 귀찮다.
다음과 같이 작은 따옴표를 생략할 수 있다.
`th:text="hello"`

`th:text="hello world"`
문자 리터럴은 원칙상 `'`로 감싸야 하기 때문에, 공백이 있다면 의미있는 토큰으로 인식되지 않는다.
`'hello world'`와 같이 감싸주어야 한다.
문자열 리터럴은 더해주거나, 리터럴 대체를 사용해야 한다.
`|hello ${data}|` 처럼 사용할 수 있다! 데이터와 문자 리터럴 혼용 시 이렇게 해주면 된다.

---

# 연산

자바와 크게 다르지 않지만, html 엔티티를 사용하는 부분은 주의해야 한다.

비교 연산
```
&gt, gt, ge 같은 거 쓴다...
```

조건식
```
? :
```

Elvis 연산자
조건식을 편하게 쓸 수 있다.
데이터 없는지 확인할 때 씀.
```
${data}?: '데이터가 없습니다'
```
있으면 데이터 출력...

비교연산 : HTML 엔티티 사용 부분 주의
`>`는 `&gt`, `<`는 `lt`... 
조건식은 자바 조건식과 유사하다.
Elvis 연산자는 조건식의 편의 버전이다.
No-Operation `_`인 경우 마치 타임리프가 실행되지 않는 것처럼 동작하며, 활용할 시 html의 내용을 그대로 활용할 수 있다.
i.e. `${data}?: _`

---

# 속성 값 설정

타임리프는 태그의 기존 속성들을 `th:*` 형식으로 입력된 속성들로 바꿔치기하는 식으로 동작함.
서버를 타게 되면 th 속성을 렌더링 해주면서 화면이 만들어진다.
html 파일로도 보인다! 대신 서버에서 렌더링하지 않으면 th 속성은 브라우저가 버린다. (코드에는 그대로 남아있고, 보여지지 않는다.)

기존 태그에 추가하는 편의 기능도 존재함.
`th:attrappend="class=' large'`와 같이 입력 시, class 태그에 large를 추가한다.
`attrprepend`는 앞에 붙이고 append는 뒤에 붙인다.

classappend를 사용할 시 class=도 작성안하고 그냥 문자열에 입력해주면 된다.
`th:classappend="large"`와 같이 작성 가능.

checked 처리
html에서 checked 속성은 값과 상관없이 존재만 해도 체크가 된다. true, false 값을 주로 사용하는 개발자 입장에서 불편하다.

th:checked는 값이 false인 경우 checked 속성을 제거한다!

---

# 반복

th:each를 사용하면 되는데, 상태값을 알 수 있는 추가적인 편의 기능 등을 제공한다.

```html
<tr th:each="user : ${users}">
	<td th:text="${user.username}"> username </td>
```
위와 같이 동작

리스트, 배열, 이터러블 등 이터러블한 객체
Map도 사용 가능. 변수에 담기는 값은 Map.Entry

반복에 대한 상태를 나타내는 현재 루프에 대한 상태를 알려주는 객체를 추가로 제공함.

index, count, size, even/odd, first/last, current 등
index는 0부터 시작
count는 1부터 시작
first는 첫번째인지 여부
even/odd는 홀짝
current는 현재 객체

```html
<tr th:each="user, userStat : ${users}">
	<td th:text="${user.username}"> username </td>
```
여기서 userStat이 그거임!
굳이 each에서 작성하지 않고, 생략해도 동작한다.
네이밍 규칙은 for문에서 돌아가는 객체 (여기서는 user) 이름에 Stat 붙여주면 된다.

---

# 조건문

if, unless 사용 가능
if는 우리 모두가 아는 if
unless는 그 반대. false일 때 출력함

조건을 충족해야 해당 태그가 출력되는 특징이 있다.

---

# 주석

주석 유형
```
html
<!-- -->

타임리프 파서
타임리프 파서 차원에서 주석처리해서 html 렌더링 시 해당 부분이 안나옴.
<!--/* [[${data}]] */-->

아래와 같이 사용하는 것도 동일
<!--/*-->
<some_tag></some_tag>
<!--*/-->


타임리프 프로토타입
html 주석이라 브라우저에서 파일을 직접 렌더링 시 안보여주지만, 타임리프로 렌더링 시 보인다.
타임리프로 보여줄 때만 렌더링할 때 사용. 많이 쓰이는 것은 아님.
<!--/*/
<some_tag></some_tag>
/*/-->
```

---

# 블록

th:block
타임리프가 제공하는 자체 태그

div 태그를 하나씩 루프를 돌리면 th:each를 이용해주면 된다.
그런데 div 태그를 각각에 씌워주고 싶다!
```
<div>
info1
</div>
<div>
info2
</div>
...
```
이런 상황. 그런데, div 태그 안에서 돌리고 싶지 않은 상황임!
일반적인 반복이 힘든 상황에서 더미 태그 형식으로 사용한다.
렌더링할 때 제거가 됨.



---

# JS 인라인

js에서도 타임리프를 사용할 수 있도록 기능을 제공한다.

`[[${user.username}]]`
이런식으로 하면 값을 사용 가능
`"[[${user.username}]]"`
인라인 미사용시 문자열의 경우 이렇게 해야 정상작동 (스크립트에 진짜로 문자열 그대로 넣어서 JS상에서는 문자열인지 모름.)

var username = `/*`[[${user.username}]]`*/` "test username";
이런식으로 내추럴 템플릿으로도 사용 가능하다.

`[[${user}]]`
객체를 통짜로 넣어줄 때 사용함.
인라인 미사용 시 객체 넣어주면 toString 호출한다.

정말 나이브하게 코드를 해석하고 넣어준다.
그래서 F12로 확인하면 값이 이상하게 나오는 걸 볼 수 있음.
이런 불편한 고민거리를 없애주도록 JS 인라인 기능을 제공한다.

`<script th:inline="javascript">`
이걸 사용하면 타임리프가 인라인으로 사용하겠다고 선언하는 것임.
그래서 위 형식으로 설정해주면 위의 텍스트 렌더링 같은 불편한 점을 해결해준다.

문제가 될 수 있는 문자를 이스케이프 처리 해주는 기능도 존재한다.

인라인 each도 지원한다.
`[# th:each="user, stat : ${users}"]`
`tags`
`[/]`
이런 식으로 사용 시 타임리프로 받은 객체의 루프문도 사용 가능하다!

---

# 템플릿 조각

페이지의 각 영역을 분리하고 렌더링 시 합치는 기능
타임리프는 템플릿 조각과 레이아웃 기능을 지원한다.

```
th:fragment="footer"

th:fragment="footerParam (param1, param2)"
```
이런 식으로 해두면 다른 파일에서 이 파일을 불러서 사용할 수 있다.

```
부분 포함 insert
th:insert="~{template/fragment/footer :: footer}"

부분 포함 replace
th:replace="~{template/fragment/footer :: footer}"

부분 포함 단순 표현식
th:replace="template/fragment/footer :: footer"

데이터 사용
th:replace="~{template/fragment/footer :: footerParam (data1, data2)}"
```
다른 파일을 불러오는 기능

파라미터 전달하여 변수가 바인딩되서 해당 값으로 치환시키는 기능도 제공함. 따로 네이밍 룰은 없는듯...?

---

# 템플릿 레이아웃

템플릿 조각보다 개념을 확장시킨 기능

어떤 레이아웃이 있고 거기에 내 코드조각을 넘기는 것
이미 레이아웃이 있고 내 코드를 넣어준다!

공통 레이아웃
```
<head th:fragment="common_header(title,links)">
<title th:replace="${title}">레이아웃 타이틀</title>
<th:block th:replace="${links}" />
...
```

레이아웃 적용하는 html
```
<head th:replace="path/base :: common_header(~{::title}, ~{::link})">
<title>메인 타이틀</title>
<link rel~~~...>
<link rel~~~...>
...

<body>
컨텐츠
</body>
```

각 레이아웃 별로 다르게 하고 싶을 때 이렇게 만들어줄 수 있음.
위처럼 만들게 되면 단순히 패러미터로 주는 게 아니라 태그 자체를 집어넣어버림

th:block 사용 해주면 link 태그처럼 여러개 넣어주는 경우도 한 줄씩 다 넣어줄 수 있다.

## 템플릿 레이아웃 확장

이번엔 헤드만 하는 게 아니라 html 전체를 레이아웃 개념으로 두고 우리 코드가 레이아웃 식으로 맞추는 방법

레이아웃
```
<html th:fragment="layout (title, content)" ~~~>
<head>
<title th:replace="${title}">레이아웃 타이틀</title>
...
<title
<div th:replace="${content}">
레이아웃 컨텐츠
</div>
```

레이아웃 적용하는 html
```
<html th:replace="path/base :: common_header(~{::title}, ~{::section})">
<head>
<title>메인 타이틀</title>
...
<body>
<section>
...
</section>
```
이런 식으로 넣어주면 된다.
이렇게 되면 레이아웃 자체가 바뀌게 됨.

