이번 실습 프로젝트 구조는 domain이랑 web이랑 분리해둠
도메인은 웹과 관련된 코드를 다 들어내서 의존성이 존재하도록 하면 안된다고 함.

간단하게 분리해주면 되지만, 몇몇 복잡한 케이스들이 존재
form을 웹에다 두고, 리포지토리 같은 데서 form을 참조하게 될 시 웹을 참조하게 되는 것.

예제에서는 리포지토리를 해시맵으로 빠르게 테스트만 함.

회원가입, 로그인 각각 구현
Optional 컬렉션으로 한번 래핑해준다.
findBy~~ 뒤에 filter()를 붙여서 맞는지 확인하고 orElse()로 if else문 압축이 가능하다.

글로벌 오류
아이디 또는 비밀번호가 맞지 않은 경우
Valid 같은 유효성으로 검증하기 어려움.
글로벌 에러 ObjectError 생성.

---

로그인을 성공하면 로그인 처리 후 페이지로 이동해야 한다.
쿠키를 사용하는 것을 알아본다.

Http는 stateless.
브라우저는 캐시를 통해 어떤 데이터를 저장하고 관리한다.
로그인 성공 시 서버에서 쿠키를 전달해주면 브라우저는 캐시에 저장한다.

영속 쿠키, 세션 쿠키가 있다.
세션 쿠키는 만료 날짜를 생략하는 것. 브라우저 종료 시까지만 유지
영속 쿠키는 만료 날짜까지만 유지

로그인 컨트롤러에서 쿠키를 직접 만들어본다.

Cookie 클래스를 통해 만들어줄 수 있다.
new Cookie(name, value)로 만들어주고 응답에 넣어준다.
HttpServletResponse 객체에 .addCookie()

쿠키는 패러미터가 많은데, 시간 정보를 넣지 않았기 때문에 세션 쿠키가 된다.
여기선 세션 쿠키를 사용한다.

그럼 이렇게 만들어진 쿠키를 어떻게 활용하나?
@CookieValue(name = "memberId", required = false) Long memberId
형식으로 파라미터를 설정해줄 수 있음.
이제 PK 주니까 리포지토리에서 가져올 수 있다!

물론 이렇게 인증 시스템을 만들면 보안 팀이 등에 칼을 꼽을 수 있으니 이렇게 해서는 안된다.

브라우저등에서 쿠키 조작을 가능하고, 이 때문에 위변조가 가능함.
쿠키는 탈취도 가능하다.
사용자 로컬에서, 네트워크 전송 구간에서 탈취도 가능하다.

탈취한 순간 사용자 정보를 알게된다.

한번 훔쳐가면 평생 사용 가능

대안
중요 값 노출 x, 임의 토큰 값 노출.
서버에서 토큰과 사용자 id를 매핑해서 인식. 서버에서 토큰을 관리
토큰은 해커가 임의 값을 넣어도 찾을 수 없도록 예상 불가능해야 한다.
해커가 토큰을 탈취해도 일정 시간이 지나면 사용할 수 없도록 서버에서 토큰 만료 시간을 짧게 유지한다. 해킹 감지하더라도 서버에서 해당 토큰을 강제로 제거하면 된다.


---

