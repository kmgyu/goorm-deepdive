# 1. HTTP Response - 정적 리소스,뷰 템플릿

스프링에서 응답(데이터)를 만드는 방법은 크게 3가지이다.

- 정적 리소스   
  - HTML, CSS, js 등
- 뷰 템플릿 사용
  - 동직인 HTML
- HTTP 메시지 사용
  - HTTP API를 제공하는 경우에는 HTML이 아닌 데이터를 실어 넣어야하므로 HTTP 메시지 바디에 JSON같은 형식의 데이터를 실어서 보냄.

## 1.1 정적 리소스

Spring boot에서 정적 리소스 경로는 정해져있다.

```text
/static 또는
/public 또는
/resources 또는
/META-INF/resources 
```

로 정해져있다. src/main/resources는 리소스를 보관하는 곳이고, 또 클래스패스의 시작경로이다.  
따라서 다음 디렉토리에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스를 제공한다.

```text
src/main/resources/static
```

다음 경로에 파일이 들어있다고 치면

```text
src/main/resources/static/basic/form.html
```

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<form action="/request-param-v1" method="post">
  username: <input type="text" name="username" />
  height: <input type="text" name="height" />
  <button type="submit">전송</button>
</form>
</body>
</html>
```


`localhost:8080/basic/form.html`으로 접근이 가능하다.


## 1.2 뷰 템플릿

뷰 템플릿을 거쳐서 HTML이 생성되고, 뷰가 응답을 만들어서 전달한다.  
일반적으로 HTML을 동적으로 생성하는 용도로 사용하지만, 다른 것들도 가능하다. 뷰 템플릿이 만들 수
있는 것이라면 뭐든지 가능하다.  

**뷰 템플릿 경로**

```text
src/main/resources/templates
```

**해당 경로에 있는 thymeleaf 템플릿을 사용한 html code**

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p th:text="${data}">empty</p>
</body>
</html>
```

컨트롤러에서 해당 페이지를 띄우는 3가지 방법에 대해 알아볼 것임.

> 바인딩 된 경우 정적 리소스 등에서도 제한적으로 접근 가능하다.

### 1.2.1 ModelAndView

```java
package hello.springmvc;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class thymeleafTest {

    @RequestMapping("/response-v1")
    public ModelAndView view1(){
        ModelAndView modelAndView = new ModelAndView("/thymeleaf")
                .addObject("data", "hello!");
        return modelAndView;
    }

}
```

3가지 방법을 쓰면서 지켜봐야할건 return 타입과, 인자다.

ModelAndView 방식은 객체를 반환하게 되어있다. 따라서 새로운 객체를 생성해서 View이름과 데이터를 넣어준것이다.



### 1.2.2 인자에 Model 사용

```java
package hello.springmvc;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class thymeleafTest {
    @RequestMapping("/response-v2")
    public String view2(Model model){
        model.addAttribute("data","hello!");
        return "/thymeleaf";
    }
}

```
 
리턴값은 String으로 뷰 이름을 넘겼다. 또한, 인자는 Model을 적어서 보내는 데이터를 추가하였다.

이런 상황에서 @Responsebody가 없다면 뷰 리졸버가 실행되어 뷰를 찾고, 렌더링한다.
@Responsebody가 있으면 뷰 리졸버를 실행하지 않고, HTTP 바디에 직접 `/thymeleaf`라는 문자가 입력된다.

### 1.2.3 void 타입 핸들러 및 생략 처리

**권장하지 않는 방법**
논리적 뷰와 요청 url의 경로가 같다면 생략이 가능하다.

```java
package hello.springmvc;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class thymeleafTest {
    @RequestMapping("/thymeleaf")
    public void view3(Model model){
        model.addAttribute("data", "hello!");
    }
}

```

@Controller를 사용하고, HttpServletResponse, OutputStream(Writer) 같은 http 메시지 바디를 처리하는 파라미터가 없으면 요청 url을 참고해 논리 뷰 이름으로 사용한다.
요청 url : /thymeleaf/hello
실행 : /templates/thymeleaf/hello.html

명시성이 너무 떨어지고 이렇게 딱 맞는 경우도 없다. 강의에서도 권장하지 않는 방식

@ResponseBody, HttpEntity 사용시 뷰템플릿 사용하는 것이 아니라 http 메시지 바디에 직접 응답 데이터를 출력 가능하다. 물론 이미 해본 방법 강조!


때로는 너무 명시적이지 않다면 협업시 의사소통이 별도로 필요해서 불편할 때가 있다. 이런 코드는 상황을 더 짜릿하게 만들어줄 수 있다.

build.gradle에서 다음과 같이 의존성 추가 시, 스프링 부트가 자동으로 ThymeleafViewResolver와 필요한 스프링 빈들을 등록한다.
```text
`implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'`
```


또한, application.properties에 대한 설정도 자동으로 해준다.

```text
//application.properties
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
```

따라서 논리적 뷰를 반환할 때 뒤에 .html을 안 붙여도 되는 이유이다.

# 2. HTTP Response - HTTP API, 메시지 바디에 직접 입력

앞에서 했던 내용을 복습한다.

응답메시지를 보낼때 뷰나 템플릿을 거치지 않고 직접 HTTP 응답 메시지를 작성하는 방법들이다.


## 2.1 원시적인 방법 - HTTPServlet 사용

```java
package hello.springmvc.basic.response;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Controller
public class ResponseController {
    @GetMapping("/response-string-v1")
    public void responseBodyV1(HttpServletRequest request, HttpServletResponse response)throws IOException {
        response.getWriter().write("V1 ok");
    }
}
```

## 2.2 ResponseEntity<> 사용.

```java
package hello.springmvc.basic.response;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Controller
public class ResponseController {
    @GetMapping("/response-string-v2")
    public ResponseEntity<String> responseBodyV2(){
        return new ResponseEntity<>("V2 ok", HttpStatus.OK);
    }
}
```

여기서 주목해야할 점은 내가 직접 HTTP 상태값을 바꿀 수 있다는 것이다. 즉 분기에 따라서 상태값들을 바꾸기 용이하다는 것이다.

## 2.3 @ResponseBody 사용

```java
package hello.springmvc.basic.response;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Controller
public class ResponseController {
    @ResponseBody
    @GetMapping("/response-string-v3")
    public String responseBodyV3(){
        return "V3 ok";
    }
}

```

## 2.4 JSON 넘기기 - ResponseEntity 객체 사용

```java
package hello.springmvc.basic.response;

import hello.springmvc.basic.HelloData;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Controller
public class ResponseController {
    @GetMapping("/response-json-v1")
    public ResponseEntity<HelloData> responseJsonV1(){
        HelloData helloData = new HelloData();
        HelloData.setName("kms");
        HelloData.setHeight(178);
        HelloData.setWeight(74);
        return new ResponseEntity<>(helloData,HttpStatus.OK);
    }

}

```

직접 객체를 만들고 그 객체에 값을 넣어서 반환한다.

## 2.5 JSON 넘기기 - @ResponseBody 사용.

```java
package hello.springmvc.basic.response;

import hello.springmvc.basic.HelloData;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Controller
public class ResponseController {
    @ResponseBody
    @GetMapping("/response-json-v2")
    public HelloData responseJsonV2(){
        HelloData helloData = new HelloData();
        HelloData.setName("jyb");
        HelloData.setHeight(160);
        HelloData.setWeight(47);
        return HelloData;
    }
}

```

@ResponseBody는 HTTP 응답 코드를 설정하기 까다로울 것이다.
@ResponseStatus(HttpStatus.OK)와 같이 어노테이션 활용하면 응답코드 설정 가능하다

```java
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    @GetMapping("/response-json-v2")
    public HelloData responseJsonV2(){
        HelloData HelloData = new HelloData();
        HelloData.setName("jyb");
        HelloData.setHeight(160);
        HelloData.setWeight(47);
        return HelloData;
    }
```

그러나 이 역시도 한계가 있다. 코드 내에서 분기별로 상태코드를 줘야할 때 그러지 못한다는 점이다.

따라서 프로그램 조건에 따라 동적으로 변경하려면 ResponseEntity를 사용하면 된다.

## 2.6 @RestController

@RestController
@Controller 대신에 @RestController 애노테이션을 사용하면, 해당 컨트롤러의 핸들러 메소드는 모두 @ResponseBody 가 적용되는 효과가 있다.  

따라서 뷰 템플릿을 사용하는 것이 아니라, HTTP 메시지 바디에 직접 데이터를 입력한다.

이름 그대로 Rest API(HTTP API)를 만들 때 사용하는 컨트롤러이다.

참고로 @ResponseBody 는 클래스 레벨에 두면 전체에 메서드에 적용되는데, @RestController
에노테이션 안에 @ResponseBody 가 적용되어 있다.

즉 위의 코드의 통합본으로 밑과 같이 작성하면 전부 잘 동작한다는 것이다.

무한으로 @ResponseBody를 쓰는 것을 줄여주고, 모든 메소드에 적용되기 때문에 API에 적합하다는 것이다. 어느 한 군데는 view를 반환해야 한다면 쓸 수가 없기 때문이다!

```java
package hello.springmvc.basic.response;

import hello.springmvc.basic.HelloData;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

//@Controller + @ResponseBody = @RestController
@RestController
public class ResponseController {

    @GetMapping("/response-string-v1")
    public void responseBodyV1(HttpServletRequest request, HttpServletResponse response)throws IOException {
        response.getWriter().write("V1 ok");
    }

    @GetMapping("/response-string-v2")
    public ResponseEntity<String> responseBodyV2(){
        return new ResponseEntity<>("V2 ok", HttpStatus.OK);
    }
    
    @GetMapping("/response-string-v3")
    public String responseBodyV3(){
        return "V3 ok";
    }

    @GetMapping("/response-json-v1")
    public ResponseEntity<HelloData> responseJsonV1(){
        HelloData HelloData = new HelloData();
        HelloData.setName("kms");
        HelloData.setHeight(178);
        HelloData.setWeight(74);
        return new ResponseEntity<>(HelloData,HttpStatus.OK);
    }

    @ResponseStatus(HttpStatus.OK)
    @GetMapping("/response-json-v2")
    public HelloData responseJsonV2(){
        HelloData HelloData = new HelloData();
        HelloData.setName("jyb");
        HelloData.setHeight(160);
        HelloData.setWeight(47);
        return HelloData;
    }
}

```

---

# 메시지 컨버터

뷰 템플릿으로 HTML을 생성해서 응답하는것이 아니라, HTTP API 처럼 JSON같은 데이터로 응답을 보낼때 메시지 컨버터를 사용하면 편하다.

@ResponseBody의 호출 구조는 이렇다.

![[lecture-spring-mvc-1.57.1.png]]
> 출처 : 강의자료

1. 요청이 들어오면 Controller 호출
2. Controller에 @ResponseBody를 보고 viewResolver 대신 HttpMessageConverter가 동작
3. 들어온 데이터를 보고 JSONConvert, StringConverter, 등등을 파악함.
4. 요청 데이터와 헤더 등을 조합하여 새로운 메시지를 생성하고 반환.

`@ResponseBody` 를 사용시
HTTP의 BODY에 문자 내용을 직접 반환
viewResolver 대신에 `HttpMessageConverter` 가 동작 
기본 문자처리: `StringHttpMessageConverter`
기본 객체처리: `MappingJackson2HttpMessageConverter` 
`byte` 처리 등등 기타 여러 `HttpMessageConverter`가 기본으로 등록되어 있음

참고 : 응답의 경우 클라이언트의 Accept 헤더와 서버 컨트롤러의 반환 타입을 둘을 조합해서 HttpMessageConverter가 선택된다.

아무튼 스프링MVC는 다음의 경우에 HTTP 메시지 컨버터를 적용한다.
- HTTP 요청 : @RequestBody, HttpEntity(RequestEntity)
- HTTP 응답 : @ResponseBody, HttpEntity(ResponseEntity)


http 메시지 컨버터 인터페이스

```java
package org.springframework.http.converter;

public interface HttpMessageConverter<T> {
    boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);
    boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);

    List<MediaType> getSupportedMediaTypes();

T read(Class<? extends T> clazz, HttpInputMessage inputMessage)
throws IOException, HttpMessageNotReadableException;

void write(T t, @Nullable MediaType contentType, HttpOutputMessage
outputMessage)
throws IOException, HttpMessageNotWritableException;
}
```

HTTP 메시지 컨버터는 HTTP요청 HTTP응답 모두에서 사용된다.

당연하게도 can~은 읽을 수 있는지, 쓸 수 있는지에 대한 체크이다.
해당 클래스, 미디어 타입을 지원하는 지 체크하는 것임.

read, write는 메시지 컨버터를 통해 메시지를 읽고 쓰는 기능이다.

스프링의 판단 기준에 대해 알아보자.

```text
(일부 생략)
0 = ByteArrayHttpMessageConverter
1 = StringHttpMessageConverter
2 = MappingJackson2HttpMessageConverter
```

스프링 부트는 다양한 메시지 컨버터를 제공한다. 대상 클래스 타입과 미디어 타입 둘을 체크하여 사용여부를 결정하게 되는데, 만약 만족하지 않으면 다음 메시지 컨버터로 우선순위가 넘어간다.
클래스 이름이 직관적이다. 공부하기 좋아보임.

입력으로 온 데이터가 배열이고 문자열이고 JSON인지는 어떻게 판단할까?
그건 요청으로 들어온 데이터와 헤더값 중 미디어 타입에 따라서 달라진다.

- ByteArrayHttpMessageConverter
  - 클래스 타입이 'byte[]'이고, 미디어 타입이 '`*/*`' 인 경우
  - 요청 예) @RequestBody byte[] data
  - 응답 예) @ResponseBody byte[] data 이 경우 반환 미디어 타입 = application/octet-stream
- StringHttpMessageConverter
  - 클래스 타입이 'String'이고, 미디어 타입이 '`*/*`'인 경우
  - 요청 예) @RequestBody String data
  - 응답 예) @ResponseBody return "ok"; 이 경우 반환 미디어 타입 = `text/plain`
- MappingJackson2HttpMessageConverter
  - 클래스 타입이 '객체 또는 HashMap', 미디어 타입이 'application/json'관련 경우
  - 요청 예) @RequestBody BmiData data
  - 응답 예) @ResponseBody bmidata 이 경우 반환 미디어 타입 = `application/json`
  
예시1

```text
content-type: application/json

@RequestMapping
void hello(@RequetsBody String data) {}
```

이런 요청이 들어오면 어떤것을 선택해야할까? 당연히 StringHttpMessageConverter이다.

왜냐하면 들어온 데이터의 타입이 String이고, 미디어 타입도 `*/*`에 포함되는 `application/json`이기 때문이다.

예시2

```text
content-type: application/json

@RequestMapping
void hello(@RequetsBody HelloData data) {}
```

MappingJackson2HttpMessageConverter가 호출된다.

예시3

```text
content-type:text/html

@RequestMapping
void hello(@RequestBody HelloData data) {}
```

 content-type이 json과 관련이 없기 때문에 아무것도 출력되지 않는다.


HTTP 요청 데이터 읽기
1. HTTP 요청이 오고, @ResponseBody, HttpEntity 파라미터를 사용한다.
2. 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 canRead() 호출. 
    - HTTP 요청이 대상 클래스 타입을 지원하는지 확인
    - HTTP 요청의 Content-Type 미디어 타입을 지원하는지 확인
3. canRead()의 조건을 만족 시 read() 호출, 객체를 생성 후 반환.

HTTP 응답 데이터생성
1. 컨트롤러에서 @ResponseBody, HttpEntity로 값이 반환된다.
2. 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 canWrite() 호출
    - 대상 클래스 타입을 지원하는가? (데이터 타입)
    - HTTP 요청의 Accept 미디어 타입을 지원하는가?
3. canWrite() 조건을 만족하면 write()를 호출해서 HTTP 응답 메시지 바디에 데이터 전달

# 메시지 컨버터의 위치

스프링 MVC 구조를 다시 생각해봐야 한다.

모든 비밀은 어노테이션 기반 컨트롤러, 즉 @RequestMapping을 처리하는 핸들러 어댑터인 RequestMappingHandlerAdapter에 있다.



![[lecture-spring-mvc-1.58.1.png]]
 
> 출처 : 김영한 선생님 강의 노트

결국 핸들러 어댑터에서 컨트롤러에 등록된 함수들을 실행할텐데 그 함수들에는 @RequestMaping과, @RequestParam, @ModelAttribute같은 어노테이션 그리고 @RequestBody, HttpEntity 같은 다양한 유형을 처리해주어야 한다. 이 과정에서 이런 파라미터를 처리해주는 Argument Resolver를 이용하게 된다.

RequestMappingHandlerAdapter는 Argument Resolver를 호출해서 다양한 값(객체)을 생성한다.
## ArgumentResolver

*ArgumentResolver*가 요청에 대한 파라미터들을 처리하여 컨트롤러가 필요로 하는 다양한 파라미터 값의 객체를 생성해서 컨트롤러에 넘겨준다.

스프링은 30개가 넘는 ArgumentResolver를 기본으로 제공한다.

### 동작방식

ArgumentResolver안에 있는 supportParameter()를 호출해서 파라미터에 대한 객체를 생성할 수 있는지 여부를 확인한다. 

생성할 수 있으면 resolveArgument()를 통해 객체를 생성해서 컨트롤러에 넘겨준다.

개발자가 커스터마이징 가능하다.

## ReturnValueHandler

정식명칭은 HandlerMethodReturnValueHandler인데 줄여서 ReturnValueHandler라고 한다.

응답 값을 변환하고 처리하는 역할을 한다.

컨트롤러에서 String으로 뷰 이름을 반환해도 웹이 띄워지게 되는 것도 이 덕분이다.

-----

메시지 컨버터의 위치


![[lecture-spring-mvc-1.58.2.png]]

HTTP 메시지 컨버터를 사용하는 @RequestBody도 컨트롤러가 필요로 하는 파라미터의 값에 사용된다. @ResponseBody도 컨트롤러 반환 값을 이용한다. 따라서 이러한 유형을 처리하는 객체들 안에 있을 것이라고 유추해볼 수 있다.

**요청의 경우**
@Requestbody를 처리하는 ArgumentResolver가 있고, HttpEntity를 처리하는 ArgumentResolver가 있을 것이다. 이 ArgumentResolver 들이 HTTP 메시지 컨버터를 사용해서 필요한 객체를 생성하는 것이다.

**응답의 경우**
@ResponseBody를 처리하는 ReturnValueHandler가 있고, HttpEntity를 처리하는 ReturnValueHandler가 있을 것이다.
여기에 HTTP 메시지 컨버터를 호출해서 응답결과를 만든다.

> 참스프링 MVC는 @RequestBody @ResponseBody 가 있으면 RequestResponseBodyMethodProcessor (ArgumentResolver)를 사용하며(둘 다 합친 것), HttpEntity가 있으면 HttpEntityMethodProcessor (ArgumentResolver)를 사용한다.



## 확장

스프링은 위에서 말한 세가지를 인터페이스로 제공한다.
HttpMessageConverter
HandlerMethodArgumentResovler
HandlerReturnValueHandler

확장이 가능한데, 기능 확장은 **WebMvcConfiguer**를 상속받아서 스프링 빈으로 등록하면 된다. 기존에 구현된 것들이 많으니 실제로 자주 사용하지는 않는다.



+만약 @ResponseBody나 HttpEntity를 사용하는 경우 핸들러어댑터는 ModelAndView를 반환하지 않고 HttpServletResponse 객체에 직접 데이터를 작성하게된다.
HttpMessageConverter가 응답 메시지 본문을 작성하고 뷰리졸버가 사용되지 않는다...! 따라서 디스패처 서블릿은 ModelAndView를 반환받지 않고 뷰 관련 처리가 필요 없다고 판단하여 추가적인 뷰 렌더링 과정을 생략한다.
저번에 스터디 조사할 때 이해가 안 갔는데 드디어! 알아냈다.