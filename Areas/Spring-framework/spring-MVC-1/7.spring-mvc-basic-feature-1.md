> 강의 분량이 많아서 요청 부분만 작성

신규 프로젝트 세팅 해야한다.

# 로깅

로그를 왜 사용할까?

보통 운영 시스템에서는 _System.out.println()_ 같은 시스템 콘솔을 사용해서 정보를 출력하지 않고 로깅 라이브러리를 사용해서 로그를 출력한다.

스프링 부트 로깅 라이브러리는 기본으로 SLF4J, Logback이라는 로깅 라이브러리를 사용한다.
실무에서는 logback을 주로 사용한다.

로그 라이브러리는 Logback, Log4J, Log4J2 등 수많은 라이브러리가 있는데, 그것을 통합해서 인터페이스로 제공하는 것이 SLF4J이다.

Logback을 사용해보자.

테스트 컨트롤러를 하나 작성하겠다.

```java
package hello.springmvc.basic;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LogTestController {

    private final Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping("/log-test")
    public String logTest(){
        String name = "Log test Project by Kms";

        log.trace("trace log ={}",name);
        log.debug("debug log ={}",name);
        log.info("info log = {}",name);
        log.warn("info log = {}",name);
        log.error("error log = {}",name);


        //다른 방식. 이런식으로 사용하지 말자. 계산 로직이 먼저 실행되어서 불필요한 CPU, 메모리 사용으로 이어질 수 있다.
        log.debug("String concat log = " + name);
        return "ok";
    }
}

```

RestController

- @Controller와 달리 리턴 String이 뷰 이름이 아닌 HTTP 메시지 바디에 바로 입력해버린다. 그렇기에 실행 결과로 "ok"가 출력된 것. 

> 자동으로 html에 씌워주는 건 줄 알았는데, 메시지 바디에 넣어주는 것이었음... 지식이 늘었다!

log.debug 연산

- _log.debug("String concat log = " + name)_ 과 같이 연산이 일어나도록 작성하면 안된다.
  로그가 출력되지 않더라도 연산을 진행하기 때문에, 아무 의미없는 연산이 일어나게 된다. 따라서 `log.trace("trace log ={}",name);`와 같은 코드를 작성하는 것.


결과
결과 확인 시, info ~ / warn ~ / error ~ 로 로그가 정상출력된 것을 볼 수 있다.

로그 출력 포맷을 보면 시간 + 로그 레벨 + 프로세스 ID + 쓰레드 이름 + 클래스명 + 로그메시지 순으로 보여준다.

보통 개발 서버는 debug 수준, 운영 서버는 info 수준으로 로그를 출력한다.

여기서 debug 수준 info 수준이라고 함은 로그 레벨을 설정해줄 수 있고 출력범위를 지정해줄 수 있다.

TRACE > DEBUG > INFO > WARN > ERROR 순으로 로그 레벨이 포괄적이다.

WARN로 설정하면 ERROR와 WARN만 보여주고, INFO로 설정하면 INFO와 WARN, ERROR를 보여주는 것이다.

설정 파일을 건드려서 log 레벨을 지정해줄 수 있다.

```xml
#전체 로그 레벨 설정(기본 info
logging.level.root=info

#내가 만든 패키지와 그 하위 로그 레벨 설정.
logging.level.hello.springmvc=debug
```

밑의 경로가 더 세부적이라 우선순위는 밑의 설정을 따른다.

밑의 설정인 Debug 수준의 로그까지 보여준다.

로그를 왜 쓸까?

- 쓰레드 정보, 클래스 이름 같은 부가 정보를 볼 수 있고, 출력 모양을 조정할 수 있다.
- 로그 레벨에 따라 출력을 지정할 수 있으므로 상황에 따라 유연하게 조절 가능하다.
- 로그의 기능 중 따로 파일에 저장하는 기능도 있는데, 해당 기능을 통하여 네트워크 등 로그를 별도의 위치에 남길 수 있다. 또한 파일이 커지면 자동으로 분할 및 압축시켜버릴 수도 있다.
- 그냥 성능이 System.out보다 더 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를 사용해야 한다.

---

# 1. 요청 매핑


## 1.1 기본 매핑

기본적인 형태의 매핑 방식이다. 

저번에 작성한 양식이랑 같다.

```java
package hello.springmvc.basic.reqeustmapping;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MappingController {

    private Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping("/hello-basic")
    public String basicreq(){
        log.info("basic reqeust  kms");
        return "ok";
    }
}

```

"~/hello-basic"로 요청이 들어오면 로그로 string을 찍어주고 @RestController로 인해 웹에 ok를 뿌려주는 간단한 로직.

- 참고로 대부분의 속성을 배열[]로 제공하므로 다중 설정이 가능하다.  
    ex) "~/hello-basic , ~/hello-go"  
- 다음 두 요청은 다른 URL이지만 스프링은 같은 요청으로 매핑한다.  
    ex) "~/hello-basic", "~/hello-basic/"
    ~/hello-basic로 매핑해줌


## 1.2 HTTP 메서드 매핑

```java

     * method 특정 HTTP 메서드 요청만 허용
     * GET, HEAD, POST, PUT, PATCH, DELETE
     */
    @RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)
    public String mappingGetv1(){
        log.info("mapping-get-v1");
        return "ok";
    }
```

애노테이션 값안에 method 파라미터를 붙여서 요청을 지정 가능

즉 저 URL로 POST요청이 오면 스프링 MVC는 HTTP 405(Method Not Allowed)를 반환한다.

POST 요청을 보냈을 때 로그가 Warn로 해당 메서드는 지원하지 않는다고 로그를 찍는걸 볼수 있다.

위에 로그들은 GET요청을 보냈을 때 정상적으로 로직이 수행된 것이다.

## 1.3 HTTP 메서드 축약

```java
    /**
     * 편리한 축약 애노테이션
     * @GetMapping
     * @PostMapping
     * @PutMapping
     * @DeleteMapping
     * @PatchMapping
     */
    @GetMapping(value = "/mapping-get-v2")
    public String mappingGetv2(){
        log.info("mappingGetv2");
        return "ok";
    }
```

즉, 위처럼 _GetMapping_ 라는 애노테이션을 달아주면 _@RequestMapping_ 에 _method = RequestMethod.GET_ 을 써준거나 똑같아진다.

## 1.4 PathVariable(경로 변수)

최근 HTTP API는 리소스 경로에 식별자를 넣는 스타일을 선호한다.

- /mapping/userA (userA는 변수)
- /users/1 (1은 변수)

이렇게 말이다.

이렇게 경로에 변수가 있을때 꺼내게 해주는 애노테이션이 있다.

```java
    /**
     * PathVariable 사용.
     * @param id
     * @return
     */
    @GetMapping("/mapping/{userId}")
    public String mappingPath(@PathVariable("userId") String id){
        log.info("mapping path userId = {}",id);
        return "ok";
    }

```

@GetMapping 안에는 '{}'에 변수 값이 들어온다는 것을 알려주고 @PathVariable 속성값으로 변수를 받아올 수 있다.

> @PathVariable 의 이름과 파라미터 이름이 같으면 생략할 수 있다.
> 명시해주는 것이 좋을까? 팀마다 다르겠지만 생략하는 게 더 편할듯?
> 물론, 어노테이션 자체를 생략해줘서는 안된다.

## 1.5 PathVariable 사용 - 다중

```java
    @GetMapping("/mapping/users/{userId}/orderws/{orderId}")
    public String mappingPath(@PathVariable String userId, @PathVariable Long orderId){
        log.info("mapping path userId = {}, orderId = {}",userId,orderId);
        return "ok";
    }
```

@PathVariable 다중 사용 시, 파라미터 이름이 같으면 속성값을 생략할 수 있다는 것을 보여주기 위해 만들어진 예제제


## 1.6 특정 파라미터 조건 매핑

```java
    /**
     * 파라미터로 추가 매핑
     * parmas = "lang"
     * params ="!lang"
     * params = "lang=java"
     * params = "lang!=java"
     * params = {"lang=java","name="kms"}
     * 위와 같은 표현도 가능하다는 것.
     */
    @GetMapping(value = "/mapping-param",params = "lang=java")
    public String mappingParam(){
        log.info("mappingParam");
        return "ok";
    }
```

이런식으로 작성하면 요청값에 꼭 "lang=java"라는 특정 파라미터 값이 들어와야한다.
배열로 다수를 받는 것을 조건으로 해줄 수도 있음.

## 1.7 특정 헤더 조건 매핑

```java
    /**
     * 특정 헤더로 추가 매핑
     * headers = "mode"
     * headers = "!mode"
     * headers = "mode = debug"
     * headers = "mode != debug"
     */
    @GetMapping(value = "/\mapping-headers", headers = "mode=debug")
    public String mappingHeader(){
        log.info("mappingHeader");
        return "ok";
    }
```

특정 헤더를 조건으로 매핑시켜줄 수 있다.
헤더에 mode=debug라는 요청을 필수로 받는다.

## 1.8 미디어 타입 조건 매핑 - ContentType, consume

```java
   /**
     * Content-Type 헤더 기반 추가 매핑 Media Type
	 * 부가적으로는 아래 기능도 쓸 수 있음.
     * consumes = "application/json"
     * consumes = "!application/json"
     * consumes = "aplication/*"
     * consumes = "*\/*"
     * MediaType.APPLICATION_JSON_VALUE
     */

    @PostMapping(value = "/mapping-consume", consumes = "application/json")
    public String mappingConsumes(){
        log.info("mappingConsumes");
        return "ok";
    }
```

http 요청의 content-type 헤더 기반으로 미디어 타입 매핑한다.
맞지 않으면 415 unsopported media type 반환

## 1.9 미디어 타입 조건 매핑 Accept, produce

```java
   /**
    * Accept 헤더 기반 Media Type
    * produces = "text/html"
    * produces = "!text/html"
    * produces = "text/*"
    * produces = "*\/*"
    * produces = {"text/plain", "application/*"}
    * produces = MediaType.TEXT_PLAIN_VALUE
    * produces = "text/plain;charset=UTF-8"
    */
    @PostMapping(value = "/mapping-produce", produces = "text/html")
    public String mappingProduces() {
        log.info("mappingProduces");
        return "ok";
    }
```

consume과 비슷하다. produce는 Accept헤더를 기반으로 미디어 타입으로 매핑한다.
맞지 않으면 406 Not Acceptable을 반환한다.

### 1.9.1 Accept, Conent-Type

- Accept은 클라이언트가 선호하는 표현을 요청한다. 즉, 클라이언트 입장에서 응답을 받을때, Accept 헤더에 있는 데이터 타입이 오지 않으면 거절한다. 즉, 서버입장에서는 생성(produce)한 데이터 타입이 맞지 않으면 거절.

- Content-Type은 해당 헤더에 있는 데이터가 오지 않았을 경우 서버 입장에서 요청 거부 즉 서버는 헤더요청을 소비(consume)함.


# 2. 요청 매핑 - API 예시

회원 관리를 HTTP API로 만든다 생각하고 매핑을 어떻게 하는지 보자.
url 매핑만!!

- 회원 목록 조회 : GET /users
- 회원 등록 : POST /users
- 회원 조회 : GET /users/{userId}
- 회원 수정 : PATCH /users/{userId}
- 회원 삭제 : DELETE /users/{userId}

```java
package hello.springmvc.basic.reqeustmapping;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/mapping/users")
public class UserController {

    @GetMapping
    public String users(){
        return "get users";
    }

    @PostMapping
    public String addUsers(){
        return "post users";
    }

    @GetMapping("/{userId}")
    public String findUser(@PathVariable String userId){
        return "get userId :" + userId;
    }

    @PatchMapping("/{userId}")
    public String updateUser(@PathVariable String userId){
        return "patch userId : " + userId;
    }
    
    @DeleteMapping("/{userId}")
    public String deleteUser(@PathVariable String userId){
        return "delete userId : " + userId;
    }
}

```

Postman으로 테스트 가능

# 3. 요청 매핑 - 기본, 헤더 조회

어노테이션 기반 스프링 컨트롤러는 다양한 파라미터를 지원한다.
이번에는 HTTP 헤더를 조회하는 방법을 알아보자.

```java
package hello.springmvc.basic.reqeustmapping;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpMethod;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Locale;

@Slf4j
@RestController
public class RequestHeaderController {

    @RequestMapping("/headers")
    public String headers(HttpServletRequest request,
                          HttpServletResponse response,
                          HttpMethod httpMethod,
                          Locale locale,
                          @RequestHeader MultiValueMap<String,String> headerMap,
                          @RequestHeader("host") String host,
                          @CookieValue(value = "myCookie",required = false) String cookie){
        log.info("request = {}",request);
        log.info("response = {}",response);
        log.info("httpMethod = {}",httpMethod);
        log.info("Locale = {}",locale);
        log.info("headerMap = {}",headerMap);
        log.info("header host = {}",host);
        log.info("cookie = {}",cookie);

        return "ok";
    }
}

```

MultiValueMap을 통해 하나의 키에 여러 개의 값을 받아올 수 있다.
> MultiValueMap은 스프링 api 문서에서 찾아볼 수 있는 컬렉션이다.
> map 인터페이스를 상속 받을 때, vlaue 값을 list로 받는다.
> 하나의 key와 하나 이상의 value로 이루어진 리스트를 받는다..!
> key 값이 중복 시 같은 키에 여러 개의 value를 쑤셔넣는 체이닝 해시 같은 방식이다.

@Requestheader("host")를 통해 특정 헤더를 받아올 수도 있다.
defaultValue로 기본값 지정 가능

쿠키의 경우, @CookieValue로 가져올 수 있다. required = false


@Slf4j
다음 코드와 같이 자동으로 생성해 로그 선언해준다. 개발자는 편리하게 `log`라고 생성해주면 된다.

```java
private static final Logger log = LoggerFactory.getLogger(RequestHeaderController.class);
```


@Controller가 사용 가능한 파라미터, 응답 값 목록은 spring api docs에 나와있다.
정말 다양한 타입을 받아올 수 있다....

---

# 1. HTTP 요청 파라미터 - 쿼리파라미터, HTML FORM

클라이언트에서 서버로 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용한다.

- GET - 쿼리 파라미터
  - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
  - /url?username=kms&hegiht=178

- POST - HTML Form
  - content-type:application/x-www-form-urlencoded
  - 메시지 바디에 쿼리 파라미터 형식으로 전달함.  

- HTTP message body에 데이터를 직접 담아서 요청
  - HTTP API에 주로 사용된다. JSON, XML, TEXT
  - 데이터 형식은 주로 JSON이 사용된다.

## 1.1 GET,쿼리 파라미터로 전송.


```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {

    //기본적인 형태

    @RequestMapping("/request-param-v1")
    public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException {

        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        log.info("username={} , age={}",username,age);

        response.getWriter().write("ok");
    }
}

```


## 1.2 Post로 Form 전송

전송하기 위해 html 파일을 만들어야한다.
 `~/resources/static/basic/hello-from.html`

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<form action="/request-param-v1" method="post">
  username: <input type="text" name="username" />
  age: <input type="text" name="age" />
  <button type="submit">전송</button>
</form>
</body>
</html>
```

쿼리 파라미터와 다른 점은 이미 설명한 바 있다. (어딘가에서... 설명했었다. 이 강의가 아니더라도 구글링만 해도 나온다.)
http body에 넣어주냐, url에 노출되냐의 차이이다.

# 2. HTTP 요청 파라미터 - @RequestParam

_@RequestParam_ 애노테이션을 이용해서 요청 파라미터를 관리해보자.

가장 기본적인 형태는 다음과 같다.

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {
    @ResponseBody
    @RequestMapping("/request-param-v2")
    public String requestParamV2(
            @RequestParam("username") String memberName,
            @RequestParam("age") int memberAge) {

        log.info("username={}, age={}", memberName, memberAge);
        return "ok";
    }

```

_@ResponseBody_ 를 사용해준 이유는 @Controller 애노테이션 때문에 리턴값으로 지정한 "ok"를 논리적 뷰 이름으로 판단하지 않게끔 하기 위해서이다.
이렇게 설정하면 _@RestController_ 처럼 HTTP message body에 리턴값을 넣어버려 반환한다.

만약 HTTP 요청 파라미터 이름이 변수 이름과 같다면 _@RequestParam()_ 속성값을 생략할 수 있다.

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {
    @ResponseBody
    @RequestMapping("/request-param-v3")
    public String requestParamV3(
            @RequestParam String username,
            @RequestParam int age) {

        log.info("username={}, age={}", username, age);
        return "ok";
    }

}

```

위와 같은 상황에서도 _@RequestParam_ 을 생략할수 있다.

```java
    package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {
    @ResponseBody
    @RequestMapping("/request-param-v4")
    public String requestParamV4(String username, int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
}

```

이러한 방식은 팀원들끼리 협의가 되어있어야 한다. 너무 줄여서 헷갈릴 수 있기 때문이다. _@RequestParam_ 을 명시하여 요청 파라미터에서 데이터를 읽는다는 것을 알 수 있다.

## 2.1 파라미터 필수 여부 - requestParamRequired

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {

    @ResponseBody
    @RequestMapping("/request-param-required")
    public String requestParamRequired(
            @RequestParam(required = true) String username,
            @RequestParam(required = false) Integer age) {

        log.info("username={}, age={}", username, age);
        return "ok";
    }

}

```

_@RequestParam_ 의 속성 값으로 'required = true', 'required = false'가 있다.

만약 age와 같은 원시 타입은 값을 입력해주지 않으면 500이 나온다.
null로 설정해줘서 값이 없기 때문.
따라서 RequestParam은 Integer와 같은 래핑 클래스를 사용하는 것이 권장된다. 또는 defaultValue 사용.

**주의**
요청 파라미터로
username=&age=178
username&age=178
위의의 값을 입력 시, 200을 반환한다.
empty는 null이 아니기 때문. (위 두 요청 모두 empty로 판단함.)
아마 blank도 동일하게 판단할 것으로 보임. 정확히는 타입별로 다르다고 한다. 공백 자체도 허용 불가 시 NotBlank 어노테이션을 적용하면 된다고 함. 근데 아마 이거 쓰는 게 제일 확실하지 않을까?

### 2.1.1 기본값 적용 - requestParamDefault

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {

    @ResponseBody
    @RequestMapping("/request-param-default")
    public String requestParamDefault(
            @RequestParam(required = true, defaultValue = "guest") String username,
            @RequestParam(required = false, defaultValue = "-1") int age) {

        log.info("username={}, age={}", username, age);
        return "ok";
    }

}

```

defaultValue를 설정한 시점에서 required는 의미가 없어졌다
defaultValue는 empty도 체크해준다. (empty인지 blank까지 처리해주는 지는 강의에서 안나왔다. 빈 문자라고만 하였으니, blank도 포함하는 지는 )

요청 파라미터가 비어있다면 username에는 'guest'를 넣어주고, height에는 '-1'를 넣어준다.

## 2.2 requestParamMap


```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

@Slf4j
@Controller
public class RequestParamController {
    @ResponseBody
    @RequestMapping("/request-param-map")
    public String requestParamMap(@RequestParam Map<String, Object> paramMap) {
        log.info("username={}, age={}", paramMap.get("username"), paramMap.get("age"));
        return "ok";
    }
}

```

파라미터의 값이 1개가 확실하다면 Map 을 하지만, 그렇지 않다면 MultiValueMap 을 사용한다.

아마 이런 것은 일반적이지 않은 케이스일 듯....

# 3. HTTP 요청 파라미터 - @ModelAttribute

실제 개발을 하다보면 요청파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어줘야 한다. 보통 다음과 같이 코드를 작성할 것이다.
```java
@RequestParam String username;
@RequestParam int age;

HelloData data = new HelloData();
data.setUsername(username);
data.setAge(age);
```

스프링은 이 과정을 완전히 자동화해주는 @ModelAttribute 기능을 제공한다.

먼저 요청파라미터를 바인딩할 객체를 만든다.

```java
package hello.springmvc.basic;

import lombok.Data;

@Data
public class HelloData {
    private String username;
    private int age;
}
```

## 3.1 @Data

- 롬복에서 제공하는 애노테이션으로 @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor를 자동으로 제공한다.

@ModelAttribute를 적용하면 더 편리하게 파라미터를 받을수 있다.

```java
package hello.springmvc.basic.request;

import hello.springmvc.basic.HelloData;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

@Slf4j
@Controller
public class RequestParamController {
    @ResponseBody
    @RequestMapping("/model-attribute-v1")
    public String modelAttributeV1(@ModelAttribute HelloData helloData) {
        log.info("helloData={}", helloData);
        return "ok";
    }
}

```

보기 간편해졌다! 코드 작성 측면에서도 줄어들었으니 편하다.
@Data는 toString()도 자동으로 만들어준다. 정말 편하지 않을 수 없다!

작동 방식
HelloData 객체 생성
객체 프로퍼티를 찾는다. 해당 프로퍼티 setter를 호출해 파라미터 값을 입력(바인딩)한다.

프로퍼티?
객체에 getter, setter가 있으면 이 객체는 해당 필드의 프로퍼티를 가진다.
프로퍼티 값을 변경시 setter가 호출되고, 조회시 getter가 호출된다.

바인딩 호출
숫자가 들어가야 할 곳에 문자를 넣으면 BindException이 발생한다. 이런 바인딩 오류를 처리하는 방법은 검증 부분에서 다룬다.

@ModelAttribute도 마찬가지로, 생략 가능하다.
name도 맞춰줄 수 있다?!?!
그런데 @RequestParam도 생략할 수 있으니 혼란 발생 가능

스프링은 해당 생략 시 다음과 같은 규칙 적용
단순 타입? @RequestParam 처럼 생략 가능하다.
나머지 = @ModelAttribute (argument resolver로 지정해둔 타입 외)

---

# HTTP Request Body

## HTTP Request Message - 단순 텍스트

요청 파라미터와 다르게 HTTP 바디를 통해서 데이터가 직접 데이터로 넘어오는 경우는 @RequestParam, @ModelAttribute를 사용할 수 없다. 

가장 단순한 방법으로 텍스트를 읽는법을 알아보자.

### 1. InputStream을 사용한 방법.

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyController {

    @PostMapping("request-body-mappingV1")
    public void requestbodyV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        ServletInputStream inputStream = request.getInputStream();
        String messagebody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messagebody = {}",messagebody);

        response.getWriter().write("ok");
    }
}

```

클래스들의 이름이 너무 길다는 불편한 점 존재. 설정도 해줘야 한다.
Spring에서는 이러한 설정들을 본인들이 직접하여 개발자가 편리하게 messagebody를 다룰 수 있도록 도와준다.

### 2. InputStream, Writer를 이용한 방법.

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyController {

    @PostMapping("/request-body-mappingV2")
    public void requestbodyV2(InputStream inputStream, Writer writer) throws IOException {
        String messagebody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("v2 messagebody = {}",messagebody);

        writer.write("ok");
    }
}

```
스프링 MVC는 다음 파라미터를 지원한다.
- InputStream(Reader): HTTP 요청 메시지 바디의 내용을 직접 조회
- OutputStream(Writer): HTTP 응답 메시지의 바디에 직접 결과 출력

v1에서는 request에서 직접 꺼내서 썼다면, v2에서는 아예 꺼낸 Stream을 인자로 받아서 쓰고 있다는 점이다.

### 3. HttpEntity<> 이용한 방법.

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpEntity;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyController {

    @PostMapping("/request-body-mappingV3")
    public HttpEntity<String> requestbodyV3(HttpEntity<String> httpEntity)  {
        String messagebody = httpEntity.getBody();

        log.info("v3 messagebody = {}",messagebody);

        return new HttpEntity<>("im kms OK");
    }
}

```

스프링 MVC가 지원하는 기능이다.

- HTTPEntity<>는 HTTP Header,body를 좀 더 편히 조회할 수 있게 도와준다.
- HTTPEntity<>는 응답용으로도 사용될 수 있다.

HTTPEntity를 상속받은 객체들이 있는데, 이는 더 개발자가 요구하는 바를 더 명확하게 밝히고 기능이 강화되어있다.

메시지 바디 정보 직접 반환, 헤더 정보 포함 가능, view 조회 안함.
요청 파라미터 조회하는 기능과 관계 없음. @RequestParam 같은 친구와 관계 없다.

### 4. HttpEntity<>를 상속받은 RequestEntity, ResponseEntity객체


```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyController {
    @PostMapping("/request-body-mappingV4")
    public HttpEntity<String> requestbodyV4(RequestEntity<String> requestEntity){
        String messagebody =  requestEntity.getBody();

        log.info("v4 messagebody = {}",messagebody);

        return new ResponseEntity<String>("ok", HttpStatus.CREATED);
    }
}

```


http 상태 코드를 넣어줄 수 있다.

HttpEntity 및 상속받는 친구들은 HttpMessageContverter 기능을 이용한다.
RestController 조사하면서 알아봤던 놈인데, 적절하게 바꿔주는 역할을 함...

### 5. @ResponseBody, @RequestBody 사용

```java
package hello.springmvc.basic.request;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyController {

    @ResponseBody
    @PostMapping("/request-body-mappingV5")
    public String requestV5(@RequestBody String messagebody){
        log.info("v5 messagebody = {}", messagebody);
        return "v5 ok!!";
    }
}

```

코드가 굉장히 간결해졌다.

- _@RequestBody_

@RequestBody 를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다.

헤더 정보가 필요하다면 HttpEntity를 사용하거나 @RequestHeader를 사용하면 된다.

메시지 바디를 직접 조회하는 기능은 요청 파라미터를 조회하는 @RequestParam, @ModelAttribute와는 전혀 관계가 없다.

- 요청 파라미터 vs HTTP 메시지 바디  
요청 파라미터를 조회하는 기능: @RequestParam , @ModelAttribute  
HTTP 메시지 바디를 직접 조회하는 기능: @RequestBody  

- @ResponseBody
@ResponseBody 를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아서 전달할 수 있다.
물론 이 경우에도 view를 사용하지 않는다.

-----

## HTTP Request Message - JSON

JSON 형태를 조회하는 방법을 알아볼 것이다.

먼저 원시적인 방법을 보겠다.

### 1. Servlet방식으로 JSON 조회

```java
package hello.springmvc.basic.request;

import com.fasterxml.jackson.databind.ObjectMapper;
import hello.springmvc.basic.HelloData;
import lombok.extern.slf4j.Slf4j;
import org.apache.catalina.mapper.Mapper;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyJSONController {
    private ObjectMapper mapper = new ObjectMapper();

    @PostMapping("/request-body-json-v1")
    public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException{
        ServletInputStream inputStream = request.getInputStream();
        String messagebody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("message = {}",messagebody);
        HelloData data = mapper.readValue(messagebody,HelloData.class);
        log.info("name = {}, height = {}, weight = {}",data.getName(),data.getHeight(),data.getWeight());

        response.getWriter().write("ok");
    }

}
```

### 2. ResponseBody, RequestBody 사용.

전통적인 방식이다. mapper를 통해 데이터를 넣고 그 데이터를 출력한다. 

```java
package hello.springmvc.basic.request;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import hello.springmvc.basic.HelloData;
import lombok.extern.slf4j.Slf4j;
import org.apache.catalina.mapper.Mapper;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyJSONController {
    private ObjectMapper mapper = new ObjectMapper();

    @ResponseBody
    @PostMapping("/request-body-json-v2")
    public String requestBodyJsonV2(@RequestBody String messagebody) throws JsonProcessingException {

        log.info("message = {}", messagebody);
        HelloData data = mapper.readValue(messagebody, HelloData.class);
        log.info("name = {}, height = {}, weight = {}",data.getName(),data.getHeight(),data.getWeight());

        return "json v2 ok";
    }

}

```

리턴값을 String으로 바꾸고 메소드 앞에 _@ResponseBody_ 를달아줬다.

또한, 파라미터에는 _@RequestBody_ 를 달아줘서 body값을 직접 가져오도록 하였다.

mapper에 너무 의존적이라는 문제점이 있다.

```java
package hello.springmvc.basic.request;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import hello.springmvc.basic.HelloData;
import lombok.extern.slf4j.Slf4j;
import org.apache.catalina.mapper.Mapper;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyJSONController {
    @ResponseBody
    @PostMapping("/request-body-json-v3")
    public String requestBodyJsonV3(@RequestBody HelloData data)  {
        log.info("name = {}, height = {}, weight = {}",data.getName(),data.getHeight(),data.getWeight());

        return "json v3 ok";
    }
}

```

이처럼 _@RequestBody_ 안에 직접 만든 객체를 지정해줄 수 있다. 단, 요청으로 들어오는 JSON Key의 이름과 객체의 필드 이름이 같아야 Spring의 HTTP 메시지컨버터가 이를 찾고 매핑해준다.

주의
@RequestBody 를 생략해버리면 스프링의 규칙에 따라 _@ModelAttribute_ 가 적용된다. 즉 생략하면 HTTP 메시지 바디가 아니라 요청 파라미터로 처리해버린다.
> 요청을 일단 받았지만 모두 NULL의 형태가 들어감.

원시 타입에 대한 값 처리의 경우, @ModelAttribute가 좀 더 관대한다.
content-type의 경우, application/json인지 확인해야 한다.

### 3. HTTPEntity로 받기.

```java
package hello.springmvc.basic.request;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import hello.springmvc.basic.HelloData;
import lombok.extern.slf4j.Slf4j;
import org.apache.catalina.mapper.Mapper;
import org.springframework.http.HttpEntity;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyJSONController {
    @ResponseBody
    @PostMapping("/request-body-json-v4")
    public String requestBodyJsonV4(HttpEntity<HelloData> data)  {
        HelloData body = data.getBody();
        log.info("name = {}, height = {}, weight = {}",body.getName(),body.getHeight(),body.getWeight());

        return "json v4 ok";
    }
}

```


```java
package hello.springmvc.basic.request;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import hello.springmvc.basic.HelloData;
import lombok.extern.slf4j.Slf4j;
import org.apache.catalina.mapper.Mapper;
import org.springframework.http.HttpEntity;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyJSONController {
    @ResponseBody
    @PostMapping("/request-body-json-v5")
    public HelloData requestBodyJsonV5(@RequestBody HelloData data)  {
        log.info("name = {}, height = {}, weight = {}",data.getName(),data.getHeight(),data.getWeight());
        return data;
    }
}

```

get body를 생략하고 싶다면, 이렇게 리턴값에 클래스명과 리턴값으로 그냥 넘겨버리면 된다.

- @RequestBody 요청  
JSON 요청 -> HTTP 메시지 컨버터 -> 객체
- @ResponseBody 응답  
객체 -> HTTP 메시지 컨버터 -> JSON 응답

즉, HttpMessageConverter가 중간에서 원하는 데이터의 형태로 바꿔주는 역할을 한다.
> 핸들러 매핑 후에 작동하던 것으로 기억함.

요청을 보낼때는 Content-Type이 application/json 이어야 하고, 응답을 보낼 때에는 Accept가 application/json이어야 한다.!!!


https://github.com/kkminseok/4_kyh_spring_mvc_note/blob/main/6_Spring_Basic_Option/1_Logging.md
참고함++