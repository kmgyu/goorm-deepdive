이번에는 mvc 프레임워크를 만드는 실습을 하게 될 것임.

프론트 컨트롤러?
공통 관심사를 모아서 연결해주는 컨트롤러를 추가하는 것이다.

특징
서블릿 하나로 클라이언트 요청 받음
프론트 컨트롤러가 요청에 맞는 컨트롤러 찾아서 호출
입구를 하나로
공통 처리 가능
프론트 컨트롤러 제외 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨.


프론트 컨트롤러 - v1

프론트 컨트롤러가 매핑 정보에서 컨트롤러 조회
컨트롤러 호출, jsp를 컨트롤러가 호출해서 포워딩함.

실제 개발에서는 절대 경로 쓰는 경우가 많다.
(상대 경로 실수하기 쉬워서... 절대 경로 쓰는 게 좋음)
그래도 상대 경로 쓰는 것이 나은 경우가 있다. 패턴이 비슷하거나 할 때는 상대 경로를 써도 되는 상황임.


뷰 분리 - v2
viewPath부터 디스패처로 포워딩 하는 것에 중복이 있었다.
컨트롤러에서 직접 jsp 포워딩을 하는 것 대신 프론트컨트롤러가 MyView를 호출 해 jsp 포워딩하도록 만든다.


모델 추가 - v3
request, response 정보는 당장 필요한 정보가 아니다.
우리가 구현하는 컨트롤러가 서블릿 기술을 전혀 사용하지 않도록 한다.뷰이름에 중복이 있는 것 확인 가능.
컨트롤러는 뷰의 논리 이름을 반환하고, 실제 물리 위치 이름은 프론트 컨트롤러에서 처리하도록 단순화
이렇게 해두면 뷰의 폴더 위치가 함께 이동해서 프론트 컨트롤러만 고치면 됨!

점점 스프링 mvc와 유사하게 되어가고 있다

ViewResolver가 이 논리 이름 기반으로 뷰를 찾아준다...
스프링 mvc도 같은 역할을? 하는 것으로 알고 있다.

단순하고 실용적인 컨트롤러 v4
아키텍처도 중요하지만 실제 개발하는 개발자가 단순하고 편리하게 사용할 수 있어야 한다.
더 간단한 버전으로 만들어보자!

프론트 컨트롤러에서 모델 추가하고 프론트컨트롤러서블릿은 이전버전과 거의 동일
개발자 입장에서는 뷰의 논리 이름을 넣게 되면 매번 뷰를 생성할 필요가 없으니 편리해진다.

어댑터를 v5에서 설명
항상 모양이 정해졌는데 v4말고 v1을 쓰고 싶다 같은 것은 지금 구조에선 안됨.
프론트 컨트롤러의 컨트롤러 맵에서 인터페이스 타입이 정해져서?
이 문제를 해결해 볼 것임.


유연한 컨트롤러 - v5
어떤 개발자는 v3, 어떤 개발자는 v4 방식의 컨트롤러를 하나의 프로젝트에서 사용하고 싶은 상황
나는 상속을 생각하고 있었는데, 어댑터 패턴이라는 것이 있다.
완전히 다른 인터페이스이기 때문에 호환이 불가능한 형태임. 상속으로도 한계가 있는듯?
그래서 어댑터라는 걸 사용해야 한다고 함...
핸들러 매핑 정보 조회, 핸들러 처리 가능한 핸들러 어댑터 조회
이제 우리가 아는 디스패처 서블릿의 형태가 조금씩 나오는 것 같다!
핸들러 어댑터 : 중간에 어댑터 역할을 하는 어댑터. 다양한 종류의 컨트롤러를 호출 가능
핸들러 : 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경. 어댑터가 있기 때문에 컨트롤러 개념 뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문.

제너릭을 Object로 해서 핸들러 매핑할 때 그냥 다 넣어줌
요청에 맞춰서 타입 캐스팅 해주는 거 같음
instanceof을 여기서 쓴다. 우왕

1부/2부로 나뉨. v3,v4 각각 1부랑 2부...

2부에서는 핸들러 매핑하는 메인 로직은 손을 안댔다.
핸들링만 만들어줌.
이 핸들러 매핑하는 것도 외부에서 주입하게 바꿀 수 있는데 너무 복잡해지니까 강의에서는 생략한다고 함!!!


실행로직은 pdf 참고...


스프링은 어노테이션 지원 이전에도 인터페이스 구현과 분리해 설계하는 것이 잘되어있었음.
