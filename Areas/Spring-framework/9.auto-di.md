# 다양한 의존 관계 주입 방법
크게 4가지 방법

- 생성자 주입
- 수정자 주입(setter 주입)
- 필드 주입
- 일반 메서드 주입

## 생성자 주입
생성자에 @Autowired 어노테이션을 넣게되면 생성자 호출 시 스프링 컨테이너에서 스프링 빈을 주입해준다.
>  서비스 커지면 빈 관리 어려워져서 안쓴다고 했던 거 같은데?

제약이 분명한 것은 좋은 설계.
외부에서 수정할 수 있는 방법이 없다. (불변 객체)
필수 의존 관계만 사용한다.
- 생성자에 들어오는 객체는 무조건 값이 있어야 함.
- null 허용 명시안하면 왠만하면 생성자에는 값을 채워 넣는 것이 관례


생성자가 1개만 있으면 @AutoWired를 생략해도 된다.
 > 지금까지 명시안하면 AutoWired 안쓰는 줄 알았는데... 나도 모르게 쓰고 있었다!!!

## 수정자 주입
가끔씩 쓰는데 애매하다고 함.
getter나 setter에 @Autowired하면 이것도 주입이 된다.
getter, setter 자체는 자바빈 프로퍼티 규약?이라는 관례가 있다고 한다.

자바빈 프로퍼티 규약?
필드 값 직접 변경하지 않고 getXXX, setXXX와 같이 메서드 통해서 값 읽거나 수정하는 규칙.
자바 빈 프로퍼티라고 검색하면 쭉 나옴.

선택, 변경 가능성 있는 의존자에 사용.
스프링빈에 등록되지 않을 수가 있다. 이럴 때 선택적으로 의존 관계 주입을 한다. (???)

required = false 옵션을 통해 선택적 적용이 가능하다.

> `@Autowired` 기본 동작은 주입할 대상이 없으면 오류가 발생함. 주입 대상이 없어도 동작하게 하려면 `@Autowired(required=false)`로 지정하면 된다!

## 필드 주입
필드에다가 값을 넣어버림
```java
@Autowired private class objectName;
```
놀라울 정도로 간편하다!
> Config에서 설정해둔 게 있으면 오류가 조금씩 나는 것 같다.

특징
- 코드가 간결하다. 대신 외부에서 변경 불가능해서 테스트하기 힘들다.
  ex) 더미데이터 넘기는 멤버리포지토리로 바꾸고 싶은데 Autowired 되서 더미로 바꾸기가 힘들다. 유연하지 않음.
- DI 프레임워크가 없으면 아무것도 할 수 없다.
- 사용하지 않는 것이 좋다.
	- 애플리케이션 실제 코드와 관계없는 테스트 코드
	  갖다 쓰지 않으니까 테스트 코드에서는 해도 됨.
	- 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용
	  AppConfig에서 Bean 관리할 때 Autowired 사용하던데 빈인젝션? warning 메시지 뜬다.

> 쓰지마라는 Autowired가 이거였는데 기억이 왜곡된 듯...?

일반 메서드 주입
일반 메서드 통해 주입 가능
수정자 주입할 때랑 비슷한 타이밍에 들어온다. 사실상 똑같은 방식이라 볼 수 있음. 둘다 메서드라...
수정자랑 
특징
- 일반적으로 사용 안함.
- 한번에 여러 필드 주입 가능하다.

# 옵션 처리

@Autowired만 사용하면 자동 주입 대상 없으면 오류 발생한다.

자동 주입 대상을 옵션으로 처리하는 방법은 다음과 같다.
- @Autowired(required=false) : 주입 대상 없으면 수정자 메서드 자체가 호출 안됨.
- org.springframework.lang.@Nullable : 자동 주입할 대상 없으면 null 입력
- Optional<> : 자동 주입할 대상이 없으면 Optional.empty 입력 된다.


@Nullable
```java
@Autowired
public void setBean(@Nullable Member member)
```

Optional<>
```java
@Autowired
public void setBean(Optional<Member> member)
```
Optional이 이렇게 쓰는 거였구나!
엔티티 뽑아올 때 Optional에 담아와서 isEmpty로 내용물 확인할때만 썼던 거 같은데 지식이 늘었다

# 생성자 주입을 선택해라
과거에는 수정자 / 필드 주입 많이 사용.
최근에는 스프링 포함 DI 프레임워크 대부분이 생성자 주입 권장함

### 불변
의존관계를 애플리케이션 종료까지 변경할 일이 없다.
오히려 애플리케이션 종료전까지 대부분의 의존관계는 변하면 안된다.
수정자의 경우 setXXX를 public으로 열어놓게 되고, 누군가 호출해버려서 실수로 바꿀수도 있는 문제 발생함.
변경할 수 있는 메서드를 열어 두는 것 자체가 좋은 선택이 아님.

### 누락
프레임워크 없이 순수 자바 코드 단위 테스트하는 경우가 정말 많다.
가짜 객체를 주입시켜서 쓸 수도 있는데, 이걸 누락할 수 있다.
의존 관계를 알기 쉽지 않아 문제점 찾기도 어려움.
생성자로 하게되면 컴파일 오류 떠서 바로 인지할 수 있음.
목라이브러리 등 이용해서 가짜 객체 임의로 넣어주고 쉽게 진행이 가능함.

생성자 사용 시 생성자에서만 값 생성 가능

파이널 키워드 넣기 가능. (생성자 만들면서 코드 누락 시 오류 메시지 출력)
생성자만 가능하다!

컴파일 오류는 세상에서 가장 빠르고 좋은 오류


정리
- 생성자 주입 방식 선택 이유는 여러가지. 프레임 워크에 의존하지 않고 순수한 자바 언어 특징을 잘 살리는 방법이기도 함.
- 기본적으로 생성자 주입, 옵션으로 수정자 주입 방식 넣어주면 됨
- 항상 생성자 주입 선택해라. 필드 주입은 사용하지 않는게 좋다.


# 롬복과 최신 트렌드
개발해보면 대부분이 다 불변이다.
그래서 생성자에 final 키워드 만들게 된다.

생성자를 만들기 귀찮아진다.
필드 주입처럼 편리하게 만드는 방법? 없나?

Enable Annotaion Processor를 사용해야 인텔리제이에서 롬복 사용 가능.
build.gradle에도 annotation processor 세팅해줘야 한다.

@Getter, @Setter 등으로 수정자 주입 가능.
생성자 등 넣을 수 있는 게 굉장히 많다.
@ToString도 가능함.

@RequiredArgsConstructor
final? 필수.
필수 매개변수 생성자 만들어줌.
생성자도 있고 파이널도 있다. 필드 주입보다 좋음

의존관계 추가시 편해진다.
새 필드 추가 등의 케이스에서..


정리
최근에는 생성자 1개 두고 @Autowired 생략하는 방법을 주로 사용한다.
여기에 lombok 라이브러리 @RequiredArgsConstructor 까지 함께 사용하면 기능은 제공하면서 코드는 깔끔하게 사용 가능하다.


# 조회 빈이 2개 이상 문제