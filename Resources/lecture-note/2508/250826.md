인텔리제이를 이용해서 쿼리 실습을 한다...?


100만 개 데이터로 인덱스 튜닝하면 속도 어떻게 바뀌는 지 보여주심

210ms에서 93ms로 줄어들었다.

인텔리제이의 실행계획에서 풀스캔인지, 인덱스스캔인지 등도 볼 수 있다.



DB 튜닝해서 운용해야하는 그런 회사를 간다면 이미 운용하는 사람이 있을 확률이 큼

비즈니스 성격에 따라 다르긴 한데 일반적인 회사로 들어간다면 기본적인 것이 준비가 되어있다면 이런 개념을 가져가는 것이 좋다.

어디부터 필요한 지식인지...?

### **주요 용어 이해**

| 용어                 | 의미               | 좋음/나쁨     |
| ------------------ | ---------------- | --------- |
| **Table Scan**     | 테이블 전체를 순차적으로 읽기 | ⚠️ 느림     |
| **Index Scan**     | 인덱스를 사용해서 읽기     | ✅ 빠름      |
| **Nested Loop**    | 중첩 반복으로 조인       | 👍 소량 데이터 |
| **Hash Join**      | 해시 테이블로 조인       | 👍 대량 데이터 |
| **Sort**           | 정렬 작업            | ⚠️ 메모리 사용 |
| **Using filesort** | 디스크에서 정렬         | ❌ 매우 느림   |
## **실행계획 읽는 법**

### **주요 컬럼 이해**

| 컬럼       | 의미                | 좋음/나쁨   |
| -------- | ----------------- | ------- |
| **type** | 테이블 접근 방식         |         |
| - const  | Primary Key로 단일 행 | ✅ 최고    |
| - eq_ref | UNIQUE 인덱스로 단일 행  | ✅ 매우 좋음 |
| - ref    | 인덱스로 여러 행         | ✅ 좋음    |
| - range  | 인덱스 범위 스캔         | 👍 괜찮음  |
| - ALL    | 전체 테이블 스캔         | ❌ 나쁨    |

| **Extra**       | 의미          | 좋음/나쁨 |
| --------------- | ----------- | ----- |
| Using index     | 인덱스만으로 해결   | ✅ 최고  |
| Using where     | WHERE 조건 적용 | 👍 보통 |
| Using filesort  | 디스크에서 정렬    | ⚠️ 주의 |
| Using temporary | 임시 테이블 생성   | ❌ 나쁨  |

## 실무에서 자주 마주치는 성능 문제들
### **문제 1: WHERE 절에 함수 사용**

**❌ 나쁜 예시:**

```sql
-- 함수 사용으로 인한 인덱스 무력화
SELECT * FROM orders WHERE YEAR(order_date) = 2024;
-- 실행계획: type: ALL (전체 스캔)
```

**✅ 좋은 예시:**

```sql
-- 범위 조건으로 변경하여 인덱스 활용
SELECT * FROM orders 
WHERE order_date >= '2024-01-01' 
  AND order_date < '2025-01-01';
-- 실행계획: type: range (인덱스 활용)
```

SARGable 하지 않음.

### **문제 2: LIKE 패턴과 인덱스**

**LIKE와 인덱스의 관계:**

```sql
-- ❌ 중간 매칭: 전체 스캔 필요
WHERE phone LIKE '%1234%'
-- 실행계획: type: ALL, rows: 1,000,000

-- ✅ 앞부분 매칭: 인덱스 활용 가능
WHERE phone LIKE '010-1234%'
-- 실행계획: type: range, rows: 100 정도
```

**이유:** 인덱스는 앞글자부터 정렬되어 있어서, 중간 글자로는 찾을 수 없음

**현실적인 접근:**

```sql
-- 게시판 검색은 어쩔 수 없이 중간 매칭 필요
SELECT * FROM board WHERE title LIKE '%검색어%';
-- 이건 정상이고 받아들여야 함!

-- 하지만 불필요한 함수는 피하기
❌ WHERE UPPER(title) LIKE '%검색어%'    -- 더 느려짐
✅ WHERE title LIKE '%검색어%'           -- 단순하게
```

### **문제 3: 영문 검색의 대소문자 문제**

**먼저 현재 DB 설정 확인:**

```sql
-- 1. 데이터베이스 기본 collation 확인
SHOW VARIABLES LIKE 'collation_database';

-- 2. 기존 테이블의 collation 확인
SHOW CREATE TABLE your_table_name;

-- 결과 해석:
-- utf8mb4_general_ci    → 대소문자 구분 안함 (이미 해결됨)
-- utf8mb4_bin          → 대소문자 구분함 (문제 발생 가능)
```

**현재 설정이 대소문자를 구분한다면:**

```sql
-- 1. 강제로 대소문자 구분하는 테이블 생성
CREATE TABLE test_board (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) COLLATE utf8mb4_bin,  -- 대소문자 구분
    content TEXT
);

-- 2. 다양한 대소문자로 데이터 삽입
INSERT INTO test_board (title, content) VALUES 
('Hello World', '첫 번째 게시글입니다.'),
('HELLO PROGRAMMING', '두 번째 게시글입니다.'),
('hello database', '세 번째 게시글입니다.');

-- 3. 검색 테스트 (대소문자 구분됨)
SELECT * FROM test_board WHERE title LIKE '%hello%';
-- 결과: 'hello database'만 나옴

-- 4. Collation 변경
ALTER TABLE test_board MODIFY title VARCHAR(200) COLLATE utf8mb4_general_ci;

-- 5. 다시 검색 (이제 대소문자 구분 안됨!)
SELECT * FROM test_board WHERE title LIKE '%hello%';
-- 결과: 3개 모두 나옴!
```

### **문제 4: ORDER BY 최적화**

```sql
-- ❌ 인덱스 없는 컬럼으로 정렬
EXPLAIN SELECT * FROM test_member ORDER BY name;
-- Extra: Using filesort (디스크에서 정렬)

-- ✅ Primary Key로 정렬
EXPLAIN SELECT * FROM test_member ORDER BY id;
-- Extra: 정렬 작업 없음 (이미 정렬되어 있음)
```

**이유:**

- **id**는 Primary Key라서 자동으로 정렬된 인덱스 존재
- **name**은 인덱스가 없으면 임시 정렬 작업 필요

## 옛날 책에서 본 WHERE 조건 순서, 정말 중요할까?

확률적으로 봤을 때, 남녀는 1:1이다.
10대~80대는 몰루?
나이대는 전체 데이터를 8개로 나눌 것이다. 그렇다면 age부터 가야한다.
더 잘게 쪼개지는 것을 먼저 select 하는 것이 스캔할 시의 비용이 경제적으로 든다! (그래서 옛날은 이런 게 팁이었다고 함. 실제 데이터의 selectivity를 가지고 쿼리를 구성하는 게 이슈였다...)

요즘은 똑똑해져서 현재는 알아서 최적화해줌.

복합 인덱스

개별 인덱스는 DBMS가 알아서 하지만, 복합 인덱스는 개발자가 순서 결정해야 한다.

**개별 인덱스: DBMS가 알아서**

```sql
CREATE INDEX idx_name ON members(name);
CREATE INDEX idx_age ON members(age); 
CREATE INDEX idx_city ON members(city);

-- 조건 순서 상관없음 - MySQL이 알아서 최적화
WHERE city = '서울' AND age = 25 AND name LIKE '김%'
WHERE age = 25 AND name LIKE '김%' AND city = '서울'
-- → MySQL: "name LIKE가 가장 선택적이니까 이걸 먼저 쓸게!"
```

**복합 인덱스: 개발자가 순서 결정해야 함**

```sql
-- 순서가 매우 중요!
CREATE INDEX idx_name_age ON members(name, age);    -- name 먼저
CREATE INDEX idx_age_name ON members(age, name);    -- age 먼저

-- 서로 다른 성능!
WHERE name LIKE '김%' AND age = 25;  -- 첫 번째 인덱스에 유리
WHERE age = 25 AND name LIKE '김%';  -- 여전히 첫 번째 인덱스에 유리 (순서 무관)
```

### **복합 인덱스의 동작 원리**

**인덱스 내부 구조:**

```sql
CREATE INDEX idx_city_age ON members(city, age);

-- 인덱스 내부 정렬 순서:
('부산', 20), ('부산', 21), ('부산', 22), ..., ('부산', 80),
('대구', 20), ('대구', 21), ('대구', 22), ..., ('대구', 80),  
('서울', 20), ('서울', 21), ('서울', 22), ..., ('서울', 80)
```

**효율적인 사용:**

```sql
-- ✅ 앞쪽 컬럼부터 사용 (효율적)
WHERE city = '서울'                     -- 첫 번째 컬럼만: OK
WHERE city = '서울' AND age = 25        -- 둘 다: 매우 효율적
WHERE city = '서울' AND age > 25        -- 둘 다: 효율적

-- ❌ 뒤쪽 컬럼만 사용 (비효율적)  
WHERE age = 25                          -- 두 번째 컬럼만: 인덱스 효과 제한적
```

### **복합 인덱스 설계 원칙**

**선택도(selectivity) 높은 순서대로:**

```sql
-- ❌ 잘못된 순서
CREATE INDEX idx_status_created ON members(status, created_date);
--                                         ^^^^^^  ^^^^^^^^^^^^
--                                       선택도 낮음  선택도 높음
-- status = 'ACTIVE' (95%) → 거의 안 걸러짐

-- ✅ 올바른 순서
CREATE INDEX idx_created_status ON members(created_date, status);
--                                          ^^^^^^^^^^^^  ^^^^^^
--                                        선택도 높음    선택도 낮음
-- created_date >= '2024-01-01' → 90% 걸러짐 → status 조건으로 추가 필터링
```


배포 전 스트레스 테스트 시 인덱스를 추가해줬더니 속도가 전혀 달라진 경험이 있다고 하심.

## 🎓 **고급 주제**

### **1. Cardinality와 선택도**

**개념:**

```sql
-- 카디널리티: 값의 다양성
-- 예시 테이블: 회원 100만 명
members:
- user_id: 1, 2, 3, ... 1000000     → Cardinality: 1,000,000 (높음)
- gender: M, F                      → Cardinality: 2 (낮음)
- age: 20, 21, 22, ... 80          → Cardinality: 61 (중간)
- city: 서울, 부산, 대구, 인천, 광주  → Cardinality: 5 (낮음)
```

**확인 방법:**

```sql
SHOW INDEX FROM test_member;  -- Cardinality 컬럼 확인

-- 실제 분포 확인
SELECT 
    COUNT(DISTINCT phone) as phone_cardinality,
    COUNT(DISTINCT city) as city_cardinality,
    COUNT(*) as total_rows
FROM test_member;
```

### **2. "거의 모든 회원이 ACTIVE" 문제**

**문제 상황:**

```sql
-- 현실적인 데이터 분포
SELECT status, COUNT(*) FROM members GROUP BY status;
-- ACTIVE: 950,000명 (95%)
-- INACTIVE: 30,000명 (3%) 
-- DELETED: 20,000명 (2%)

-- 이 쿼리는 인덱스 있어도 느림
SELECT * FROM members WHERE status = 'ACTIVE'; -- 95% 대상
```

**해결 방법들:**

**역방향 접근:**

```sql
-- ACTIVE 대신 소수 그룹을 타겟팅
✅ SELECT * FROM members WHERE status != 'ACTIVE';    -- 5% 대상 (빠름)
✅ SELECT * FROM members WHERE status IN ('INACTIVE', 'DELETED'); -- 5% 대상
```

**복합 조건 활용:**

```sql
-- 다른 조건과 조합해서 선택도 높이기
SELECT * FROM members 
WHERE status = 'ACTIVE' 
  AND created_date >= '2024-01-01'  -- 추가 조건으로 범위 축소
  LIMIT 100;                        -- 결과 수 제한
```

### **3. 실행계획 힌트 (최후의 수단)**

```sql
-- 강제로 특정 인덱스 사용
SELECT /*+ INDEX(m idx_member_name) */ *
FROM member m
WHERE name = '홍길동';

-- 조인 순서 강제
SELECT /*+ STRAIGHT_JOIN */ *
FROM small_table s
JOIN big_table b ON s.id = b.small_id;
```

**주의:** 힌트는 DBMS의 자동 최적화를 무시하므로 신중하게 사용

### **4. 통계 정보 관리**

```sql
-- 통계 정보 갱신 (주기적으로 실행 권장)
ANALYZE TABLE test_member;

-- 실행계획 캐시 초기화 (성능 문제 시)
FLUSH QUERY CACHE;
```

주기적으로 통계 정보를 관리해서 최적화를 시켜줘야 한다?
엣



## 🚨 **자주 하는 실수들**

### **실수 1: 인덱스만 만들면 된다고 생각**

```sql
-- 인덱스가 있어도 이런 쿼리는 느림
WHERE UPPER(indexed_column) = 'VALUE'  -- 함수 때문에 인덱스 무력화
WHERE indexed_column LIKE '%value%'    -- 중간 매칭은 인덱스 못 씀
```
where에 함수 넣으면 진짜 큰일난다?

### **실수 2: SELECT * 남용**

```sql
-- 필요한 것만 조회하는 습관
❌ SELECT * FROM member JOIN orders ...
✅ SELECT m.name, o.order_date FROM member m JOIN orders o ...
```

### **실수 3: 실행계획을 안 보고 추측**

```sql
-- "이 쿼리는 빠를 거야"라고 추측하지 말고
-- 반드시 실행계획으로 확인하기
EXPLAIN SELECT ...
```



sm 유지보수를 많이 안해서 실제 DB의 유의미한 변화를 겪지는 못했었다.
where 조건에 대한 순서 같은 거?

예전에는 stored proxy 같은 것을 사용하고 그랬다? 요즘은 그렇지 않다고 한다.
요즘은 postgreSQL이 유행이다. dbms의 특징을 공부하는 게 더 좋을 수도 있다...


---

DB 기본 용어
DB, DBMS, RDBMS
스키마, 테이블, 행/열, 데이터 타입



정규화
BCNF를 생략하셨다. 아이에에에
설명도 3정규화까지만 한다. BCNF 어디갔는데ㅔㅔ

1NF
반복그룹

2NF
부분 함수 종속

3NF
이행 함수 종속

BCNF
후보키가 아닌 결정자 제거


반정규화(=비정규화)
조인하기 힘드니 그냥 테이블 컬럼에다 사용자 이름 박아넣는다던가.. 하는 테이블있다
원칙적으로는 안됨.

이름 수정하면 해당 테이블에서도 수정해야 되기 때문.
~~아하! 그럼 update 권한을 뺏으면 되겠구나!~~

그러나! 그 시점의 스냅샷을 가져간다면? 그런 개념이라면 조금 달라진다.

오늘의 시세를 기록한다.
회원이 그 당시의 상품을 구매한다면, 어떤 제품인지와 수량만 기록 시 구매 시점 가격을 기록하지 못한다.
도메인이 뭐냐에 따라 테이블에 넣을 수도 있고, 아닐 수도 있고~


Join을 줄이기 위해 사용하는 기법은 아님.
비정규화 할 정도로 문제가 있을 지는 잘 몰루?
미리 계산해서 넣어주면 빼낼 때마다 계산 안해도됨?
배치 처리를 이용해 테이블 채워넣기?


리버스 엔지니어링 기능을 인텔리제이에서도 지원하는 듯!
진짜 없는게 뭐냐 쥐엔장!!!
인텔리제이에서도 ERD를 그려줄 수 있다.



오늘 과제?
모델링 step01, 02를 보고 논리 ERD, 물리 ERD 그리는 게 오늘 실습.
툴은 알아서 사용할 것.
더 하고 싶은 사람은 시나리오 둘 중에 하나를 추가로 하라.


다음 예정
MyBatis를 이용해 DB 모델링을 구조화해주는 것이 있다?
DB도 버전관리가 필요함. flyweight라는 버전관리툴을 통해 관리한다.
