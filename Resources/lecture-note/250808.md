
팩토리, 싱글톤, 옵저버, 빌더 패턴

옵저버의 경우 해싱 쪽 좀 생각해볼 필요가 있다?

팩토리 패턴은 우리가 만들 일은 없으니 예제코드는 최대한 간단하게 만들어졌다.

헤드퍼스트 디자인 패턴
몬가 거창한 거라고 생각하면 망한다. 이런 불편함이 있었고 그래서 생겨남 이라고 생각해야 됨.

스프링 프레임워크? 실제 적용 사례

리팩토링 - 기존 코드를 패턴 활용해 개선

bad smell 을 어느정도 잡아주는 툴이 있다.
bad smell은 뭐임. 클래스에 카멜케이스 쓰면 파스칼 쓰라고 하는 건가.

클린 아키텍처 - 더 큰 규모 설계 패턴

대부분의 개념들이 문제점 생겨서 해결했다! 5부 완! 로 끝나는 게 대부분이다.

익명클래스
한번쓰고 버릴때 익명함수를 사용한다.
원래 익명클래스로 구현, java 8부터는 람다식으로 훨씬 간단하게 작성

모던 자바
자바 8 이전 개발 생태계에서 자바가 점점 인기가 떨어짐
파이썬, node.js 등장, 스칼라, Go 등장, 리액트 개발 등...
aws 람다도 파이썬, node를 먼저 지원함.
페이스북도 php - hiphop - hhvm으로 자바 대신 자체 솔루션 구축

자바의 장황함이 생산성을 저해, 자바가 다른 언어보다 더 많은 코드 필요 등 불편함 호소

함수형 프로그래밍의 역사?
알론저 처치가 람다 계산법을 발표, 컴퓨터 과학 기초 마련

최초의 함수형 언어 Lisp 등장
Haskell (1990 표준화)
ML, Scheme 등의 발전

2005년경 멀티코어 시대 도래
**Intel의 방향 전환:**

- **2005년 이전**: CPU 속도 증가에 집중 (클록 속도 경쟁)
- **2005년 이후**: 멀티코어로 방향 전환 (듀얼코어, 쿼드코어)

**개발자들의 새로운 고민:**

```java
// 기존 방식: 단일 스레드로 처리
for (int i = 0; i < 1000000; i++) {
    processData(data[i]);  // 순차적 처리
}

// 멀티코어 시대: 병렬 처리 필요
// 하지만 어떻게? 🤔
```

#### 💡 **함수형 프로그래밍의 해답**

**불변성(Immutability)의 중요성:**

```java
// 문제가 되는 코드 (공유 상태)
class Counter {
    private int count = 0;
    
    public void increment() {
        count++;  // 여러 스레드에서 동시 접근하면 문제!
    }
}

// 함수형 해결책 (불변 객체)
class ImmutableCounter {
    private final int count;
    
    public ImmutableCounter(int count) {
        this.count = count;
    }
    
    public ImmutableCounter increment() {
        return new ImmutableCounter(count + 1);  // 새 객체 반환
    }
}
```

**순수 함수(Pure Function)의 장점:**

```java
// 순수 함수: 외부 상태에 의존하지 않음
public static int add(int a, int b) {
    return a + b;  // 같은 입력 → 항상 같은 출력
}

// 병렬 처리 시 안전함!
// 여러 스레드에서 동시에 호출해도 문제없음
```

스칼라 등장 (2003년)

트위터의 스칼라 도입

~~

자바8! 람다식 등장!
업계 전반 변화!

C# 람다식 문법 개선, 파이썬 3.5 타입힌트 추가, 코틀린 JVM에서 더 간결한 문법 제공...

---
람다식!

람다식 남용 시 가독성 저하

---

모-던 자바

record? DTO 보일러플레이트 해결
보일러플레이트가 웨? 문제임? (진짜 모름)
애초에 보일러 플레이트가 뭐냐. 아직도 잘 몰루겠는데숭...

Stream API
for문과 if 문 많아지는 걸 방지하는 문법

#### 1️⃣ **조건 필터링 + 데이터 변환**
**기존 방식**
```java
// 김씨 성을 가진 사람들을 대문자로 변환
List<String> result = new ArrayList<>();
for (String name : names) {
    if (name.startsWith("김")) {
        result.add(name.toUpperCase());
    }
}
```

**모던 방식 (Stream)**
```java
List<String> result = names.stream()
    .filter(name -> name.startsWith("김"))  // 1. 김씨만 걸러내기
    .map(String::toUpperCase)              // 2. 대문자로 변환
    .collect(Collectors.toList());         // 3. 리스트로 수집
```

Optional
NullPointerException을 보다 안전하게...
null 체크 지옥을 방지하기 위해 만들어짐

이건 null일수도 있고 아닐 수도 있다는 걸 타입 수준에서 강제시킨다.
그래서 이게 뭐가좋냐?
몰라레후.
메서드가 반환할 때 이거 사실 null일 수도 있음ㅋ 라는 걸 타입 수준에서 알려준다는 것이다!
A-HA!!!!!!


**기존 방식 (null 체크 지옥)**
```java
public String getUserName(Long id) {
    User user = userRepository.findById(id);
    if (user != null) {
        String name = user.getName();
        if (name != null) {
            return name;
        }
    }
    return "Unknown";
}
```

**모던 방식**
```java
public String getUserName(Long id) {
    return userRepository.findById(id)
        .map(User::getName)
        .orElse("Unknown");
}
```



타입 추론 var
타입명이 너무 길면 가독성을 해쳐서 컴파일러가 타입을 알아서 추론하게 만든다.

복잡한 제네릭 타입 선언, 메서드 내부 지역변수, 반복문에서 심플하게 쓴다.

**기존 방식 (타입명 중복)**
```java
Map<String, List<Integer>> scoreMap = new HashMap<String, List<Integer>>();
List<String> nameList = new ArrayList<String>();
```

**모던 방식**
```java
var scoreMap = new HashMap<String, List<Integer>>();
var nameList = new ArrayList<String>();
```

레코드
DTO / VO 클래스 만들 때 getter, setter, equals, toString 매번 정의해주는 거 번거롭다!!!!
불변성은 덤이다.

**기존 방식 (보일러플레이트 코드)**
```java
public class User {
    private final String name;
    private final int age;
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    
    @Override
    public boolean equals(Object o) {
        // 길고 복잡한 equals 구현...
    }
    
    @Override
    public int hashCode() {
        // hashCode 구현...
    }
    
    @Override
    public String toString() {
        return "User{name='" + name + "', age=" + age + "}";
    }
}
```

**모던 방식**
```java
public record User(String name, int age) {}
```

Advanced switch

기존 switch? break 빼먹으면 버그. 값 리턴하려면 복잡함.


**기존 방식**
```java
String result;
switch (grade) {
    case "A":
        result = "우수";
        break;
    case "B":
        result = "보통";
        break;
    case "C":
        result = "부족";
        break;
    default:
        result = "등급없음";
}
```

**모던 방식**
```java
String result = switch (grade) {
    case "A" -> "우수";
    case "B" -> "보통";
    case "C" -> "부족";
    default -> "등급없음";
};
```


실습 미쑌 있다.


더 깊이 파기
### 🚀 중급 단계 (실무 2-3년차)
| 항목 | 설명 | 우선순위 |
|------|------|----------|
| **CompletableFuture** | 비동기 프로그래밍, 멀티스레드 처리 | ⭐⭐⭐ |
| **Method Reference** | `::` 문법으로 더 간결한 코드 | ⭐⭐⭐ |
| **Collectors** | Stream 결과를 다양한 형태로 수집 | ⭐⭐ |
| **Functional Interface** | `Predicate`, `Function`, `Consumer` 등 | ⭐⭐ |

### 🔥 고급 단계 (시니어 개발자)
| 항목 | 설명 | 우선순위 |
|------|------|----------|
| **Pattern Matching** | Java 17+ switch 패턴 매칭 | ⭐⭐⭐ |
| **Text Blocks** | 여러 줄 문자열 처리 (Java 15+) | ⭐⭐ |
| **Sealed Classes** | 상속 제한으로 안전한 계층 구조 | ⭐⭐ |
| **Virtual Threads** | 경량 스레드 (Java 21+) | ⭐ |
