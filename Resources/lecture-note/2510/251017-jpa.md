관계 선택 시 a스타일, b스타일 가지고 테스트를 해보았다.

DB 관점에서는 a, 코드 관점에서는 b 타입의 형태가 유리하다는 점 존재
DB는 부모-자식 객체? 코드는 객체로 보는 시점

jpa 자체는 원래 즉시 모두 로딩이 디폴트였는데 현실적 이유로 n+1 발생
lazy 미사용 시 프록시 객체로 인해 DB I/O가 다시 발생해서 N+1 사용하게 된다?

객체가 단방향 탐색밖에 안되서 생기는 태생적 문제

cascadetype.remove vs orphan removal
이벤트 트리거 적 관점
부모를 삭제할 때 자식도 같이 삭제 / 부모에서 자식을 삭제했을 때
고아 객체의 경우 시나리오가 일반적이지 않다.

---

Many to Many? 중간 테이블을 관리하지 못하기 때문에 제약 존재
중간 엔티티를 두고 many2one, one2many 등의 조합을 사용하는 것이 표준이다?

many to many는 비즈니스 로직 추가가 불가
요구사항 추가 시 못 바꾸는 것이 주요 문제

---

datainitializer
데이터 초기화시켜주는 클래스였다.

초기데이터를 다시 넣어주려고 함.
ddl-auto를 none으로 설정 시 영속성 관리 안되니까 데이터를 새로 넣어주려고 한다?
프로필 분리도 의미없음.
로직에 대한 문제라고 한다.
Repository에서 count를 통해 데이터가 있으면 초기화 정보가 들어간 것이라고 판단하게 해준다...?

---

오후

m2m에서 태그 조회시 오류 발생
에러 메시지가 없으니 수정이 어렵다.
-> 에러 로깅을 추가로 세팅해주면 더 디테일한 오류를 확인 가능함.

이슈는 엔티티를 직접 반환하기 때문에 생기는 것임
기존에는 dto를 반환할 때 생기지 않았었다.
entity를 사용할 때에도 생기지 않았었음.
차이점은 관계.

지연로딩 시 프록시 객체를 만들고 json 직렬화를 하기 때문에 오류가 생긴다.
권장 사항은 dto 사용


Cascade type의 경우 all 쓰면 안된다.
persist랑 remove 명시하는 방식으로 써라?

