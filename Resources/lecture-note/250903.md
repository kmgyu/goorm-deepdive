스프링 삼각형

AOP
반복되는 코드를 따로 빼는 것
로깅이 대표적.
로그 코드가 없어도 자동으로 찍히는 것
로깅 방법이 달라졌다? 한 클래스에서 모든 로그를 담당하니 클래스 추가하고 범위 수정하던가, 해당 클래스 수정하던가...

AOP 적용 후

```java
@Aspect
@Component
public class LoggingAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) {
        System.out.println("[로그] " + joinPoint.getSignature().getName() + " 시작");
        
        Object result = joinPoint.proceed(); // 실제 메서드 실행
        
        System.out.println("[로그] " + joinPoint.getSignature().getName() + " 완료");
        return result;
    }
}
```

**결과:**

```java
@Service
public class OrderService {
    public void processOrder() {
        // 로그 코드 없어도 자동으로 찍힌다!
        validateOrder();
        saveOrder();
        sendNotification();
    }
}
```


AOP는 지금은 구현할 일이 없다고 함.
초보 개발자 레벨에서 개발할 일이 없다고 한다?

---


PSA 쪽은 잘 몰랐는데 자료에서 설명되고 있다.
일관된 서비스 추상화?

PSA와 OOP
- **추상화**: OOP의 핵심 개념으로, 구체적인 기술 구현을 숨기고 일관된 인터페이스 제공
- **다형성**: 같은 인터페이스로 다양한 구현체를 사용할 수 있게 해주는 OOP 특성 활용
- **개방-폐쇄 원칙(OCP)**: 확장에는 열려있고 수정에는 닫혀있는 SOLID 원칙 지원

예시
각 드라이버마다 다른 구현체를 사용해줘야 했는데, 리포지토리 인터페이스로 통일하는 거...

트랜잭션 관리
```java
// 어떤 DB를 쓰든 동일한 방식
@Transactional
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    // JPA든 JDBC든 MyBatis든 상관없이 트랜잭션 처리됨
    accountRepository.withdraw(fromId, amount);
    accountRepository.deposit(toId, amount);
    // 예외 발생시 자동 롤백
}
```
캐시 관리
```java
// Redis든 EhCache든 Caffeine이든 동일한 방식
@Cacheable("users")
public User getUser(Long id) {
    return userRepository.findById(id);
}

@CacheEvict("users")
public void updateUser(User user) {
    userRepository.save(user);
}
```
웹 MVC
```java
// 톰캣, 제티, 언더토우 등 어떤 서버든 동일한 코드
@RestController
public class UserController {
    
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getUser(id);
    }
    
    @PostMapping("/users")
    public User createUser(@RequestBody User user) {
        return userService.createUser(user);
    }
}
```
예시 코드가 조금씩 이상하긴 한데, 어댑터 패턴이나 프록시 패턴의 더 넓은 개념이라고 보면 될 것 같다.
정확히는 PSA 구현을 위해 여러 디자인 패턴을 사용하는 것...
어댑터, 프록시, 전략, 템플릿 메서드, 퍼사드 등 여러 패턴이 쓰인다.

그래서 결론적으로 작고 유연하게 만든다는 패러다임임

---

값 검증하기

@Valid랑 @NotBlank 등 값 검증하는 것들

@Valid의 경우 DB 값 검증하는 것들도 많이 있다.

핵심 컴포넌트 및 역할
**Bean Validation Provider (Hibernate Validator)**
- Jakarta Validation 스펙의 구현체
- 어노테이션 기반 검증 규칙 실행
- 커스텀 Validator 지원

**BindingResult**
- 검증 오류 정보 수집 객체
- Controller와 View 사이의 오류 전달 매개체
- 필드별, 전체 오류 구분 저장

**MessageSource**
- 다국어 오류 메시지 관리
- properties 파일에서 메시지 로드
- 플레이스홀더({min}, {max}) 치환


Spring MVC와 Validation 통합
1. 어노테이션 처리 과정
```java
// 1. Entity에 검증 어노테이션 정의
@NotBlank(message = "제목은 필수입니다")
private String title;

// 2. Controller에서 @Valid 트리거
public String create(@Valid Post post, BindingResult result) {
    // 3. Spring이 자동으로 검증 실행 후 결과를 BindingResult에 저장
}
```
1. 검증 타이밍
- **Parameter Binding 후**: 요청 파라미터가 객체로 변환된 직후
- **Method 실행 전**: Controller 메서드 진입 이전
- **Exception 발생 없음**: 검증 실패 시에도 메서드는 실행됨
1. BindingResult의 특별한 점
- **순서 중요**: @Valid 매개변수 바로 다음에 위치해야 함
- **선택적 처리**: BindingResult가 없으면 MethodArgumentNotValidException 발생
- **입력값 보존**: 검증 실패 시에도 사용자 입력 데이터 유지

다국어 메시지도 가능
 