firebase 세팅
app-hosting 시 과금된다. 정적 파일 호스팅은 그냥 hosting을 이용할 것.
automatic builds and deploys with GitHub -> CI 옵션. 

정적 파일 프로젝트 할 거면 이거 이용
연결하고 싶은 도메인이 있다면 여기 연결할 것.
자바는 서비스할 수가 없다. (PHP는 안됨?)
자바도 올릴 수 있는 곳이 있다. aws 프리티어, 구글 프리티어, 벌쳐 등... 무료 크레딧 말하는 듯.
github pages도 있으니까
도메인 하나 사서 DNS 세팅하고 돌려보는 것도 나쁘지 않다.
무료 도메인도 있음.


JS특
- 인터프리터 언어
이름부터 스크립트가 들어가있다. 스크립트 언어들은 전부 인터프리터 쓴다.
HTML, CSS, JS 전부 브라우저에서 열려야하니까... 개인용 PC에서도 사용해야 하기 때문에 적은 비용으로 코드를 구동해야했고 이렇게 된 거 아닌가?
- 동적 타이핑 (타입 안 씀)
- 객체 기반
- 이벤트 기반
- 함수 중심
함수를 변수처럼 다룰 수 있음.
- 브라우저 내장

브라우저 렌더링 파이프라인

1. HTML 파싱 → DOM 트리 생성  
2. CSS 파싱 → CSSOM 트리 생성  
3. DOM + CSSOM → 렌더 트리(Render Tree) 생성  
4. 레이아웃(Layout) → 각 요소의 위치와 크기 계산  
5. 페인트(Paint) → 시각 요소들을 픽셀로 칠함  
6. 컴포지팅(Compositing) → 화면에 최종 합성

> todo에서 하기로 했던 것임.

렌더 트리(Render Tree)란,

> **브라우저가 DOM과 CSSOM을 결합해 실제 화면에 그릴 요소들을 구성한 트리 구조입니다.**

- `display: none` 같은 요소는 포함되지 않음
- 렌더링 최종 단계에서 **페인트(Paint)와 컴포지팅**으로 이어짐

### ❓생각해보기
 렌더트리 : 브라우저 입장에서 최종적으로 보여줘야 할 것들.
- `display: none` 요소는 **화면에는 안 보이지만 JavaScript에서 접근 가능할까?**
   -> 렌더 트리에는 없지만, **DOM에는 있으므로 접근은 가능하다** 

가상 돔 등장 배경
> 브라우저는 HTML, CSS, JavaScript를 해석해서  
> DOM을 만들고, 이를 그려주는 렌더링 과정을 거칩니다.
> 
> 그런데 이 DOM은 바뀔 때마다 **레이아웃, 페인트, 합성(컴포지팅)** 등  
> 많은 리소스를 쓰기 때문에 **성능 비용이 크죠.**
> 
> 그래서 React 같은 라이브러리는 DOM을 직접 조작하지 않고,  
> 가상의 DOM(Virtual DOM)**에서 먼저 변경사항을 계산한 뒤  
> 최소한의 변경만 실제 DOM에 반영해요.
> 
> 즉, 렌더링 파이프라인의 무거운 작업을 최소화하기 위해 나온 최적화 기법이에요.


```
[상태 변경]  
 → [Virtual DOM에서 변경사항 비교]  
 → [실제 DOM에 최소한만 반영]  
 → [렌더 트리 갱신 → Layout → Paint → Composite]
```

리액트에 가상 돔이 있기 때문에 훅이라는 개념이 생겼다.

브라우저의 주요 구성요소

|구성 요소|역할|
|---|---|
|**렌더링 엔진(Rendering Engine)**|HTML, CSS 파싱 → 화면 표시 (ex. Blink, WebKit)|
|**자바스크립트 엔진(JS Engine)**|JavaScript 실행 (ex. V8 - Chrome, SpiderMonkey - Firefox)|
|**네트워크 모듈**|HTTP 요청/응답 처리|
|**UI 모듈**|주소창, 탭, 버튼 등 브라우저 외부 UI|
|**데이터 저장소**|쿠키, LocalStorage, IndexedDB 등|
렌더링 엔진 내부 주요 흐름

```
HTML 파싱 → DOM 트리  
CSS 파싱 → CSSOM  
→ 렌더 트리 생성  
→ Layout (위치 계산)  
→ Paint (시각화)  
→ Composite (화면에 최종 출력)
```

그래서 버추얼 돔이 뭔데?
브라우저 렌더링 흐름에서 dom -> 렌더 트리 -> 페인트로 이어지는 무거운 과정의 비용을 줄이기 위해 등장한 최적화 기술

브라우저는 html 읽다가 script 만날 시 html 파싱 멈추고 js 실행
이로 인한 이슈 존재함.

ex) DOM이 만들어지지 않았는데 접근하려 하는 케이스들
head에서 아직 만들어지지 않은 DOM을 접근하던지

script defer -> 렌더링이 완료된 후 스크립트 읽음.
헤더에서 defer 명시하는 것이 가장 원칙적?

예전 스타일처럼 dom content loaded라는 이벤트를 넣을 수도 있음.
전체적인 document를 ready 시키고 생성 후 안전하게 js를 사용하는 식으로...


`DOMContentLoaded` vs `load` 이벤트 차이?

| 이벤트                | 언제 발생?                           | 특징                                  |
| ------------------ | -------------------------------- | ----------------------------------- |
| `DOMContentLoaded` | **DOM 트리 생성 완료 시**               | ✅ 빠름 / 이미지, CSS 등 **리소스 로딩 전에도 발생** |
| `load`             | **모든 리소스(CSS, 이미지 등)까지 로드 완료 시** | ⏱ 느림 / 전체가 다 준비된 후 발생               |
> `DOMContentLoaded`는 JS가 **빠르게 실행**되어야 할 때 사용  
> `load`는 **이미지, 영상 등 포함한 모든 게 준비된 후 실행**하고 싶을 때 사용

`<script async>` vs `<script defer>` 비교

| 속성      | 실행 시점               | 실행 순서 보장          | HTML 파싱 중단 여부       |
| ------- | ------------------- | ----------------- | ------------------- |
| 없음      | 즉시 실행               | ❌ (순서 불보장)        | ✅ 중단됨               |
| `async` | 다운로드 완료 즉시 실행       | ❌ (먼저 받아진 순으로 실행) | ❌ HTML 파싱 병행 가능     |
| `defer` | **HTML 파싱 끝난 뒤 실행** | ✅ **작성 순서대로 실행**  | ❌ 병행 (HTML 파싱 후 실행) |
- `async`: 빠르지만 **순서 보장 안 됨** → 광고, 트래킹 스크립트에 적합
- `defer`: **HTML 파싱 이후 실행 + 순서 보장** → 메인 스크립트에 적합

순수 js에서 이걸 활용할 일은 별로 없긴 하다.

`MutationObserver`와 리렌더링 감지

> **DOM의 변경을 감지하는 API**  
> → 비동기적으로 DOM 변경을 추적할 수 있음

요약
- **`DOMContentLoaded`**: DOM만 준비되었을 때 실행
- **`load`**: 모든 리소스(이미지 등 포함)가 다 준비된 뒤 실행
- **`async` vs `defer`**:  
    → `defer`는 순서 보장 + HTML 파싱 후 실행 / `async`는 순서 무시하고 즉시 실행
- **`MutationObserver`**: DOM이 바뀔 때 자동 감지하는 기능, 프레임워크에서도 내부적으로 사용됨


var let const
var 쓰던 시절?
언어로 불리지 않던 시절 사용했었고 데이터 타입이나, 변수 같은 것의 처리 같은게 그렇게 중요치 않던 시절임.
JS가 node 생기면서 서버사이드 생기면서 형태 같은 걸 감당할 수 없어서 let, const 등장.
목적 자체가 다르다? 태생 자체가 언어 관점에서 쓰는 게 아님. var은 이제 쓰면 안된다.

호이스팅
자바스크립트가 실행되기 전에 변수·함수 선언을 먼저 메모리에 등록해, 코드에서 선언 위치보다 위에서도 참조할 수 있게 되는 동작
개발에서 까지 신경 쓸 개념인지는 모르겠다고 함.

js에서 undefined와 null
undefined는 값이 "정의되지 않음", null은 "일부러 비워둠"입니다.

조건문과 연산자
타입까지 명확하게 비교할 때는 `===`를 쓰는 것이 안전합니다. 실무에선 `===`가 기본입니다.


선택과제?
안해도 된다. 프론트하려는 사람만 하면 될 것

고차함수
해보면 좋을 듯? 고차함수가 뭐죱
화살표 함수 익숙하다면 낯설 수가 있다.
이런게 있다 정도는 알아야 함.
깊게 다루진 않겠으나 리액트 사용 시 쓸 수 있다. (110% 쓸 일 생김)

숫자 & 문자열 정렬
문자열
사람이 보는 것과 다른 결과 줄 수 있다?
localeCompare는 사람이 보는 사전 순서에 맞춰 정렬

문자열이랑 숫자랑 섞일 경우 문자열 기준 정렬이 됬었?나?

DOM 접근하기
기본적인 돔 접근하는 것들
w3schools dom 내용 아주 많음.

Browser BOM이라는 것도 있음.

JS는 CSSOM에 바로 접근하지 못함. DOM을 통해 단계적으로 접근한다.
JS가 CSS를 변경하는 건 맞는데 직접적으로 CSSOM에 접근하는 것은 아님.
DOM에 딸린 CSSOM을 접근한다.

DOM methods, document, elements, html, forms....
간단하게 둘러보기
구글 드라이브랑 내 PC랑 연동할 수도 있다. Onedrive만 되는 줄 알았는데

인터렉티브한 것들을 좀 실험을 해보면 좋을 것 같다.

페어프로그래밍 하는 사람들은 이벤트리스너 걸어주고 JS 디버깅은 개발자 도구
