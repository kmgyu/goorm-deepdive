자바는 초기에는 클래스만 존재했다.
클래스 기반 상속은 단일 상속만 가능했다. -> OOP와 충돌
인터페이스 등장

문제 해결과 행동 규약 정의를 위해 인터페이스 도입
원칙적으로 정의된 규약은 모두 구현을 해줘야 함.

도입시점?
클래스 : 자바 초창기
인터페이스 : 자바 1.0

default라는 개념이 생기면서? 추상 클래스, 내부 클래스가 생김
클래스 : 모든걸 정의해야함.
추상 클래스 : 일부는 미리 정의한다는 개념 접목
복잡한 객체 관계 관리를 위해 내부 클래스 문법 도입
도입시기 : 자바 1.1

팩토리 메서드
객체 생성의 유연성을 높이기 위한 디자인 패턴
도입시기 : 디자인 패턴이기에 자바 버전에 종속되지 않음.


인터페이스와 default 메서드
자바 8부터 인터페이스에 default 메서드 도입
기존 인터페이스에 새로운 메서드 추가 시 인터페이스를 구현한 모든 클래스를 수정해야 하는 하위 호환성 이슈로 인함.
default 메서드는 인터페이스에 구현을 가진 메서드를 추가할 수 있도록 하여, 기존 클래스들이 영향을 받지 않고 그대로 동작할 수 있게 됨.
도입시기 : 자바8

---

추상클래스랑 default랑 뭔 차이가 있는거지

요즘 트렌드는 인터페이스에 default 메서드 쓰는 거

템플릿 메서드 패턴?
알고리즘 구조는 상위 클래스 정의, 세부 구현 하위클래스에서 결정
와 했던 거당당

---

클래스와 객체
객체가 메서드 영역에 올라간다?
힙 영역 아니었나?
객체가 스택 Area?
인스턴스? 특정 클래스로 만든 객체(관계 강조)

실제 구현체는 힙 영역, 포인터는 스택에 저장된다 라는 걸 말하시는 듯

클래스 : 메서드 애리어
스택 : 주소 포인터
힙 : 실제 구현체

생성자
생성자 선언 규칙? 까먹는 경우 많다.
기본 생성자가 있는 경우, 코드를 안써도 됨.
다른 생성자가 있는 경우, 기본 생성자 필요할 시 반드시 코드로 추가해줘야 함

생성자 체이닝
this(), super()

this() - 같은 클래스 다른 생성자 호출
```java
public class User {
    private String name;
    private int age;
    private String email;
    
    // 모든 필드를 초기화하는 마스터 생성자
    public User(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    
    // this()를 사용한 생성자 체이닝
    public User(String name, int age) {
        this(name, age, "이메일 미등록");  // 마스터 생성자 호출
    }
    
    public User(String name) {
        this(name, 0);  // 위의 생성자 호출
    }
    
    public User() {
        this("이름 미정");  // 위의 생성자 호출
    }
}
```
이런 느낌이라고 함.
오버로딩 메서드에서 기본 값 지정을 해주던가?
안해주면 이런 느낌일듯.


super() - 상위 클래스 생성자 호출
```java
class Animal {
    protected String species;
    
    public Animal(String species) {
        this.species = species;
        System.out.println("동물 생성: " + species);
    }
}

class Dog extends Animal {
    private String name;
    
    public Dog(String name) {
        super("개");  // 부모 클래스의 생성자 호출
        this.name = name;
        System.out.println("강아지 생성: " + name);
    }
}

// 사용
Dog dog = new Dog("뽀삐");
// 출력:
// 동물 생성: 개
// 강아지 생성: 뽀삐
```

> 💡 **부연설명**: this()와 super()는 생성자의 첫 번째 줄에 와야 하며, 동시에 사용할 수 없습니다. 이는 객체 초기화 순서를 명확히 하기 위함입니다.

```java
public class Child extends Parent {
    public Child() {
        super(); // 부모 생성자 호출
        this("Hello"); // 같은 클래스의 다른 생성자 호출 -> ❌ 컴파일 에러 발생
    }

    public Child(String message) {
        // ...
    }
}
```

Object
모든 자바 클래스 공통조상

toString()
문자열 표현을 반환하는 메서드
- 디버깅할 때 사용
- 객체 상태 확인
- 로그 기록

기본은 객체 키값 반환함. 그래서 재정의 시켜줘야 됨.

equals() 객체 동등성 비교
재정의를 통해 논리적으로 같은 객체인지 비교하도록 만들 수 있다.
```java
public class User {
    private String name;
    private int age;
    
    // equals() 오버라이드
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;  // 같은 참조인지 확인
        if (obj == null || getClass() != obj.getClass()) return false;
        
        User user = (User) obj;
        return age == user.age && Objects.equals(name, user.name);
    }
}

User user1 = new User("김철수", 25);
User user2 = new User("김철수", 25);

System.out.println(user1.equals(user2)); // true (내용이 같음)
System.out.println(user1 == user2);      // false (다른 객체)
```

hashCode()?
객체의 해시코드를 반환

### `hashCode()`의 주요 목적

1. **빠른 검색**: `HashMap`이나 `HashSet`과 같은 해시 기반 컬렉션은 객체의 `hashCode()` 값을 이용해 객체가 저장될 '버킷(Bucket)'을 빠르게 찾습니다. 이렇게 하면 모든 요소를 일일이 비교하지 않고도 객체를 삽입하거나 검색할 수 있어 성능이 매우 뛰어납니다.
    
2. **`equals()`와 함께 동등성 판단**: 객체를 해시 기반 컬렉션에 저장할 때, 먼저 `hashCode()`를 통해 동일한 버킷에 저장된 객체들을 찾습니다. 그 후, 찾은 객체들과 `equals()` 메서드로 실제 내용이 같은지 한 번 더 비교하여 최종적으로 동등성 여부를 판단합니다.

### `hashCode()` 재정의 시 주의사항

`equals()` 메서드를 재정의했다면, **`hashCode()` 메서드도 반드시 함께 재정의**해야 합니다. 두 메서드가 일관성 있게 동작해야 해시 기반 컬렉션에서 객체가 올바르게 처리됩니다.

- `equals()`가 `true`를 반환하는 두 객체는 **반드시 동일한 `hashCode()` 값을 반환**해야 합니다.

따라서 `hashCode()`는 `equals()`와 함께 객체의 논리적 동등성을 완성하는 중요한 메서드이며, 특히 `Map`이나 `Set`을 사용할 때 필수적으로 이해해야 하는 개념입니다.

```java
@Override
public int hashCode() {
    return Objects.hash(name, age);
}

// equals()가 true면 hashCode()도 같아야 함
if (user1.equals(user2)) {
    assert user1.hashCode() == user2.hashCode(); // 반드시 성립
}
```

> 💡 **부연설명**: 이 세 메서드를 올바르게 구현해야 HashMap, HashSet 등에서 객체가 올바르게 작동합니다.

---

JavaBeans 규칙
Getter/Setter
캡슐화와 접근 제어

1. **필드는 private으로 선언**
2. **getter 메서드**: get + 필드명(첫글자 대문자)
3. **setter 메서드**: set + 필드명(첫글자 대문자)
4. **boolean 필드**: isActive() 형태
5. **기본 생성자 제공**

Spring의 자동 매칭은 이 규칙을 기반으로 한다.

---

객체 복사 방식
참조 복사(= shallow copy)
객체 복사(= deep copy)

clone() 메서드
객체 복제시 사용
중요 규칙을 따라야 한다.
Cloneable 인터페이스 구현
clone() 메서드 재정의

---
빌더 패턴
복잡한 객체를 생성하는 과정을 단계별로 분리하여 객체를 더 쉽게 만들고 가독성을 높이는 디자인 패턴
 객체에 필드가 많을 때 특히 유용
`new` 키워드를 여러 번 사용하지 않고도 유연하게 객체를 초기화

빌더 패턴은 보통 다음과 같은 구조로 이루어집니다.

1. **빌더 클래스**: 객체를 만들기 위한 메서드들을 포함하는 내부(Inner) 클래스입니다.
2. **생성 메서드**: 빌더 클래스의 메서드를 통해 최종적으로 원본 객체를 생성합니다.

### 빌더 패턴의 장점

- **가독성 향상**: `new Person("홍길동", 30, null)`과 같이 매개변수의 의미를 알기 어려운 생성자 대신, `new Person.Builder().name("홍길동").age(30).build()`처럼 메서드 이름을 통해 각 값이 무엇을 의미하는지 명확하게 알 수 있습니다.
    
- **유연성**: 필요한 필드만 선택적으로 초기화할 수 있습니다.
    
- **불변성(Immutability)**: `final` 키워드를 사용하여 객체가 한 번 생성되면 상태를 변경할 수 없도록 만들어 안정성을 높일 수 있습니다.
    

### 실무에서의 빌더 패턴

`Lombok` 라이브러리의 `@Builder` 어노테이션을 사용하면 위와 같은 코드를 직접 작성하지 않아도 자동으로 빌더 패턴을 구현해줍니다. 이 때문에 실무에서 가장 널리 사용되는 객체 생성 패턴 중 하나입니다.

---

직렬화
### 6.1 직렬화란?

객체를 바이트 스트림으로 변환하여 저장하거나 전송할 수 있게 만드는 과정

```java
// 직렬화 가능한 클래스
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int age;
    private transient String password;  // 직렬화에서 제외
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

// 객체를 파일로 저장
User user = new User("김철수", 25);
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.ser"));
oos.writeObject(user);
oos.close();

// 파일에서 객체로 복원
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.ser"));
User restoredUser = (User) ois.readObject();
ois.close();
```

### 6.2 현대적 접근 - JSON

```java
// 실무에서는 JSON을 더 많이 사용
public class User {
    private String name;
    private int age;
    
    // 기본 생성자 필요 (JSON 라이브러리용)
    public User() {}
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // getter/setter 필요
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}
```

스프링에서는 JSON 변환이 자동으로 처리됨, 이때 자바빈즈 규칙이 중요한 역할을 한다.


네트워크 관점에서 보면 브라우저와 서버 사이에서 바이트코드로 전환되어 전송된다.
받는 사람 입장에서는 정리되지 않으면 구분하기 어려움..
JSON 형태 객체를 보낼 시 직렬화를 시켜서 보내게 된다.
객체 통신 시 직렬화하여 보내야 한다.

클래스 던지는 형식이 아니라 직렬화할 수 있는 Serializable 인터페이스 있어야 한다...? 어..
객체 자체를 직렬화하는 게 아니라 요즘은 JSON으로 해준다.
그래서 JSON 베이스로 직렬화 해준다.
명시적으로 직렬화를 풀거나 직렬화를 하지 않아도 해준다.
응답도 JSON 응답 시 자동으로 던져준다?

---

static 키워드
클래스에 속하는 멤버(인스턴스와 무관)

static 메모리 구조
클래스가 처음 사용될 때 메모리에 로드되어 method area에 저장됨.

static method의 경우, 인스턴스 변수에는 접근이 불가능하다.
매개변수로 인스턴스 받아주는 경우 아닌 이상 접근 못한다.
마찬가지로 this 키워드도 사용하지 못한다.

활용방식?
유틸리티 클래스.
인스턴스 생성을 방지하고 메서드만 사용하는 클래스 방식
ex) Math.sqrt(), Math.abs()

---
final 키워드

재할당되지 않도록 한다.

상수 선언 시 사용
메서드에 사용하여 오버라이드 금지용으로도 사용됨. (상속 시 재정의되지 않음.)
클래스에 사용시 혹은 상속 금지로도 사용 가능.

불변 객체 만들기

---

접근 제어자

|접근제어자|같은 클래스|같은 패키지|하위클래스|다른 패키지|
|---|---|---|---|---|
|public|✅|✅|✅|✅|
|protected|✅|✅|✅|❌|
|default|✅|✅|❌|❌|
|private|✅|❌|❌|❌|
내부에서만 사용하는 헬퍼 메서드의 경우, private로 선언

하위클래스에서 접근가능하게 하려면 protected 선언

캡슐화 전략
1. **모든 필드는 private**로 시작
2. **필요한 메서드만 public**으로 공개
3. **내부 구현은 private**으로 숨김
4. **상속 고려사항은 protected** 사용

Spring Security에서 사용자 인증 시 해당 캡슐화 원칙 적용됨

---

내부 클래스

두 클래스가 논리적으로 강하게 연결되어 있지만, 내부 클래스가 외부 클래스에 종속적일 때 사용

외부 클래스 멤버에 접근 가능

내부 클래스는 외부 클래스 객체를 통해서만 객체 생성 가능.

유형
멤버 내부 클래스
정적 내부 클래스
지역 내부 클래스
익명 내부 클래스

> 자세한 건 강의 자료에서 확인

람다식 도입되면서 익명 내부클래스의 경우 람다식 쓰는 게 더 많아졌다?
람다식이 문법적으로 클리어하다.

---

패키지와 import
패키지 역할
import 활용
### 5.3 패키지 설계 원칙

```java
// 도메인별 패키지 구조
com.company.ecommerce
├── user
│   ├── User.java
│   ├── UserService.java
│   └── UserRepository.java
├── product  
│   ├── Product.java
│   ├── ProductService.java
│   └── ProductRepository.java
└── order
    ├── Order.java
    ├── OrderService.java
    └── OrderRepository.java
```
Spring Boot에서 @ComponentScan이 패키지 기준으로 동작하므로 패키지 구조가 매우 중요

---
# 정적 팩토리 메서드
### 6.1 정적 팩토리 메서드란?


`static`메소드를 통해 객체를 생성하는 **방식**.

### 정적 팩토리 메서드의 목적 및 장점


**정적 팩토리 메서드**는 객체 생성을 담당하는 `static` 메서드입니다. 일반 생성자(`new User(...)`) 대신 `User.createAdmin(...)`처럼 **의미 있는 이름**을 가진 메서드를 통해 객체를 만드는 방식입니다.

#### 6.2 정적 팩토리 메서드의 장점

- **이름을 가질 수 있음**: `new` 키워드 대신 `from()`, `of()`, `create()`처럼 **의미 있는 메서드 이름**을 사용해 객체가 어떻게 만들어지는지 명확하게 알 수 있습니다.
    
- **객체를 재활용할 수 있음**: 필요할 때마다 새로운 객체를 만들지 않고, 이미 만들어진 객체를 반환하여 메모리를 절약할 수 있습니다. `Boolean.valueOf(true)`가 대표적인 예시입니다.
    
- **반환 타입의 하위 타입 객체를 반환**: 부모 클래스의 메서드로 자식 클래스의 객체를 반환할 수 있어 유연한 설계를 할 수 있습니다.
    

#### 6.3 정적 팩토리 메서드의 활용

직접 구현하는 경우는 많지 않지만, **자바 표준 라이브러리**에서 이미 광범위하게 사용되고 있습니다. 이 개념을 이해하면 `Integer.valueOf()`, `Collections.emptyList()` 같은 메서드들이 왜 이런 형태로 존재하는지 알 수 있게 됩니다.

**결론**: 정적 팩터리 메서드는 **객체 생성의 효율성과 가독성을 높여주는** 유용한 방법으로, 직접 구현하기보다는 자바의 다양한 API를 이해하는 데 중요한 개념입니다.

**정적 팩토리 메서드를 먼저 호출**해서 객체를 생성해야만, 그 다음에 `getName()`과 같은 일반 메서드를 사용할 수 있습니다.

팩토리 메서드와 일반 메서드의 관계는 다음과 같이 정리할 수 있습니다.

1. **객체 생성**: `User.createAdmin("관리자")`처럼 **정적 팩터리 메서드**를 호출하여 `User` 객체를 만듭니다. 이 과정이 없으면 `User` 객체는 존재하지 않습니다.
2. **객체 사용**: `admin.getName()`처럼 **일반 메서드**를 호출하여 생성된 객체의 데이터를 사용합니다.

이처럼 정적 팩토리 메서드는 **객체의 시작점** 역할을 하고, 일반 메서드는 **생성된 객체를 활용하는 역할**을 담당합니다.

장점
이름을 가질 수 있어 의미를 통해 기능을 명확하게 알 수 있다.
호출할 때마다 새 객체를 만들지 않아도 된다.
하위 타입 객체 반환 가능(자식 클래스)

### 6.3 일반적인 명명 규칙

```java
public class User {
    
    // from: 매개변수 하나로 인스턴스 생성
    public static User from(String userData) {
        // userData 파싱해서 User 객체 생성
        return new User(userData);
    }
    
    // of: 여러 매개변수를 받아서 인스턴스 생성  
    public static User of(String name, int age, String email) {
        return new User(name, age, email);
    }
    
    // valueOf: from과 of의 더 자세한 버전
    public static User valueOf(String userInfo) {
        return new User(userInfo);
    }
    
    // instance 또는 getInstance: 싱글톤 패턴
    public static User getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    // create 또는 newInstance: 매번 새로운 인스턴스 생성
    public static User create(String name) {
        return new User(name);
    }
}
```

Integer.valueOf(), String.valueOf(), Collections.emptyList() 등이 정적 팩토리 메서드의 좋은 예시


---
String
String 성능 이슈

```java
public class StringPerformance {
    
    // ❌ 성능이 나쁜 코드
    public static String badConcatenation() {
        String result = "";
        for (int i = 0; i < 1000; i++) {
            result += "a"; // 매번 새 String 객체 생성!
        }
        return result; // 1000개의 String 객체 생성됨
    }
    
    // ✅ 성능이 좋은 코드
    public static String goodConcatenation() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append("a"); // 내부 버퍼에 추가
        }
        return sb.toString(); // 마지막에 한 번만 String 생성
    }
}
```

> 💡 **부연설명**: 문자열을 반복적으로 연결할 때는 StringBuilder를 사용해야 합니다. String의 불변성 때문에 매번 새 객체가 생성되어 성능이 급격히 저하됩니다.


## 🔧 2. StringBuilder와 StringBuffer

### 2.1 가변 문자열 클래스

```java
public class StringBuilderExample {
    public static void main(String[] args) {
        // StringBuilder 생성
        StringBuilder sb = new StringBuilder();
        
        // 문자열 추가
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        
        // 메서드 체이닝
        sb.append("!").append(" Java").append(" Programming");
        
        // 삽입
        sb.insert(6, "Beautiful ");
        
        // 삭제
        sb.delete(6, 16); // "Beautiful " 삭제
        
        // 교체
        sb.replace(6, 11, "Amazing");
        
        // 뒤집기
        StringBuilder reversed = new StringBuilder("Hello").reverse();
        System.out.println(reversed); // "olleH"
        
        // 최종 String 변환
        String result = sb.toString();
        System.out.println(result); // "Hello Amazing Java Programming"
    }
}
```

### 2.2 StringBuilder vs StringBuffer

```java
public class StringBuilderVsBuffer {
    
    // StringBuilder - 단일 스레드 환경
    public static String useStringBuilder() {
        StringBuilder sb = new StringBuilder();
        sb.append("Fast");
        sb.append(" and");
        sb.append(" Efficient");
        return sb.toString();
    }
    
    // StringBuffer - 멀티스레드 환경
    public static String useStringBuffer() {
        StringBuffer sb = new StringBuffer();
        sb.append("Thread");
        sb.append(" Safe");
        sb.append(" but Slower");
        return sb.toString();
    }
}
```

**차이점:**

- **StringBuilder**: 동기화되지 않음, 빠름, 단일 스레드용
- **StringBuffer**: 동기화됨, 느림, 멀티 스레드용

> 💡 **부연설명**: 대부분의 상황에서는 StringBuilder를 사용합니다. StringBuffer는 레거시 코드에서 주로 볼 수 있습니다.

---
래퍼 클래스

**8가지 래퍼 클래스:**

- byte → Byte
- short → Short
- int → Integer
- long → Long
- float → Float
- double → Double
- char → Character
- boolean → Boolean

자동 박싱 / 언박싱
```java
public class AutoBoxingExample {
    public static void main(String[] args) {
        // 자동 박싱 (Auto Boxing)
        Integer num1 = 10; // Integer.valueOf(10)과 동일
        Double num2 = 3.14; // Double.valueOf(3.14)와 동일
        
        // 자동 언박싱 (Auto Unboxing)
        int primitive1 = num1; // num1.intValue()와 동일
        double primitive2 = num2; // num2.doubleValue()와 동일
        
        // 연산에서의 자동 박싱/언박싱
        Integer a = 100;
        Integer b = 200;
        Integer c = a + b; // 언박싱 → 연산 → 박싱
        
        // 컬렉션에서의 활용
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1); // 자동 박싱
        numbers.add(2);
        
        int first = numbers.get(0); // 자동 언박싱
    }
}
```

특별한 특성
Integer 캐싱
JVM은 -128~127 범위의 Integer 객체를 미리 생성해서 캐싱
> 파이썬도 비슷한 거 있던데

---
다양한 유틸리티 클래스 및 유용한 클래스들

Math 클래스
수학 연산 메서드

Arrays 클래스
배열 조작 메서드

날짜와 시간
LocalDate - 날짜 처리
LocalTime - 시간 처리
LocalDateTime - 날짜와 시간

Spring Boot에서 JSON 응답에 날짜가 포함될 때 LocalDateTime을 자주 사용하며, 포맷팅 설정이 중요

Random 클래스

---
enum
**enum**: 서로 관련된 상수들을 편리하게 선언하기 위한 특별한 클래스

```java
// 기본 enum 선언
public enum Color {
    RED, GREEN, BLUE, YELLOW
}
```

### 1.2 enum vs 상수의 차이점

```java
// ❌ 기존 상수 방식의 문제점
public class OldConstants {
    public static final int SPRING = 1;
    public static final int SUMMER = 2;
    public static final int AUTUMN = 3;
    public static final int WINTER = 4;
}

public class BadExample {
    public static void main(String[] args) {
        int season = OldConstants.SPRING;
        
        // 문제 1: 타입 안전성 없음
        season = 100; // 컴파일 에러 없음, 하지만 잘못된 값
        
        // 문제 2: 의미 없는 출력
        System.out.println(season); // 1 (무슨 의미인지 모름)
        
        // 문제 3: 네임스페이스 없음
        if (season == 1) { // 1이 뭘 의미하는지 불분명
            System.out.println("봄");
        }
    }
}
```

### 1.3 enum의 고급 기능

#### 필드와 메서드를 가지는 enum

```java
public enum Planet {
    // 각 상수에 값 할당
    MERCURY(3.303e+23, 2.4397e6),
    VENUS(4.869e+24, 6.0518e6),
    EARTH(5.976e+24, 6.37814e6),
    MARS(6.421e+23, 3.3972e6);
    
    // 필드 선언
    private final double mass;   // 질량 (kg)
    private final double radius; // 반지름 (m)
    
    // 생성자 (private만 가능)
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    
    // 메서드 정의
    public double getMass() {
        return mass;
    }
    
    public double getRadius() {
        return radius;
    }
    
    // 중력 계산
    public double getGravity() {
        final double G = 6.67300E-11; // 중력 상수
        return G * mass / (radius * radius);
    }
}

// 사용
public class PlanetExample {
    public static void main(String[] args) {
        Planet earth = Planet.EARTH;
        
        System.out.println("지구의 질량: " + earth.getMass());
        System.out.println("지구의 중력: " + earth.getGravity());
        
        // 모든 행성 출력
        for (Planet p : Planet.values()) {
            System.out.printf("%s: 중력=%.2f%n", p.name(), p.getGravity());
        }
    }
}
```

#### 추상 메서드를 가지는 enum

```java
public enum Operation {
    PLUS("+") {
        @Override
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS("-") {
        @Override
        public double apply(double x, double y) {
            return x - y;
        }
    },
    MULTIPLY("*") {
        @Override
        public double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE("/") {
        @Override
        public double apply(double x, double y) {
            return x / y;
        }
    };
    
    private final String symbol;
    
    Operation(String symbol) {
        this.symbol = symbol;
    }
    
    // 추상 메서드 - 각 상수에서 구현해야 함
    public abstract double apply(double x, double y);
    
    @Override
    public String toString() {
        return symbol;
    }
}

// 사용
public class CalculatorExample {
    public static void main(String[] args) {
        double x = 10;
        double y = 3;
        
        for (Operation op : Operation.values()) {
            System.out.printf("%.1f %s %.1f = %.1f%n", 
                x, op, y, op.apply(x, y));
        }
        // 출력:
        // 10.0 + 3.0 = 13.0
        // 10.0 - 3.0 = 7.0
        // 10.0 * 3.0 = 30.0
        // 10.0 / 3.0 = 3.3
    }
}
```

권한 설계 같은 것에서 enum 타입 활용하게 되면 좋다.

상태 관리에서도 사용 가능.

> 💡 **부연설명**: enum은 싱글톤 패턴을 보장합니다. 각 상수는 JVM에서 하나의 인스턴스만 존재하므로 == 연산자로 안전하게 비교할 수 있습니다.

> 🔮 **Spring 예고**: Spring Boot에서 @ConfigurationProperties와 함께 enum을 사용하여 설정값을 타입 안전하게 관리할 수 있습니다.

---

## 📝 2. record 클래스 (Java 14+)

데이터 세팅시 불변 객체로 만들어 안전하게 보내기 위함?
클래스는 성격상 getter, setter가 있어 데이터를 세팅 가능함.
객체 자체가 불변

엔티티 객체 생성 시 두가지 이슈가 있다?

엔티티를 통으로 넘기면 안된다 라는 개념이 있을 때 record를 사용하게 된다?
아직 잘 모르겠음...

필요한 건 2개인데 리턴되는건 5개?


### 2.1 record의 등장 배경

```java
// ❌ 전통적인 데이터 클래스 - 보일러플레이트 코드 많음
public class PersonOld {
    private final String name;
    private final int age;
    private final String email;
    
    public PersonOld(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    public String getEmail() { return email; }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PersonOld person = (PersonOld) obj;
        return age == person.age && 
               Objects.equals(name, person.name) && 
               Objects.equals(email, person.email);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age, email);
    }
    
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + ", email='" + email + "'}";
    }
}
```

```java
// ✅ record 클래스 - 한 줄로 해결!
public record Person(String name, int age, String email) {
    // 자동으로 생성되는 것들:
    // - private final 필드들
    // - 생성자
    // - getter 메서드들 (name(), age(), email())
    // - equals(), hashCode(), toString()
}

// 사용
public class RecordExample {
    public static void main(String[] args) {
        Person person = new Person("김철수", 25, "kim@email.com");
        
        // 자동 생성된 메서드들
        System.out.println(person.name()); // 김철수
        System.out.println(person.age()); // 25
        System.out.println(person); // Person[name=김철수, age=25, email=kim@email.com]
        
        // equals 자동 구현
        Person person2 = new Person("김철수", 25, "kim@email.com");
        System.out.println(person.equals(person2)); // true
    }
}
```

### 2.2 record의 고급 기능

#### 커스텀 생성자와 검증

```java
public record BankAccount(String accountNumber, double balance) {
    
    // 컴팩트 생성자 - 검증 로직 추가
    public BankAccount {
        if (accountNumber == null || accountNumber.isEmpty()) {
            throw new IllegalArgumentException("계좌번호는 필수입니다");
        }
        if (balance < 0) {
            throw new IllegalArgumentException("잔액은 음수일 수 없습니다");
        }
        
        // 필드 정규화
        accountNumber = accountNumber.toUpperCase();
    }
    
    // 추가 생성자
    public BankAccount(String accountNumber) {
        this(accountNumber, 0.0); // 기본 잔액 0
    }
    
    // 인스턴스 메서드 추가
    public BankAccount deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("입금액은 양수여야 합니다");
        }
        return new BankAccount(accountNumber, balance + amount);
    }
    
    public BankAccount withdraw(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("출금액은 양수여야 합니다");
        }
        if (amount > balance) {
            throw new IllegalArgumentException("잔액이 부족합니다");
        }
        return new BankAccount(accountNumber, balance - amount);
    }
    
    // 정적 메서드 추가
    public static BankAccount createSavingsAccount(String accountNumber, double initialBalance) {
        return new BankAccount("SAV-" + accountNumber, initialBalance);
    }
}

// 사용
public class BankAccountExample {
    public static void main(String[] args) {
        BankAccount account = BankAccount.createSavingsAccount("12345", 1000);
        System.out.println(account); // BankAccount[accountNumber=SAV-12345, balance=1000.0]
        
        BankAccount afterDeposit = account.deposit(500);
        System.out.println(afterDeposit.balance()); // 1500.0
        
        // 원본은 변경되지 않음 (불변 객체)
        System.out.println(account.balance()); // 1000.0
    }
}
```

### 2.3 record vs class 선택 기준

**record 사용하면 좋은 경우:**

- 단순한 데이터 저장용 객체
- 불변 객체가 필요한 경우
- DTO, VO 같은 값 객체
- API 응답/요청 데이터

**일반 class 사용해야 하는 경우:**

- 상태가 변경되어야 하는 경우
- 복잡한 비즈니스 로직이 필요한 경우
- 상속이 필요한 경우

```java
// ✅ record 적합 - API 응답 데이터
public record ApiResponse(int code, String message, Object data) {}

// ✅ record 적합 - 설정 정보
public record DatabaseConfig(String url, String username, int maxConnections) {}

// ❌ record 부적합 - 상태 변경이 필요
public class ShoppingCart {
    private List<Item> items = new ArrayList<>();
    
    public void addItem(Item item) {
        items.add(item); // 상태 변경
    }
}
```

---

## 📦 3. 제네릭 기초

### 3.1 제네릭 등장 배경

```java
// ❌ 제네릭 없던 시절 - 타입 안전성 없음
import java.util.*;

public class BeforeGenerics {
    public static void main(String[] args) {
        List list = new ArrayList(); // Raw Type
        
        list.add("문자열");
        list.add(123); // 다른 타입도 들어감
        list.add(true); // 컴파일 에러 없음
        
        // 사용할 때 문제 발생
        for (Object obj : list) {
            String str = (String) obj; // ClassCastException 위험!
            System.out.println(str.toUpperCase());
        }
    }
}
```

```java
// ✅ 제네릭 사용 - 타입 안전성 확보
import java.util.*;

public class WithGenerics {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(); // 타입 지정
        
        list.add("문자열");
        // list.add(123); // 컴파일 에러! 타입 안전성
        
        // 캐스팅 불필요
        for (String str : list) {
            System.out.println(str.toUpperCase()); // 안전함
        }
    }
}
```

### 3.2 기본 제네릭 사용법

```java
// 제네릭 클래스 정의
public class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}

// 제네릭 메서드
public class GenericMethod {
    
    // 제네릭 메서드 정의
    public static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    public static void main(String[] args) {
        // 다양한 타입으로 사용
        Box<String> stringBox = new Box<>();
        stringBox.set("Hello");
        String value = stringBox.get(); // 캐스팅 불필요
        
        Box<Integer> intBox = new Box<>();
        intBox.set(123);
        Integer number = intBox.get();
        
        // 제네릭 메서드 사용
        String[] names = {"Alice", "Bob", "Charlie"};
        swap(names, 0, 2);
        System.out.println(Arrays.toString(names)); // [Charlie, Bob, Alice]
        
        Integer[] numbers = {1, 2, 3};
        swap(numbers, 0, 1);
        System.out.println(Arrays.toString(numbers)); // [2, 1, 3]
    }
}
```

### 3.3 와일드카드와 제한된 타입

```java
import java.util.*;

public class WildcardExample {
    
    // ? extends T (상한 제한) - T와 그 하위 타입만 허용
    public static double sumOfNumbers(List<? extends Number> numbers) {
        double sum = 0.0;
        for (Number num : numbers) {
            sum += num.doubleValue();
        }
        return sum;
    }
    
    // ? super T (하한 제한) - T와 그 상위 타입만 허용
    public static void addNumbers(List<? super Integer> numbers) {
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
    }
    
    public static void main(String[] args) {
        // 상한 제한 와일드카드 활용
        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);
        List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3);
        
        System.out.println(sumOfNumbers(intList)); // 15.0
        System.out.println(sumOfNumbers(doubleList)); // 6.6
        
        // 하한 제한 와일드카드 활용
        List<Number> numberList = new ArrayList<>();
        addNumbers(numberList);
        System.out.println(numberList); // [1, 2, 3]
        
        List<Object> objectList = new ArrayList<>();
        addNumbers(objectList);
        System.out.println(objectList); // [1, 2, 3]
    }
}
```

### 3.4 제네릭 실무 활용 패턴

```java
// 제네릭 인터페이스
public interface Repository<T, ID> {
    void save(T entity);
    T findById(ID id);
    List<T> findAll();
    void delete(ID id);
}

// 구현 클래스
public class UserRepository implements Repository<User, Long> {
    
    private Map<Long, User> users = new HashMap<>();
    private long nextId = 1;
    
    @Override
    public void save(User user) {
        user.setId(nextId++);
        users.put(user.getId(), user);
    }
    
    @Override
    public User findById(Long id) {
        return users.get(id);
    }
    
    @Override
    public List<User> findAll() {
        return new ArrayList<>(users.values());
    }
    
    @Override
    public void delete(Long id) {
        users.remove(id);
    }
}

// 사용자 클래스
class User {
    private Long id;
    private String name;
    
    public User(String name) {
        this.name = name;
    }
    
    // getter, setter
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    @Override
    public String toString() {
        return "User{id=" + id + ", name='" + name + "'}";
    }
}

// 활용 예제
public class RepositoryExample {
    public static void main(String[] args) {
        UserRepository userRepo = new UserRepository();
        
        userRepo.save(new User("김철수"));
        userRepo.save(new User("이영희"));
        
        User user = userRepo.findById(1L);
        System.out.println(user); // User{id=1, name='김철수'}
        
        List<User> allUsers = userRepo.findAll();
        System.out.println(allUsers); // [User{id=1, name='김철수'}, User{id=2, name='이영희'}]
    }
}
```

> 💡 **부연설명**: 제네릭은 컴파일 시점에서만 타입 체크를 하고, 런타임에는 타입 정보가 소거됩니다(Type Erasure). 이를 알아두면 고급 제네릭을 이해하는데 도움이 됩니다.

---
어노테이션

프로그램에 대한 메타데이터를 제공하는 특별한 형태의 문법

개념 자체는 이전부터 존재함.

#### 어노테이션은 왜 생겼을까? 🤔

어노테이션이 등장하기 전에는 설정 정보를 XML 파일 같은 외부 파일에 기록하거나, Javadoc 주석에 규칙을 정해 정보를 추가하는 방식을 사용했습니다. 하지만 이 방식들은 다음과 같은 단점들이 있었습니다.

- **코드와 설정의 분리**: XML 파일은 코드와 따로 관리되어, 어떤 설정이 어떤 코드에 적용되는지 한눈에 파악하기 어려웠습니다.
- **컴파일러의 무지**: 단순 주석은 컴파일러가 인식하지 못해 문법 오류를 검증할 수 없었습니다.
- **복잡한 파싱**: Javadoc 주석을 읽어 처리하는 별도의 프로그램을 만들어야 하는 번거로움이 있었습니다.

이러한 문제들을 해결하기 위해 **코드 내부에 직접 메타데이터를 포함**시키고, 컴파일러나 JVM이 이 정보를 활용할 수 있도록 하기 위해 어노테이션이 등장했습니다.

어노테이션은 `@Override`처럼 컴파일러에게 추가 정보를 제공하거나, `@Service`처럼 런타임에 리플렉션 기술을 통해 필요한 기능을 주입하는 등 다양한 용도로 활용됩니다.

Java 5에서 공식적으로 첫 도입

@Override 명시 등...
부모의 메서드를 상속하는 것인지, 직접 메서드를 만드는 것인 지 알 수 없음.
이런 문제를 해결하기 위해 도입되었음.

예전 스타일은 XML에 정의했었는데, 요즘은 어노테이션이 대세임
XML이 더러운데 한번에 볼 수 있다.
어노테이션은 다 분산이 되있어서 소스코드 상에서 찾기 힘들지 않은가?
초창기에는 이런 의견이 있었음.

마커, 단일값, 다중값 어노테이션 등이 있음.

커스텀 어노테이션 만드는 법....

---

예외 처리

**예외(Exception)**: 프로그램 실행 중에 발생하는 예상치 못한 상황입니다. 개발자가 적절히 처리하여 프로그램이 비정상적으로 종료되는 것을 막을 수 있습니다.

예외 vs 에러
**예외**는 프로그램에서 처리할 수 있는 문제이고, **에러**는 시스템 레벨의 심각한 문제로 프로그램에서 처리하기 어렵습니다.

## 🌳 2. 예외 계층구조

### 2.1 예외 클래스 계층

자바의 모든 예외는 `Throwable` 클래스를 상속받는 계층 구조를 가집니다.

```
Throwable
├── Error (시스템 레벨 에러)
│   ├── OutOfMemoryError
│   ├── StackOverflowError
│   └── ...
└── Exception (프로그램 레벨 예외)
    ├── IOException (Checked Exception)
    ├── SQLException (Checked Exception)
    └── RuntimeException (Unchecked Exception)
        ├── NullPointerException
        ├── IllegalArgumentException
        ├── ArrayIndexOutOfBoundsException
        └── ...
```

### 2.2 Checked vs Unchecked Exception

#### Checked Exception - 컴파일 시점에 처리 강제

컴파일러가 예외 처리를 **강제**하는 예외입니다. 주로 파일 입출력(`IOException`)처럼 외부 자원과 관련된 경우가 많습니다.


```java
import java.io.*;

public class CheckedException {

    // ❌ 컴파일 에러 - 예외 처리 안함
    /*
    public void readFile(String filename) {
        FileReader file = new FileReader(filename); // IOException 발생 가능
    }
    */

    // ✅ 방법 1: try-catch로 처리
    public void readFileWithTryCatch(String filename) {
        try {
            FileReader file = new FileReader(filename);
            System.out.println("파일 읽기 성공");
            file.close();
        } catch (IOException e) {
            System.out.println("파일 읽기 실패: " + e.getMessage());
        }
    }

    // ✅ 방법 2: throws로 상위로 전파
    public void readFileWithThrows(String filename) throws IOException {
        FileReader file = new FileReader(filename);
        System.out.println("파일 읽기 성공");
        file.close();
    }

    public static void main(String[] args) {
        CheckedException example = new CheckedException();

        // try-catch 버전 사용
        example.readFileWithTryCatch("nonexistent.txt");

        // throws 버전 사용 - 여기서도 처리해야 함
        try {
            example.readFileWithThrows("test.txt");
        } catch (IOException e) {
            System.out.println("메인에서 처리: " + e.getMessage());
        }
    }
}
```

#### Unchecked Exception - 런타임에 발생

`RuntimeException`을 상속받는 예외로, 컴파일러가 처리를 강제하지 않습니다. `NullPointerException`처럼 개발자의 실수로 발생하는 예외가 대부분입니다.


```java
public class UncheckedException {

    public static int divide(int a, int b) {
        // 처리해도 되고, 안해도 됨 (컴파일 에러 없음)
        return a / b; // ArithmeticException 발생 가능
    }

    public static int safeDivide(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("0으로 나눌 수 없습니다");
        }
        return a / b;
    }

    public static void main(String[] args) {
        // 예외 처리 안함 - 프로그램 종료됨
        // System.out.println(divide(10, 0));

        // 예외 처리함 - 프로그램 계속 실행
        try {
            System.out.println(divide(10, 0));
        } catch (ArithmeticException e) {
            System.out.println("나눗셈 오류 발생: " + e.getMessage());
        }

        // 명시적 예외 발생
        try {
            System.out.println(safeDivide(10, 0));
        } catch (IllegalArgumentException e) {
            System.out.println("안전한 나눗셈 오류: " + e.getMessage());
        }
    }
}
```

> 💡 **부연설명**: Checked Exception은 컴파일러가 처리를 강제하므로 반드시 `try-catch` 또는 `throws`를 사용해야 합니다. Unchecked Exception은 처리하지 않아도 컴파일은 되지만, 런타임에 예외가 발생하면 프로그램이 종료됩니다.

try-catch-resources

자원 관리의 문제점

파일 처리 중 예외 발생 시 자원 해제 코드가 생기는데 코드 복잡성 완화를 위해 사용됨

`try-with-resources`는 `AutoCloseable` 인터페이스를 구현하는 객체를 `try` 괄호 안에 선언하면, `try` 블록을 벗어나는 순간 **자동으로 `close()` 메서드를 호출**해 자원을 해제합니다. 이로써 자원 누수를 막고 코드를 간결하게 만들 수 있습니다.

> 💡 **부연설명**: `try-with-resources`는 `AutoCloseable` 인터페이스를 구현하는 모든 객체와 함께 사용할 수 있습니다. 자원들은 선언된 순서의 역순으로 해제됩니다.

Exception 만드는 이유?
`Exception` 또는 `RuntimeException`을 상속받아 **애플리케이션의 도메인(업무)에 맞는 예외**를 직접 정의합니다. 예외에 비즈니스 관련 정보를 담아 전달할 수 있어 코드의 가독성이 높아집니다.

사용자 입장에서 모르게 해야 하는 예외
내부적으로 문제가 있다면 사용자에게는 에러를 직접 보여주면 안된다.
에러가 생겼으니 몇번 코드, 관리자에게 문의.. 이런식으로 뿌려줘야 한다?

이미지 하나가 없다면 xbox나옴
이때 default 객체 사용하면 최소한 xbox는 안나온다.
이런 행위에 대한 예외, 프로세스 상의 예외를 만들어서 사용하면 된다~
프로젝트에서 한 두개정도 만들어서 사용하면 좋을듯?

실무 전략
### 5.1 예외를 처리할 것인가, 전달할 것인가? 🤔

예외를 어떻게 처리할지는 예외의 종류와 발생한 로직의 역할에 따라 달라집니다.

- **예외를 잡아서 처리 (Catch and Handle)**: 해당 로직에서 **복구(Recovery)가 가능할 때** 사용합니다. 예를 들어, 파일을 읽다가 오류가 나면 기본 파일을 로드하는 대체 로직을 실행하는 경우입니다.
    
- **예외를 전달 (Propagate)**: 발생한 예외를 해당 로직에서 처리할 방법이 없거나, **상위 호출자가 처리하는 것이 더 의미 있을 때** 사용합니다. 예를 들어, 잔액 부족 예외를 상위 계층으로 전달하여 사용자에게 직접 알리는 경우입니다.
    

**💡 실용적인 조언**: **무책임하게 빈 `catch` 블록을 만들지 마세요.** 예외를 잡았다면 반드시 의미 있는 복구 로직을 추가하거나, 적절한 로그를 남겨야 합니다.

### 5.2 계층별 예외 변환과 책임 분리 🏛️

**컨트롤러에서 예외 메시지를 직접 결정하는 것은 좋은 설계가 아닙니다.** 예외 메시지는 비즈니스 로직을 담당하는 **서비스 계층에서 결정**하고, 컨트롤러는 이를 전달받아 응답을 포장하는 역할을 해야 합니다.

1. **서비스 계층**: 비즈니스 로직을 수행하고, 예외 객체에 **비즈니스 의미를 담는 책임**을 가집니다. (예: "잔액이 부족합니다")
    
2. **컨트롤러 계층**: 서비스 계층에서 던져진 예외를 잡아서, 해당 예외를 **HTTP 응답 형식으로 변환**하는 역할을 수행합니다.
    

이러한 방식은 코드의 응집도를 높이고 유지보수를 쉽게 만듭니다.

전역 예외 처리?
Spring Boot에서는 `@ControllerAdvice`와 `@ExceptionHandler`를 사용하여 전역 예외 처리를 구현할 수 있습니다. 또한 Spring Actuator를 통해 애플리케이션의 예외 통계를 모니터링할 수 있습니다.

### 예외 처리 성능 고려사항

- 예외 생성 시 스택 트레이스 수집 비용이 큼
- 예외를 제어 흐름으로 사용하면 성능 저하 심각
- 자주 발생하는 예외는 미리 생성해두고 재사용 고려
- `fillInStackTrace()` 오버라이드로 스택 트레이스 생성 생략 가능

### Checked vs Unchecked 선택 기준

- `Checked`: 호출자가 반드시 처리해야 하는 예외
- `Unchecked`: 프로그래밍 오류나 복구 불가능한 상황
- 최근 트렌드는 `Unchecked Exception` 선호 (Spring 등)
- API 설계 시 호출자의 부담을 고려

### 예외 변환(Exception Translation) 패턴

- 하위 계층의 예외를 상위 계층 예외로 변환
- 계층 간 결합도 감소
- 원인 예외(`cause`) 정보는 반드시 보존
- JPA의 `DataAccessException`이 좋은 예시

### 멀티스레드 환경에서의 예외 처리

- `UncaughtExceptionHandler`로 처리되지 않은 예외 관리
- `CompletableFuture`의 `exceptionally()` 활용
- 스레드 풀.에서 발생한 예외는 별도 처리 필요

---

컬렉션 프레임워크

## 📦 1. 컬렉션이 왜 필요한가?

### 1.1 배열의 한계

```java
// 배열의 문제점들
public class ArrayProblems {
    public static void main(String[] args) {
        // 1. 크기가 고정됨
        String[] students = new String[3];
        students[0] = "김철수";
        students[1] = "이영희";
        students[2] = "박민수";
        
        // 4번째 학생을 추가하려면? 😫
        // students[3] = "최영수"; // ArrayIndexOutOfBoundsException!
        
        // 2. 중복 체크가 어려움
        boolean isDuplicate = false;
        String newStudent = "김철수";
        for (String student : students) {
            if (student != null && student.equals(newStudent)) {
                isDuplicate = true;
                break;
            }
        }
        
        // 3. 삭제가 복잡함
        String[] newArray = new String[students.length - 1];
        int index = 0;
        for (String student : students) {
            if (!student.equals("이영희")) {
                newArray[index++] = student;
            }
        }
    }
}
```

### 1.2 컬렉션의 해결책

```java
import java.util.*;

public class CollectionSolution {
    public static void main(String[] args) {
        List<String> students = new ArrayList<>();
        
        // 1. 크기가 자동으로 늘어남
        students.add("김철수");
        students.add("이영희");
        students.add("박민수");
        students.add("최영수"); // 문제없음!
        
        // 2. 중복 체크가 간단
        boolean isDuplicate = students.contains("김철수"); // true
        
        // 3. 삭제가 간단
        students.remove("이영희"); // 한 줄로 해결!
        
        System.out.println("학생 수: " + students.size());
        System.out.println("학생 목록: " + students);
    }
}
```

> 💡 **부연설명**: 컬렉션은 크기 조절, 중복 관리, 검색, 정렬 등 배열로는 복잡한 작업들을 간단하게 해결해줍니다.

## 🌳 2. 컬렉션 계층구조

### 2.1 전체 구조 이해

```
Collection (인터페이스)
├── List (인터페이스)
│   ├── ArrayList (클래스)
│   ├── LinkedList (클래스)
│   └── Vector (클래스)
├── Set (인터페이스)
│   ├── HashSet (클래스)
│   ├── LinkedHashSet (클래스)
│   └── TreeSet (클래스)
└── Queue (인터페이스)
    ├── LinkedList (클래스)
    └── PriorityQueue (클래스)

Map (별도 인터페이스 - Collection을 상속하지 않음)
├── HashMap (클래스)
├── LinkedHashMap (클래스)
└── TreeMap (클래스)
```

| 컬렉션       | 중복허용   | 순서보장 | 주요특징        | 대표구현체      |
| --------- | ------ | ---- | ----------- | ---------- |
| **List**  | ⭕      | ⭕    | 인덱스 접근      | ArrayList  |
| **Set**   | ❌      | ❌    | 고유한 요소만     | HashSet    |
| **Queue** | ⭕      | ⭕    | FIFO 구조     | LinkedList |
| **Map**   | Value만 | ❌    | Key-Value 쌍 | HashMap    |

## 📋 3. List - 순서 있는 컬렉션

### 3.1 List의 특징

- **순서 보장**: 추가한 순서대로 저장
- **중복 허용**: 같은 값을 여러 번 저장 가능
- **인덱스 접근**: get(0), set(1, value) 등으로 접근

### 3.2 ArrayList vs LinkedList

#### ArrayList - 배열 기반

```java
import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        List<String> fruits = new ArrayList<>();
        
        // 추가
        fruits.add("사과");
        fruits.add("바나나");
        fruits.add("오렌지");
        fruits.add(1, "포도"); // 특정 위치에 삽입
        
        // 조회
        String first = fruits.get(0); // "사과"
        int size = fruits.size(); // 4
        
        // 검색
        boolean hasApple = fruits.contains("사과"); // true
        int index = fruits.indexOf("바나나"); // 2
        
        // 수정
        fruits.set(0, "청사과"); // 0번째를 "청사과"로 변경
        
        // 삭제
        fruits.remove(0); // 인덱스로 삭제
        fruits.remove("오렌지"); // 값으로 삭제
        
        System.out.println("과일 목록: " + fruits);
    }
}
```

#### LinkedList - 노드 기반

```java
public class LinkedListExample {
    public static void main(String[] args) {
        LinkedList<Integer> numbers = new LinkedList<>();
        
        // LinkedList만의 특별한 메서드들
        numbers.addFirst(10); // 맨 앞에 추가
        numbers.addLast(30);  // 맨 뒤에 추가
        numbers.add(20);      // 맨 뒤에 추가 (addLast와 같음)
        
        System.out.println("처음: " + numbers.getFirst()); // 10
        System.out.println("마지막: " + numbers.getLast()); // 30
        
        // 큐처럼 사용하기
        numbers.offer(40); // 뒤에 추가
        Integer first = numbers.poll(); // 앞에서 제거하고 반환
        
        System.out.println("제거된 값: " + first); // 10
        System.out.println("남은 값들: " + numbers); // [20, 30, 40]
    }
}
```

### 3.3 성능 비교와 선택 기준

|작업|ArrayList|LinkedList|언제 사용?|
|---|---|---|---|
|**조회** get(i)|O(1) 빠름|O(n) 느림|조회가 많으면 ArrayList|
|**맨 끝 추가**|O(1) 빠름|O(1) 빠름|차이 없음|
|**중간 삽입**|O(n) 느림|O(1) 빠름|삽입이 많으면 LinkedList|
|**삭제**|O(n) 느림|O(1) 빠름|삭제가 많으면 LinkedList|

```java
// 선택 가이드
public class ListChoiceGuide {
    public void demonstrateChoice() {
        // ✅ ArrayList 선택 - 조회가 많은 경우
        List<String> menuItems = new ArrayList<>();
        // 메뉴 아이템들 - 자주 조회, 거의 변경 안됨
        
        // ✅ LinkedList 선택 - 삽입/삭제가 많은 경우  
        LinkedList<String> taskQueue = new LinkedList<>();
        // 작업 큐 - 앞뒤로 자주 추가/제거
    }
}
```


## 🎒 4. Set - 중복 없는 컬렉션

### 4.1 Set의 특징

- **중복 불허**: 같은 값을 두 번 저장할 수 없음
- **순서 보장 안함**: HashSet은 저장 순서와 다를 수 있음
- **빠른 검색**: contains() 메서드가 매우 빠름

### 4.2 HashSet 활용

```java
import java.util.*;

public class HashSetExample {
    public static void main(String[] args) {
        Set<String> uniqueNames = new HashSet<>();
        
        // 추가
        uniqueNames.add("김철수");
        uniqueNames.add("이영희");
        uniqueNames.add("김철수"); // 중복 - 추가되지 않음
        uniqueNames.add("박민수");
        
        System.out.println("크기: " + uniqueNames.size()); // 3
        System.out.println("포함 여부: " + uniqueNames.contains("김철수")); // true
        
        // 순회 (순서 보장 안됨)
        for (String name : uniqueNames) {
            System.out.println(name);
        }
        
        // 삭제
        uniqueNames.remove("이영희");
        System.out.println("삭제 후: " + uniqueNames);
    }
}
```

### 4.3 Set의 실무 활용

```java
public class SetPracticalExample {
    
    // 중복 제거
    public List<String> removeDuplicates(List<String> list) {
        Set<String> uniqueSet = new HashSet<>(list);
        return new ArrayList<>(uniqueSet);
    }
    
    // 권한 체크
    public class UserService {
        private Set<String> adminUsers = new HashSet<>();
        
        public UserService() {
            adminUsers.add("admin");
            adminUsers.add("manager");
            adminUsers.add("supervisor");
        }
        
        public boolean hasAdminAccess(String userId) {
            return adminUsers.contains(userId); // O(1) 빠른 검색
        }
    }
    
    // 태그 시스템
    public class Article {
        private Set<String> tags = new HashSet<>();
        
        public void addTag(String tag) {
            tags.add(tag); // 중복 자동 제거
        }
        
        public boolean hasTag(String tag) {
            return tags.contains(tag);
        }
        
        public Set<String> getTags() {
            return new HashSet<>(tags); // 방어적 복사
        }
    }
    
    public static void main(String[] args) {
        SetPracticalExample example = new SetPracticalExample();
        
        // 중복 제거 테스트
        List<String> duplicateList = Arrays.asList("A", "B", "A", "C", "B");
        List<String> uniqueList = example.removeDuplicates(duplicateList);
        System.out.println("중복 제거: " + uniqueList); // [A, B, C] (순서는 다를 수 있음)
    }
}
```

### 4.4 TreeSet - 정렬된 Set

```java
import java.util.*;

public class TreeSetExample {
    public static void main(String[] args) {
        // 자동으로 정렬됨
        Set<Integer> sortedNumbers = new TreeSet<>();
        sortedNumbers.add(30);
        sortedNumbers.add(10);
        sortedNumbers.add(20);
        sortedNumbers.add(10); // 중복 - 무시됨
        
        System.out.println("정렬된 숫자: " + sortedNumbers); // [10, 20, 30]
        
        // 문자열도 자동 정렬
        Set<String> sortedNames = new TreeSet<>();
        sortedNames.add("Charlie");
        sortedNames.add("Alice");
        sortedNames.add("Bob");
        
        System.out.println("정렬된 이름: " + sortedNames); // [Alice, Bob, Charlie]
    }
}
```


## 🗃️ 5. Map - 키-값 저장소

### 5.1 Map의 특징

- **키-값 쌍**: 데이터를 연결해서 저장
- **키 중복 불허**: 같은 키로 두 번 저장하면 덮어씀
- **값 중복 허용**: 다른 키에 같은 값 저장 가능

### 5.2 HashMap 기본 사용법

```java
import java.util.*;

public class HashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> ageMap = new HashMap<>();
        
        // 추가
        ageMap.put("김철수", 25);
        ageMap.put("이영희", 30);
        ageMap.put("박민수", 28);
        ageMap.put("김철수", 26); // 덮어쓰기 - 25 → 26
        
        // 조회
        Integer age = ageMap.get("이영희"); // 30
        Integer unknownAge = ageMap.get("홍길동"); // null
        
        // null 안전한 조회
        Integer safeAge = ageMap.getOrDefault("홍길동", 0); // 0
        
        // 존재 여부 확인
        boolean hasKim = ageMap.containsKey("김철수"); // true
        boolean hasAge30 = ageMap.containsValue(30); // true
        
        // 크기
        System.out.println("사람 수: " + ageMap.size()); // 3
        
        // 삭제
        Integer removedAge = ageMap.remove("박민수"); // 28 반환
        
        System.out.println("나이 맵: " + ageMap);
    }
}
```

### 5.3 Map 순회하기

```java
public class MapIteration {
    public static void main(String[] args) {
        Map<String, String> capitals = new HashMap<>();
        capitals.put("한국", "서울");
        capitals.put("일본", "도쿄");
        capitals.put("중국", "베이징");
        
        // 방법 1: keySet() 사용
        System.out.println("=== 키로 순회 ===");
        for (String country : capitals.keySet()) {
            String capital = capitals.get(country);
            System.out.println(country + "의 수도: " + capital);
        }
        
        // 방법 2: entrySet() 사용 (더 효율적)
        System.out.println("=== Entry로 순회 ===");
        for (Map.Entry<String, String> entry : capitals.entrySet()) {
            System.out.println(entry.getKey() + " → " + entry.getValue());
        }
        
        // 방법 3: values()만 필요한 경우
        System.out.println("=== 값만 순회 ===");
        for (String capital : capitals.values()) {
            System.out.println("수도: " + capital);
        }
    }
}
```

### 5.4 Map의 실무 활용

```java
public class MapPracticalExample {
    
    // 카운팅
    public Map<String, Integer> countWords(String text) {
        Map<String, Integer> wordCount = new HashMap<>();
        String[] words = text.split("\\s+");
        
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }
        
        return wordCount;
    }
    
    // 그룹핑
    public Map<String, List<String>> groupByFirstLetter(List<String> names) {
        Map<String, List<String>> groups = new HashMap<>();
        
        for (String name : names) {
            String firstLetter = name.substring(0, 1);
            
            // computeIfAbsent: 키가 없으면 새 리스트 생성
            groups.computeIfAbsent(firstLetter, k -> new ArrayList<>()).add(name);
        }
        
        return groups;
    }
    
    // 캐시 구현
    public class SimpleCache<K, V> {
        private Map<K, V> cache = new HashMap<>();
        
        public V get(K key) {
            return cache.get(key);
        }
        
        public void put(K key, V value) {
            cache.put(key, value);
        }
        
        public void clear() {
            cache.clear();
        }
        
        public int size() {
            return cache.size();
        }
    }
    
    public static void main(String[] args) {
        MapPracticalExample example = new MapPracticalExample();
        
        // 단어 카운팅
        String text = "hello world hello java world";
        Map<String, Integer> wordCount = example.countWords(text);
        System.out.println("단어 빈도: " + wordCount);
        
        // 그룹핑
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Anna", "David");
        Map<String, List<String>> grouped = example.groupByFirstLetter(names);
        System.out.println("첫 글자별 그룹: " + grouped);
    }
}
```

## 🚶‍♂️ 6. Queue - 대기줄 컬렉션

### 6.1 Queue의 특징

- **FIFO**: First In, First Out (먼저 들어온 것이 먼저 나감)
- **양쪽 끝 접근**: 한쪽으로 추가, 다른 쪽으로 제거
- **null 비허용**: null 값을 저장할 수 없음

### 6.2 Queue 기본 사용법

```java
import java.util.*;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        
        // 추가 (뒤쪽에)
        queue.offer("첫 번째");
        queue.offer("두 번째");
        queue.offer("세 번째");
        
        System.out.println("큐 내용: " + queue); // [첫 번째, 두 번째, 세 번째]
        
        // 조회 (맨 앞 확인, 제거 안함)
        String front = queue.peek(); // "첫 번째"
        System.out.println("맨 앞: " + front);
        System.out.println("크기: " + queue.size()); // 3 (변화 없음)
        
        // 제거 (맨 앞에서)
        String removed = queue.poll(); // "첫 번째" 제거하고 반환
        System.out.println("제거된 것: " + removed);
        System.out.println("남은 것: " + queue); // [두 번째, 세 번째]
        
        // 비어있을 때
        Queue<String> emptyQueue = new LinkedList<>();
        System.out.println("빈 큐 peek: " + emptyQueue.peek()); // null
        System.out.println("빈 큐 poll: " + emptyQueue.poll()); // null
    }
}
```

### 6.3 Queue vs Stack

```java
import java.util.*;

public class QueueVsStack {
    public static void main(String[] args) {
        // Queue - FIFO (First In, First Out)
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);
        
        System.out.println("Queue (FIFO):");
        while (!queue.isEmpty()) {
            System.out.println(queue.poll()); // 1, 2, 3 순서
        }
        
        // Stack - LIFO (Last In, First Out)
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        
        System.out.println("Stack (LIFO):");
        while (!stack.isEmpty()) {
            System.out.println(stack.pop()); // 3, 2, 1 순서
        }
    }
}
```

### 6.4 실무 활용 예시

```java
public class QueuePracticalExample {
    
    // 작업 큐
    public class TaskQueue {
        private Queue<String> tasks = new LinkedList<>();
        
        public void addTask(String task) {
            tasks.offer(task);
            System.out.println("작업 추가: " + task);
        }
        
        public String processNext() {
            String task = tasks.poll();
            if (task != null) {
                System.out.println("작업 처리: " + task);
            }
            return task;
        }
        
        public int remainingTasks() {
            return tasks.size();
        }
    }
    
    // BFS 알고리즘에서 사용
    public void breadthFirstSearch() {
        Queue<String> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        
        queue.offer("시작노드");
        visited.add("시작노드");
        
        while (!queue.isEmpty()) {
            String current = queue.poll();
            System.out.println("방문: " + current);
            
            // 인접 노드들을 큐에 추가 (실제로는 그래프 구조 필요)
            // for (String neighbor : getNeighbors(current)) {
            //     if (!visited.contains(neighbor)) {
            //         queue.offer(neighbor);
            //         visited.add(neighbor);
            //     }
            // }
        }
    }
    
    public static void main(String[] args) {
        QueuePracticalExample example = new QueuePracticalExample();
        
        // 작업 큐 테스트
        TaskQueue taskQueue = example.new TaskQueue();
        taskQueue.addTask("이메일 발송");
        taskQueue.addTask("보고서 생성");
        taskQueue.addTask("데이터 백업");
        
        while (taskQueue.remainingTasks() > 0) {
            taskQueue.processNext();
        }
    }
}
```

## 🔄 7. Iterator와 향상된 for문

### 7.1 컬렉션 순회 방법들

```java
import java.util.*;

public class IterationMethods {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("사과", "바나나", "오렌지");
        
        // 방법 1: 전통적인 for문 (인덱스 기반)
        System.out.println("=== 전통적인 for문 ===");
        for (int i = 0; i < fruits.size(); i++) {
            System.out.println(i + ": " + fruits.get(i));
        }
        
        // 방법 2: 향상된 for문 (for-each)
        System.out.println("=== 향상된 for문 ===");
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
        
        // 방법 3: Iterator 사용
        System.out.println("=== Iterator ===");
        Iterator<String> iterator = fruits.iterator();
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println(fruit);
        }
        
        // 방법 4: Stream 사용 (Java 8+)
        System.out.println("=== Stream ===");
        fruits.stream().forEach(System.out::println);
    }
}
```

### 7.2 Iterator의 장점

```java
public class IteratorAdvantages {
    
    // 안전한 삭제 - Iterator 사용
    public static void removeEvenNumbers(List<Integer> numbers) {
        Iterator<Integer> iterator = numbers.iterator();
        while (iterator.hasNext()) {
            Integer number = iterator.next();
            if (number % 2 == 0) {
                iterator.remove(); // 안전한 삭제
            }
        }
    }
    
    // 위험한 삭제 - 향상된 for문에서 컬렉션 수정
    public static void unsafeRemove(List<Integer> numbers) {
        // ❌ ConcurrentModificationException 발생 가능
        /*
        for (Integer number : numbers) {
            if (number % 2 == 0) {
                numbers.remove(number); // 위험!
            }
        }
        */
    }
    
    // 다양한 컬렉션에서 동일한 방식으로 순회
    public static void printAll(Collection<?> collection) {
        Iterator<?> iterator = collection.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
    
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        System.out.println("원본: " + numbers);
        
        removeEvenNumbers(numbers);
        System.out.println("짝수 제거 후: " + numbers); // [1, 3, 5]
        
        // 다양한 컬렉션에서 같은 방식으로 순회
        Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));
        Queue<String> queue = new LinkedList<>(Arrays.asList("X", "Y", "Z"));
        
        System.out.println("Set 출력:");
        printAll(set);
        
        System.out.println("Queue 출력:");
        printAll(queue);
    }
}
```

## 🛠️ 8. Collections 유틸리티 클래스

### 8.1 정렬과 검색

```java
import java.util.*;

public class CollectionsUtility {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6));
        System.out.println("원본: " + numbers);
        
        // 정렬
        Collections.sort(numbers);
        System.out.println("오름차순: " + numbers);
        
        Collections.sort(numbers, Collections.reverseOrder());
        System.out.println("내림차순: " + numbers);
        
        // 다시 오름차순으로 만들어서 검색 테스트
        Collections.sort(numbers);
        
        // 이진 검색 (정렬된 리스트에서만 사용)
        int index = Collections.binarySearch(numbers, 4);
        System.out.println("4의 위치: " + index);
        
        // 최댓값, 최솟값
        Integer max = Collections.max(numbers);
        Integer min = Collections.min(numbers);
        System.out.println("최댓값: " + max + ", 최솟값: " + min);
        
        // 섞기
        Collections.shuffle(numbers);
        System.out.println("섞은 후: " + numbers);
        
        // 뒤집기
        Collections.reverse(numbers);
        System.out.println("뒤집은 후: " + numbers);
    }
}
```

### 8.2 불변 컬렉션 생성

```java
public class ImmutableCollections {
    public static void main(String[] args) {
        List<String> mutableList = new ArrayList<>();
        mutableList.add("A");
        mutableList.add("B");
        mutableList.add("C");
        
        // 불변 리스트로 만들기
        List<String> immutableList = Collections.unmodifiableList(mutableList);
        
        try {
            immutableList.add("D"); // UnsupportedOperationException 발생
        } catch (UnsupportedOperationException e) {
            System.out.println("불변 리스트는 수정할 수 없습니다");
        }
        
        // 빈 컬렉션들
        List<String> emptyList = Collections.emptyList();
        Set<String> emptySet = Collections.emptySet();
        Map<String, String> emptyMap = Collections.emptyMap();
        
        // 싱글톤 컬렉션
        List<String> singletonList = Collections.singletonList("유일한 값");
        Set<String> singletonSet = Collections.singleton("유일한 값");
        
        System.out.println("싱글톤 리스트: " + singletonList);
        System.out.println("싱글톤 셋: " + singletonSet);
    }
}
```

### 8.3 컬렉션 변환과 조작

```java
public class CollectionConversion {
    public static void main(String[] args) {
        // 배열 → 리스트 변환
        String[] array = {"A", "B", "C"};
        List<String> list = Arrays.asList(array); // 고정 크기 리스트
        List<String> mutableList = new ArrayList<>(Arrays.asList(array)); // 가변 리스트
        
        // 리스트 → 배열 변환
        List<String> fruits = Arrays.asList("사과", "바나나", "오렌지");
        String[] fruitArray = fruits.toArray(new String[0]);
        
        // Set → List 변환
        Set<Integer> numberSet = new HashSet<>(Arrays.asList(3, 1, 4, 1, 5));
        List<Integer> numberList = new ArrayList<>(numberSet);
        
        // 빈도수 계산
        List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "banana", "apple");
        Map<String, Long> frequency = new HashMap<>();
        for (String word : words) {
            frequency.put(word, frequency.getOrDefault(word, 0L) + 1);
        }
        
        System.out.println("원본 배열: " + Arrays.toString(array));
        System.out.println("변환된 리스트: " + list);
        System.out.println("중복 제거된 숫자: " + numberList);
        System.out.println("단어 빈도: " + frequency);
    }
}
```

## 🎯 9. 컬렉션 선택 가이드

### 9.1 상황별 최적 컬렉션

```java
public class CollectionChoiceGuide {
    
    public void demonstrateChoices() {
        
        // 📝 학생 출석부 - 순서 중요, 중복 허용
        List<String> attendanceList = new ArrayList<>();
        attendanceList.add("김철수");
        attendanceList.add("이영희"); 
        attendanceList.add("김철수"); // 지각으로 또 체크
        
        // 👥 동아리 회원 - 중복 불허, 빠른 검색
        Set<String> members = new HashSet<>();
        members.add("김철수");
        members.add("이영희");
        members.add("김철수"); // 무시됨
        
        // 📞 전화번호부 - 이름으로 번호 찾기
        Map<String, String> phoneBook = new HashMap<>();
        phoneBook.put("김철수", "010-1234-5678");
        phoneBook.put("이영희", "010-9876-5432");
        
        // 🏪 주문 대기줄 - 순서대로 처리
        Queue<String> orderQueue = new LinkedList<>();
        orderQueue.offer("햄버거 주문");
        orderQueue.offer("피자 주문");
        
        // 🎯 검색 성능이 중요한 경우
        Set<String> blacklist = new HashSet<>(); // O(1) 검색
        blacklist.add("spammer1");
        blacklist.add("spammer2");
        
        // 사용자 검증 시 빠른 검색
        String userId = "user123";
        if (blacklist.contains(userId)) {
            System.out.println("차단된 사용자입니다");
        }
    }
    
    // 🔍 성능 비교 예시
    public void performanceComparison() {
        int size = 100000;
        
        // List vs Set 검색 성능
        List<Integer> list = new ArrayList<>();
        Set<Integer> set = new HashSet<>();
        
        // 데이터 준비
        for (int i = 0; i < size; i++) {
            list.add(i);
            set.add(i);
        }
        
        int target = size - 1; // 마지막 요소 검색
        
        // List 검색 (O(n))
        long startTime = System.nanoTime();
        boolean foundInList = list.contains(target);
        long listTime = System.nanoTime() - startTime;
        
        // Set 검색 (O(1))
        startTime = System.nanoTime();
        boolean foundInSet = set.contains(target);
        long setTime = System.nanoTime() - startTime;
        
        System.out.printf("List 검색 시간: %d ns\n", listTime);
        System.out.printf("Set 검색 시간: %d ns\n", setTime);
        System.out.printf("성능 차이: %.1f배\n", (double) listTime / setTime);
    }
}
```

### 9.2 컬렉션 결정 플로우차트

```java
public class CollectionDecisionHelper {
    
    public String recommendCollection(boolean needsOrder, boolean allowsDuplicates, 
                                    boolean needsKeyValuePair, boolean needsFIFO) {
        
        if (needsKeyValuePair) {
            return "Map을 사용하세요 (HashMap이 일반적)";
        }
        
        if (needsFIFO) {
            return "Queue를 사용하세요 (LinkedList로 구현)";
        }
        
        if (allowsDuplicates && needsOrder) {
            return "List를 사용하세요 (ArrayList가 일반적)";
        }
        
        if (!allowsDuplicates) {
            if (needsOrder) {
                return "TreeSet을 사용하세요 (정렬된 순서)";
            } else {
                return "HashSet을 사용하세요 (빠른 검색)";
            }
        }
        
        return "상황을 다시 분석해보세요";
    }
    
    public static void main(String[] args) {
        CollectionDecisionHelper helper = new CollectionDecisionHelper();
        
        System.out.println("학생 출석부: " + 
            helper.recommendCollection(true, true, false, false));
        
        System.out.println("회원 목록: " + 
            helper.recommendCollection(false, false, false, false));
        
        System.out.println("전화번호부: " + 
            helper.recommendCollection(false, false, true, false));
        
        System.out.println("작업 대기열: " + 
            helper.recommendCollection(true, true, false, true));
    }
}
```

## 🐛 10. 자주하는 실수와 해결책

### 10.1 컬렉션 사용 시 주의사항

```java
public class CollectionPitfalls {
    
    public void demonstrateCommonMistakes() {
        
        // ❌ 실수 1: 반복 중 컬렉션 수정
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        // 위험한 방법 - ConcurrentModificationException 가능
        /*
        for (Integer num : numbers) {
            if (num % 2 == 0) {
                numbers.remove(num); // 위험!
            }
        }
        */
        
        // ✅ 안전한 방법 1: Iterator 사용
        Iterator<Integer> iterator = numbers.iterator();
        while (iterator.hasNext()) {
            Integer num = iterator.next();
            if (num % 2 == 0) {
                iterator.remove(); // 안전!
            }
        }
        
        // ✅ 안전한 방법 2: 역순 인덱스
        numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        for (int i = numbers.size() - 1; i >= 0; i--) {
            if (numbers.get(i) % 2 == 0) {
                numbers.remove(i);
            }
        }
        
        // ❌ 실수 2: == 로 객체 비교
        List<String> list1 = Arrays.asList("A", "B");
        List<String> list2 = Arrays.asList("A", "B");
        
        System.out.println("== 비교: " + (list1 == list2)); // false
        System.out.println("equals 비교: " + list1.equals(list2)); // true
        
        // ❌ 실수 3: null 체크 없이 사용
        Map<String, String> map = new HashMap<>();
        map.put("key1", "value1");
        
        String value = map.get("nonexistent"); // null 반환
        // System.out.println(value.length()); // NullPointerException!
        
        // ✅ 올바른 방법
        if (value != null) {
            System.out.println(value.length());
        }
        
        // 또는 기본값 사용
        String safeValue = map.getOrDefault("nonexistent", "default");
        System.out.println("안전한 값: " + safeValue);
    }
}
```

### 10.2 메모리 누수 방지

```java
public class MemoryLeakPrevention {
    
    // ❌ 메모리 누수 위험
    private static List<String> cache = new ArrayList<>();
    
    public void addToCache(String data) {
        cache.add(data); // 계속 쌓이기만 함
    }
    
    // ✅ 크기 제한이 있는 캐시
    private static final int MAX_CACHE_SIZE = 1000;
    private List<String> limitedCache = new ArrayList<>();
    
    public void addToLimitedCache(String data) {
        if (limitedCache.size() >= MAX_CACHE_SIZE) {
            limitedCache.remove(0); // 가장 오래된 것 제거
        }
        limitedCache.add(data);
    }
    
    // ✅ WeakHashMap 사용 (가비지 컬렉션에 협조적)
    private Map<String, String> weakMap = new WeakHashMap<>();
    
    public void demonstrateWeakMap() {
        String key = new String("key"); // new로 생성하여 GC 대상으로 만듦
        weakMap.put(key, "value");
        
        System.out.println("값 존재: " + weakMap.containsKey("key"));
        
        key = null; // 참조 제거
        System.gc(); // 가비지 컬렉션 요청
        
        // 시간이 지나면 WeakHashMap에서도 제거될 수 있음
    }
}
```
### 컬렉션 내부 구조

- **ArrayList**: 내부적으로 Object[] 배열 사용, 기본 크기 10, 75% 찰 때 1.5배 확장
- **LinkedList**: 이중 연결 리스트, 각 노드가 prev/next 포인터 보유
- **HashMap**: 해시 테이블 + 연결 리스트/트리 구조 (Java 8+), 로드 팩터 0.75
- **TreeSet/TreeMap**: Red-Black Tree (자가 균형 이진 검색 트리)

### 시간 복잡도 정리

- **ArrayList**: get/set O(1), add/remove(끝) O(1), add/remove(중간) O(n)
- **LinkedList**: get/set O(n), add/remove(시작/끝) O(1), add/remove(중간) O(1)*
- **HashSet/HashMap**: add/remove/contains 평균 O(1), 최악 O(n)
- **TreeSet/TreeMap**: 모든 연산 O(log n)

### 동시성 고려사항

- **Vector, Hashtable**: 구식 동기화 컬렉션 (성능 저하)
- **Collections.synchronizedXxx()**: 래퍼 방식 동기화
- **ConcurrentHashMap**: 모던 동시성 컬렉션 (세그먼트 락킹)
- **CopyOnWriteArrayList**: 읽기 위주 시나리오용

### 메모리 효율성

- **ArrayList vs LinkedList**: ArrayList가 메모리 효율적 (포인터 오버헤드 없음)
- **HashMap**: 초기 용량 설정으로 리해싱 비용 절약
- **EnumSet**: enum 전용, 비트 벡터로 구현되어 매우 효율적

---
디자인패턴 맛보기

1. **팩토리 패턴**: 객체 생성을 전담하는 공장, "어떤 객체를 만들까?"
#### 언제 사용하나요?

- 객체 생성 로직이 복잡할 때
- 생성할 객체의 타입을 런타임에 결정할 때
- 객체 생성 방식을 숨기고 싶을 때

1. **싱글톤 패턴**: 전체 앱에서 하나만 존재, "전역 관리자"
#### 언제 사용하나요?

- 설정 정보를 관리할 때
- 데이터베이스 연결 풀을 관리할 때
- 로그 관리자가 필요할 때
- 캐시 시스템을 구현할 때

1. **옵저버 패턴**: 변화를 구독자들에게 알림, "방송국과 시청자"
#### 언제 사용하나요?

- 한 객체의 상태 변화를 여러 객체에 알려야 할 때
- 이벤트 처리 시스템을 만들 때
- GUI에서 버튼 클릭 등의 이벤트를 처리할 때

2. **빌더 패턴**: 복잡한 객체를 단계적으로 생성, "레고 조립하기"
#### 언제 사용하나요?

- 생성자에 매개변수가 너무 많을 때
- 선택적 매개변수가 많을 때
- 객체 생성 과정이 복잡할 때

