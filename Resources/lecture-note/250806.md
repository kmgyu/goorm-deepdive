static에 대용량 객체 집어넣지 마셈
static은 thread-safe하지도 않다.
값 변경을 하면서 쓰겠다고 만들게된다?
A에서 변경 시 B는 원치않은 시점에 변경이 되는 수가 있다
어제 스터디에서 했던 내용이 그대로 나온다.

컬렉션
구현체로 설명해주신다.
인터페이스 있는데 구현체랑 구분해서 설명해주면 좀 더 좋겠는데에


에너그램 검사?
실무에서 언제 필요한지 모르겠다.
왜 필요한거지...

실제 업무에서는 라이브러리 쓰는 게 대부분
성능 분석이나 동료 소통, 면접 시에 필요하므로 알아두는 게 좋다.

정렬은 DB에서 하는게 더 빠르고 효율적임.

```java
// 1. 캐시된 데이터 가공
List<User> cachedUsers = redisTemplate.get("users");
return cachedUsers.stream()
    .filter(user -> isVIP(user))  // 복잡한 비즈니스 로직
    .sorted(Comparator.comparing(User::getLastLoginDate).reversed())
    .collect(toList());

// 2. API 응답 데이터 변환
List<ProductResponse> responses = products.stream()
    .map(this::convertToResponse)  // 데이터 변환
    .filter(resp -> resp.isAvailable())  // 복잡한 조건
    .collect(toList());

// 3. 메모리 내 계산
List<RecommendationScore> scores = calculateScores(userHistory);
return scores.stream()
    .sorted(Comparator.comparing(RecommendationScore::getScore).reversed())
    .limit(10)
    .collect(toList());
```

가끔하는 것들이라고 함.


OOP?
코드 간소화

누가 정립한 건 아니고 하다보니 개념을 정리하게 되었다고 함.

OOP 초기 세팅 복잡함으로 인해 함수형 프로그래밍 재부상
멀티패러다임 언어들?
자바 람다식 같이 여러 패러다임 조합이 나오기 시작함.
OOP는 버리지 않는다.

다중상속이 필요했던 이유 -> 현실세계는 다중 특성을 가짐
다이아몬드 문제 -> 생성자/소멸자 순서 관리 지옥, 메서드 호출 시 모호성 등...

java의 해결책 : 단일상속 + 인터페이스

*Exception? 컴파일러가 발견한 예외사항*
*근데 런타임에도 JIT 컴파일러 있지 않나?*
*TODO : Exception과 runtime error, 자바 컴파일러&인터프리터*

자바로 짠다고 다 OOP는 아니다.

다형성
- 같은 인터페이스로 다른 구현
인터페이스로 스펙을 정의해두면 구현체가 해당 기능을 구현한다.
스프링은 hibernate. 근데 다른 구현체로 바꾸기만 하더라도 기능 자체는 같으면서 어... 뭐라하지 성능? 목적? 드라이버? 아무튼 다르다
그래서 인터페이스를 잘 써야 한다~

다 정해진 관례 안에서 행동할 것이기 때문에 생각할 일이 별로 없음.
하다보면 원칙을 왜 정했는지 이해해야하는 시점이 온다?

클린코드 책 읽어보는 것도 좋음.
그렇구나~ 하고 넘어가는 경험보다 히스토리나 목적을 알고 가는 것이 좋다.

서비스 운영하는 현업에서는 상속과 인터페이스 구조가 있을 거임.
SI는 이렇게까지 하지 않고 오직 속도 중시

Struts가 스프링 이전에 실용적으로 많이 쓰고 유명했다.
근데 서비스단에 자꾸 인터페이스를 만듬.
일반 crud 웹페이지 만드는 건데 왜만드는지 몰라레후
아 귀찮아 해서 들어낸 경우가 있다.

단순한 것들은 굳이 인터페이스를 만들지 않는 것도 트렌드!
습관적인 인터페이스 만드는 것에 대한 것이 FM대로 하지 않고 줄어들고 있다...

InstanceOf?

타입 안정성 보장
잘못된 캐스팅으로 인한 ClassCastException을 방지한다.
정말 이 객체가 내가 원하는 객체인지 한번 확인해줌.
하나의 변수로 여러 타입 처리 시 구분

```java
// 예시: 3가지 목적이 모두 드러나는 코드
public void processData(Object data) {  // 다형성: 모든 타입 받기
    
    // 목적 1: 타입 안전성 - 캐스팅 전 확인
    if (data instanceof String) {
        String text = (String) data;  // 안전한 캐스팅
        System.out.println("문자열 길이: " + text.length());
        
    // 목적 2: 다형성 - 타입별 다른 처리  
    } else if (data instanceof Integer) {
        Integer number = (Integer) data;
        System.out.println("숫자 값: " + number);
        
    // 목적 3: 런타임 타입 확인 - 실행 중에 타입 판별
    } else {
        System.out.println("알 수 없는 타입: " + data.getClass().getName());
    }
}
```

instanceof은 여전지 중요하지만, generic이라는 개념이 나와버림.

면접?
객체와 인스턴스 차이? -> 동일개념입니다. -> 보통 한번 더 파고듬

SOLID는 지키려고 해보샘
아니면 리팩토링하는 느낌으로다가..

인터페이스를 적극적으로 사용하는 회사가 있을 거임
solid 머리에 넣어둬라

todo : solid 개념 정리 및 참고자료 찾아보기

