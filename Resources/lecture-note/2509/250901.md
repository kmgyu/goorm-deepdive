실습 주

관련 문서
[[8. spring-mvc-webpage]]

프로젝트에서 도구를 사용할 때, 내가 사용하지 않는 것과 사용하는 것의 차이점을 알아야 한다.

nexus 쓰면 센트럴 접근 못함, 도커 대신 포드맨 쓰면 그 차이점이 뭔지 등...

```html
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
```

xmlns는 생략 가능하나, 해주는 것이 좋음.


th:utext
html 태그 그대로 적용됨.
보안을 위해 필터 씌워서 방지할 수 있는 것으로 알고있다.

리터럴
```html
<!-- 방법 1: + 연산자 사용 -->
<p th:text="'안녕하세요, ' + ${username} + '님!'">인사말</p>

<!-- 방법 2: |...| 리터럴 사용 (추천) -->
<p th:text="|안녕하세요, ${username}님!|">인사말</p>
```


@{...} 형식의 동적경로 장점
contextPath가 붙기 때문.

케이스로 비교
~/posts 접근 시
context URL : localhost:8080/app 
정적 경로 : localhost:8080/posts
동적 경로 : localhost:8080/app/posts


분기문에서 논리 연산자는 and or not 을 사용한다.

메시지 처리?
```html
<!-- 에러 메시지 표시 -->
<div th:if="${error}" class="error-message">
    <p th:text="${error}">오류 메시지</p>
</div>

<!-- 성공 메시지 표시 -->
<div th:if="${success}" class="success-message">
    <p th:text="${success}">성공 메시지</p>
</div>
```

백엔드에서 담아서 던져주면 타임리프는 뱉어내기만 하면 된다.


루프문
기본
```html
<table>
    <tr th:each="post : ${posts}">
        <td th:text="${post.id}">1</td>
        <td th:text="${post.title}">제목</td>
        <td th:text="${post.author}">작성자</td>
    </tr>
</table>
```

status를 이용한 반복상태 활용
```html
<table>
    <tr th:each="post, status : ${posts}">
        <td th:text="${status.count}">순번</td>        <!-- 1부터 시작 -->
        <td th:text="${status.index}">인덱스</td>       <!-- 0부터 시작 -->
        <td th:text="${post.title}">제목</td>
        <td th:text="${status.first ? '첫번째' : ''}">첫번째</td>
        <td th:text="${status.last ? '마지막' : ''}">마지막</td>
    </tr>
</table>
```
프로젝트에서 descending 기준으로 하는데, 번호가 박살날 수 있다.

해결법
1. **DB에서 정렬만 내림차순 처리**
    
    ```sql
    SELECT * FROM posts ORDER BY id DESC;
    ```
    
    → 이 상태에서 Thymeleaf에서
    
    ```html
    <td th:text="${status.count}">순번</td>
    ```
    
    → 출력: `1, 2, 3 ...` (id는 10, 9, 7, 6…이더라도 순번은 연속됨)
    
2. **총 개수 기반 내림차순 순번**
    
    ```html
    <td th:text="${total - status.index}">순번</td>
    ```
    
    → 출력: `10, 9, 8 ...` (전체 개수를 기준으로 역순 번호)
    



객체 연결 폼

```java
@GetMapping("/posts/new")
public String newPost(Model model) {
    // 빈 Post 객체를 모델에 추가 (폼과 연결하기 위해)
    model.addAttribute("post", new Post());
    return "post/form";
}
```


```html
<!-- th:object로 폼과 객체 연결 -->
<form th:action="@{/posts}" th:object="${post}" method="post">
    <!-- th:field는 객체의 필드와 자동 연결 -->
    <!-- *{title}은 post.title과 같음 -->
    <input type="text" th:field="*{title}" placeholder="제목">
    <!-- 자동으로 name="title", id="title" 생성 -->
    
    <input type="text" th:field="*{author}" placeholder="작성자">
    <!-- 자동으로 name="author", id="author" 생성 -->
    
    <textarea th:field="*{content}" placeholder="내용"></textarea>
    <!-- 자동으로 name="content", id="content" 생성 -->
    
    <button type="submit">저장</button>
</form>
```


