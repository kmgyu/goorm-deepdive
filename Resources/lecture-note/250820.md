오늘 미션은 로그인 및 회원가입

테일윈드? 아ㅣㅇ에에에엣????
develop2 단계에서는 테일윈드 쓰니까 그거 적용해줘야됌
develop1은 html로 되있다.


---

오늘은 로그인 보안인듯

session
http는 요청, 응답이 한 사이클로 끝난다.
서버는 이전 요청을 기억하지 않음.

상태가 없는데 요청과 응답은 연결되어있다. (요청-응답이 한 사이클임.)


세션 핵심 개념
- 한 사용자의 여러 요청을 **하나의 맥락**으로 묶는 서버측 상태 관리.
- 서버는 사용자별 **세션ID**를 발급하고, 저장소(메모리/DB/Redis)에
  `[세션ID → 사용자 상태]`를 보관.
- 클라이언트는 매 요청마다 세션ID를 보내서 자신을 식별.

> HTTP가 기억을 못해주니 이런 세션을 이용해 식별한다.

jwt는 토큰 발행, 매 요청마다 전송.
매 요청마다 전송하는 건 똑같다.


세션과 쿠키

쿠키
브라우저 로컬에 저장되는 작은 데이터.
서버가 Set-Cookie로 저장하라고 지시함.
세션 ID는 보통 쿠키에 저장. 브라우저가 자동 첨부함.
쿠키가 위험하다는 오해의 대부분은 광고용 서드파티 쿠키 때문! (사용자의 온라인 활동 추적시 사용... 여러 웹사이트 다니는 걸 기록함.)
이번에 실습할 퍼스트파티 세션 쿠키는 표준이며 안전하게 사용 가능?
- 그럼 서드파티 퍼스트파티 무슨 차이가 있지?

위험이 생기는 원리 (내 쿠키 뺏어가는 방법)
http로 전송 시 도청 (https로 암호화로 대응. 이건 기본이다.)
xss로 document.cookie 탈취 가능 (httponly 세팅으로 대응. 이러면 js가 작동안해서 차단된다.)
CSRF 위협 (SameSite 세팅으로 대응. 같은 도메인 아니면 접근 불가)

원칙은 쿠키에 민감정보 저장을 하지 않는 것.. 세션ID 같은 식별자만 저장한다.


저장방식과 확장성
- 서버 메모리: 간단/빠름, 재시작 시 소실.
- DB/Redis: 다중 서버 공유, 무중단/확장성 우수.
- Sticky Session: 같은 사용자를 같은 서버로 → 장애/스케일링 시 제약 존재.


보안 & 무효화
어떤 이유로든 공격자가 세션 ID를 탈취한다면, 공격자가 사용자 행세 가능.
PC방에서 로그인 유지하고 나간다던가...
이에 대한 서버 측의 대응? 해당 세션을 invalidate()하면 즉시 차단

그래서 화이트리스트 같은 것을 추가해서 접근 통제할 수도 있다.

토큰 기반 인증 개념 요약
상태를 클라이언트(토큰)에 담고, 서버는 검증만 수행(서명/만료 등).
- Payload엔 `sub(userId)`, `roles/scope`, `exp`, `iss`, `iat` 등 메타 포함.
- 장점: 서버 Stateless → 확장성 최고.
- 단점: 토큰 탈취 시 **만료 전까지 악용**. 즉시 무효화 어렵고, 블랙리스트 관리가 필요.

| 구분      | 세션 기반              | 토큰(JWT) 기반             |
| ------- | ------------------ | ---------------------- |
| 저장 위치   | 서버 상태(세션 저장소)      | 클라이언트(토큰에 정보 포함)       |
| 탈취 시    | 세션 삭제로 **즉시 차단**   | 만료까지 사용될 수 있어 제어 난이도 ↑ |
| 즉시 로그아웃 | **쉽다**(invalidate) | 어렵다(블랙리스트/버전 관리 필요)    |
| 확장성     | 저장소/동기화 부담         | **우수**(Stateless)      |

`cookie.setSecure(true)` 는 HTTP에서 어떻게 되나?

- **의미**: 이 쿠키는 **HTTPS 연결에서만** 전송하라(브라우저 규칙).
- **HTTP(암호화 없는) 요청**에서는 **브라우저가 쿠키를 보내지 않는다**.
    - 결과: 로컬 개발이 `http://localhost:8080` 등 HTTP라면,  
        `JSESSIONID`가 **요청에 안 붙어서 로그인 유지가 안 되는 것처럼 보일 수 있음**.
        
- **실무 팁**:
    - 로컬/개발환경에선 **`Secure=false`** 로 두거나,
    - 로컬 HTTPS(셀프사인)로 기동, 혹은 프록시(ngrok/Traefik/DevCert)로 HTTPS 터미네이션.
    - 환경별 설정 분리:
        - `dev`: Secure=false
        - `prod`: Secure=true(필수)



쿠키 속성은 개발자가 설정한다 

```java
Cookie cookie = new Cookie("JSESSIONID", session.getId());
cookie.setHttpOnly(true);
cookie.setSecure(true);       // prod에서
cookie.setPath("/");
cookie.setMaxAge(-1);         // 세션 쿠키(브라우저 종료 시 삭제)
resp.addCookie(cookie);
```

### Spring Boot(설정 파일로 간단)

```properties
# application-prod.properties (운영)
server.servlet.session.cookie.secure=true
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.same-site=strict
```

> 포인트: **브라우저가 임의 변경하는 게 아니라, 서버가 `Set-Cookie`로 내려주는 정책을 브라우저가 준수**한다.



최신 트렌드(2025)

- 전통 웹앱(SSR, 내부 관리): **세션 기반** 여전히 흔함.
- SPA/모바일/마이크로서비스: **토큰 기반** 선호(JWT + 짧은 만료, Refresh는 서버 관리).
- 브라우저 정책: 서드파티 쿠키 차단 강화(세션 쿠키 사용엔 지장 없음).
- 현실 조언: “둘 다 알아두고, **상황 맞춤 하이브리드**가 실무적.”

---
- **HTTP 기본 원리**:
    
    - 브라우저가 서버에 요청(Request) → 서버가 응답(Response)
    - 이 한 사이클이 끝나면 **연결(TCP socket)은 원칙적으로 끊어진다.**
        
- **특징**: HTTP는 **Stateless** (상태 없음).
    - 서버는 이전 요청과 다음 요청의 관계를 기억하지 않는다.

👉 “브라우저가 서버에 말을 걸면, 서버는 대답하고 문 닫습니다. 전통적인 HTTP는 ‘한 번의 질문, 한 번의 답변’ 구조입니다.”


TCP/IP 위에 HTTP 올라감.
OSI 7계층!

그래서 TCP 소켓이 열리고 3웨이 핸드세이킹하고 http 던지고 받고가 한사이클
근데 매요청마다 tcp 열면 성능 저하됨.

이미지를 요청하던가, 파일을 요청하던가. 이런 여러가지 리소스를 하나의 응답으로 보고 가져오면 tcp 성능이 저하된다.

http1.1부터는 keep alive라는 게 생김. 지속 연결 개념
별도 헤더 없이도 유지되서 서버가 close 보낼 때 끊긴다.

3-way handshake
client -> server : syn
server -> client : syn + ack
client -> server : ack
복습복습


TLS 핸드셰이크
https에서는 보안 채널을 먼저 만들어야 한다.
그래서 tls 핸드셰이크라는 과정을 거친다.
암호화 키 교환 및 서버 인증서 확인 과정

순서 (단순화 버전):
1. 클라이언트: “내가 지원하는 암호화 방식은 이거야”
2. 서버: “그럼 이 방식으로 하자, 그리고 이건 내 인증서야”
3. 서로 암호화 키를 교환 (보통 공개키/비밀키 방식)
4. 이후부터 모든 데이터는 암호화되어 전송됨


페이지 하나 불러오려고 **TCP Handshake + TLS Handshake**를 매번 하면 너무 느려요.
그래서 **Keep-Alive**로 연결을 유지하거나, **HTTP/2**로 효율을 높이는 게 필요합니다.


- **Keep-Alive (Persistent Connection)**
    - 한 번 TCP 연결을 맺고, 여러 요청/응답을 재사용
- 즉, 별도 헤더가 없어도 기본은 keep-alive이며, 
  호환성을 위해 `Connection: keep-alive` 헤더가 추가로 보이는 경우가 많음.

- `Keep-Alive: timeout=20, max=100`
    - 20초 동안 유지
    - 최대 100개의 요청까지만 재사용
이런 건 운영 서버에서 하는 것.

keep alive 필요한 이유?

| 구분              | 알아야 하는 이유                      |
| --------------- | ------------------------------ |
| **성능 디버깅**      | 페이지 느릴 때 원인이 TCP 재연결 때문일 수 있음  |
| **API 호출 최적화**  | 연속적인 API 호출에서 성능 차이 큼          |
| **부하 테스트/튜닝**   | JMeter 등에서 옵션에 따라 TPS 차이 발생    |
| **보안/운영 환경**    | 프록시·로드밸런서가 연결 끊을 때 원인 진단 가능    |
| **HTTP/2,3 이해** | Keep-Alive 개념이 확장되어 멀티플렉싱으로 발전 |

| 영역               | 개발자 제어 가능 여부 | 예시                                           |
| ---------------- | ------------ | -------------------------------------------- |
| **응답 헤더 설정**     | ✅ 가능         | `response.setHeader("Connection", "close");` |
| **API 클라이언트 옵션** | ✅ 가능         | HttpClient, OkHttp의 keep-alive 설정            |
| **프레임워크/WAS 설정** | ✅ 가능         | Spring Boot, Tomcat의 timeout 조정              |
| **TCP 연결 자체**    | ❌ 불가         | OS와 네트워크 스택 영역                               |
| **브라우저 동작 방식**   | ❌ 불가         | 브라우저는 HTTP/1.1 이상에서 기본 keep-alive            |
| **프록시/로드밸런서 정책** | ❌ 불가         | 인프라/네트워크 담당 영역                               |


네이버 예제

1. 브라우저에서 `https://www.naver.com` 접속
2. 개발자도구(F12) → **Network 탭** → 새로고침
3. 수십 개의 요청이 하나의 연결에서 처리되는 모습 확인
4. **개발자도구 Network 탭에서 `Protocol` 컬럼이 `h2`인지 확인**  
(HTTP/2에서는 `Connection`/`Keep-Alive` 헤더가 금지되어 보이지 않습니다)

👉 네이버는 **HTTP/2 기반**이라, 여러 요청이 동시에 처리되는 것(multiplexing)을 볼 수 있음

| 항목  | HTTP/1.1                              | HTTP/2                |
| --- | ------------------------------------- | --------------------- |
| 연결  | Keep-Alive로 요청을 순차 처리                 | 멀티플렉싱: 여러 요청을 동시에 처리  |
| 성능  | 요청이 많으면 지연 발생 (Head-of-Line Blocking) | 단일 연결에서 병렬 처리 가능      |
| 보안  | 평문/HTTPS 모두 가능                        | 브라우저는 사실상 HTTPS에서만 허용 |
| 기본값 | 서버/클라이언트 기본 프로토콜                      | 서버에서 명시적으로 활성화 필요     |


HTTP/2와 레거시 클라이언트

- 최신 브라우저: 대부분 HTTP/2 지원
- 구형 브라우저/일부 IoT 장비: HTTP/1.1만 지원 → 자동 fallback
- 따라서 서비스 운영 시 보통은 **HTTP/2 + HTTP/1.1 병행 지원**



### HTTP/2 활성화 조건 in SpringBoot

1. **HTTPS(TLS) 적용** 필수
2. `application.properties` 설정 추가

```properties
server.port=8443
server.http2.enabled=true

server.ssl.key-store=classpath:keystore.p12
server.ssl.key-store-password=비밀번호
server.ssl.key-store-type=PKCS12
```

👉 이렇게 하면 서버가 HTTP/2를 지원하고,  
브라우저가 지원한다면 **자동으로 HTTP/2로 업그레이드**됨 (negotiation)
서버와 클라이언트는 TLS 핸드셰이크 과정에서 ALPN 확장을 사용해 HTTP/2 지원 여부를 협상합니다


---

추가 태스크

마이페이지를 만들어 회원정보 수정하기

Step03
엉망진창이다.
insertBoard에서 사용자 아이디는 어떻게 넘겨주는가?

getBoardList에서 writer id에 유저 테이블은 왜 조인해주지? author 컬럼은 왜 남아있는가? 레거시 컬럼?
getBoard 메서드도 똑같다. 왜 조인을 해주지?
writer_name의 존재 이유가 뭔지 모르겠음.

