useMemo
-> memoization 생각하면 편하다.
이해가 쏚쏚 되잖아

useCallback
부모가 다시 렌더링되면 자식도 다시 렌더링된다.
이때 부모는 렌더링이 되더라도 함수는 바뀌지 않게 할 경우 사용한다.
ex) 카운팅하다가 새로고침하더라도 숫자가 유지됨.

커스텀 훅
규칙있음.

| 규칙                | 설명                                                    |
| ----------------- | ----------------------------------------------------- |
| **`use`로 시작해야 함** | React가 훅으로 인식하려면 반드시 `use`로 시작해야 합니다.                 |
| **조건문 안에서 사용 X**  | 기본 훅과 동일하게, **조건문, 반복문 안에서는 사용 금지**입니다.               |
| **다른 훅과 조합 가능**   | `useState`, `useEffect`, `useRef` 등을 자유롭게 사용할 수 있습니다. |


State Lifting
리액트는 부모 -> 자식이 기본적임.
근데 상태제어하면서 자식 -> 부모로 다시 끌어올릴 필요 있음.
상태 끌어올리기라고 부른다.

값이 바뀌면 리렌더링 -> 값이 바뀐다는 게 무엇을 의미할까?

```
    const nextSquares = squares.slice();
    nextSquares[i] = isXNext ? 'X' : 'O';
    setSquares(nextSquares);
    setIsXNext(!isXNext);
  }
```
이건 객체를 던진다.

이전 값과 setSquares를 통해 바뀐 값을 알아야 비교를 한다.
여기서도 얕은 비교와 깊은 비교라는 개념이 있다. 렌더링 관련 개념임
깊은 비교? 객체 다열어서 값 바뀐거 확인
얕은 비교? 숫자, 문자열 등 원시 자료형은 값 비교.
배열, 객체 등 참조 자료형 값 혹은 속성은 참조되는 위치를 비교한다.