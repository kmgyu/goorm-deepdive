리액트는 UI를 효율적이고 예측 가능하게 만드는 것.
어떤 생명주기를 가지는 프레임 워크같은 것이 아니다~

SWC? 컴파일러
babel and Vite

SWC/babel 둘 다 컴파일러의 일종
js꺼다?

예전 브라우저를 위해 최신 JS 문법을 변환해주는 기능도 있다.

SWC가 빨라서 요즘 트렌드라고 함.

App.jsx, index.jsx의 차이?

스타일 적용 시 범위에 차이점
index : 전역
app : 관련된 스타일 적용 범위. app과 그 직계 자식들

진입점인데 같은 거 아니냐?
실행 시점에서 차이있음.

|구분|index.css|App.css|
|---|---|---|
|**적용 범위**|전체 앱|App 컴포넌트 중심|
|**로드 시점**|앱 시작 시|App 컴포넌트 렌더링 시|
|**주요 용도**|전역 설정, 리셋, 변수|레이아웃, 컴포넌트별 스타일|
|**우선순위**|낮음 (먼저 로드됨)|높음 (나중에 로드됨)|


브라우저 캐싱 개념이 강해짐
받아오는 리소스가 커지다보니 웹쪽에서 이슈가 되서 강해진 부분 존재.
public 폴더



CSS 지시문
@utility의 경우 css를 사용해서 뭔가를 정의해서 새로운 태그 쓴다.
@theme, @variant, @custom-variant 등...


옵시디언 Mermaid도 지원한다... 짱이당.

csr? ssr?
seo가 읽는 시점에 따라 csr는 취약
js가 활동하는 것이기 때문에 FE 디바이스 성능에 의존

따라서 ssr이라는 개념이 만들어짐.
이때는 nodejs 서버가 중간에 필요해진다.
렌더링을 위한 일종의 미들웨어라고 봐야하나?
FE에 대한 책임을 지는 것 같음...!
웹서버는 Nginx라고 따로 표기해놓았다?


Headless Frontend?
mvc같은 전통적 형태가 아닌 것. headless BE도 있음!

Headless FE는 프론트엔드가 오직 API를 통해서만 데이터 받아 화면 구성하는 거임.


CORS?
사전 협의된 파트너십

원래 same origin만 승인하도록 보안 막아뒀는데, 정당한 요청이 생기기 시작하니까 이렇게 만듬.

### **해결 방법들** in Spring

#### Controller 설정

```java
@CrossOrigin(origins = "http://localhost:3000")
@RestController
public class UserController {
    // API 코드
}
```

#### 전역 설정

```java
@Configuration
public class WebConfig {
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedOrigins("http://localhost:3000");
            }
        };
    }
}
```



useEffect
```
  useEffect(() => {
    fetch("https://api.example.com/news")
      .then((res) => res.json())
      .then((json) => setData(json));
  }, []);
```
의존성 배열: useEffect 패러미터 마지막 비어있는 배열

특정 **상태나 props의 값이 변경될 때마다** 특정 작업을 수행하도록 하고 싶을 때 사용
