## 1. api/와 hooks/의 차이와 선택 기준

- **api/**:  
  - 실제로 API 호출(예: fetch, axios 등)을 담당하는 순수 함수 파일  
  - 예: `getProducts()`, `postOrder()` 등
- **hooks/**:  
  - React에서 API 호출과 상태 관리, 로딩/에러 처리 등을 캡슐화한 커스텀 훅  
  - 예: `useProducts()` (내부에서 api/products.js의 함수를 사용)

**권장 구조:**  
- api/에는 실제 API 호출 함수  
- hooks/에는 해당 API를 사용하는 커스텀 훅  
→ 둘 다 분리해서 관리하면 확장성과 재사용성이 높아집니다.


## 생각해볼 부분 1:  매번 api 접근의 비효율성


## 실제 API 캐싱/최적화 방법

### (1) 전역 상태 관리 라이브러리 사용

- React Query(TanStack Query), SWR 등
→ 내부적으로 API 응답을 메모리/스토리지에 캐싱, 자동 갱신, refetch 등 지원
→ 가장 많이 쓰이는 방식

### (2) 전역 상태(예: Context, Redux 등)에 저장

- 최초 한 번만 API 호출 후, 전역 상태에 저장
- 이후에는 상태에서 읽고, 필요시만 다시 fetch

### (3) localStorage/sessionStorage 활용

- 브라우저 저장소에 응답을 저장
- 새로고침해도 데이터 유지 가능
- 단, 데이터 최신화/동기화는 직접 관리해야 함

## 생각해볼 부분 2: goorm-shop\src\hooks\useProducts.js

현재의 useProducts 훅은 useState와 useEffect만으로 상태(로딩, 에러, 데이터)를 관리하고 있습니다.  
이 구조는 간단한 API fetch에는 충분하지만,  
**상태 변화가 더 복잡해지거나, 여러 액션/상태 전이가 필요할 때**는 useReducer를 사용하는 것이 더 적합할 수 있습니다.

## 언제 useReducer를 쓰는 게 좋은가?

- **상태가 여러 단계/종류로 복잡하게 변화할 때**
  - 예: 로딩, 성공, 실패, 리셋, 리프레시, 페이징 등 다양한 상태/액션이 필요할 때
- **상태 업데이트 로직이 복잡하거나, 여러 곳에서 상태를 변경해야 할 때**
- **여러 상태가 서로 연관되어 있을 때**

## 예시: useReducer가 적합한 상황

- 데이터 로딩, 에러, 성공, 리셋, 새로고침 등 다양한 액션이 필요할 때
- 여러 API 요청을 동시에 관리해야 할 때
- 상태 전이(transition) 로직이 복잡할 때

## 결론

- **지금처럼 단순한 fetch + 3가지 상태(로딩/에러/데이터)만 관리할 때는 useState로 충분**
- **상태 변화가 복잡해지면 useReducer로 리팩터링**  
  → 코드가 더 명확하고 유지보수하기 쉬워짐



콜백 지옥이라는 이슈가 있었음.
callback 개념에서 promise 나옴

function 오래 걸리는 걸 기다리고... 콜백 함수로 기다려도 어쩌고...
-> 지루하고 현학적임. 문법이 지저분함.
-> Promise 생김. 줄게 기다려

async, await으로 보내고 딴일하다가 받음.
-> 너 줄때까지 뒤에 실행 안함. 기다림.
-> 비동기 처리할 수 있음.



세션?
서버로 관리함

JWT라는 개념 생김
티켓 발급하고 잊어버림
접속량 많은 쪽은 이렇게 구현