Context Path 이해

### Context Path란?

- **정의**: 웹 애플리케이션의 URL 경로
- **예시**: `http://localhost:8080/myapp` → Context Path는 `/myapp`

### Context Path 설정 방법

**1. 폴더명으로 설정**

```
webapps/
├── ROOT/           → http://localhost:8080/
├── myapp/          → http://localhost:8080/myapp/
└── admin/          → http://localhost:8080/admin/
```

**2. WAR 파일명으로 설정**

```
webapps/
├── ROOT.war        → http://localhost:8080/
├── myapp.war       → http://localhost:8080/myapp/
└── shop.war        → http://localhost:8080/shop/
```

**3. Context 설정으로 변경**

```xml
<!-- conf/Catalina/localhost/custom.xml -->
<Context docBase="/path/to/myapp" path="/custom" />
```


war 배포

```bash
# hello 폴더로 이동
cd hello

# WAR 파일 생성
jar -cvf hello.war *

# 또는 zip 명령어 사용
zip -r hello.war *
```

```bash
# WAR 파일을 webapps에 복사
cp hello.war /path/to/tomcat/webapps/

# 톰캣 시작
./startup.sh

# 브라우저에서 확인
# http://localhost:8080/hello
```


일종의 압축이다.
war로 묶은 후, 카피해서 풀어준다?

매번 이렇게 하면 번거로우니 maven, gradle이 ci/cd 해서 빌드해준다.
근본적으로 동일한 행위?라고 함.

deploy된 jsp를 바꾸면 톰캣에서 페이지가 바뀐다.

실행한 터미널의 스레드로 생성되는 건가? 배치/배시 파일 실행한 터미널이 사라지면 톰캣 서버 죽는다고 함.

WAR 구조가 맞는 외부 소스로 연결도 가능하다.
```
<Context doBase = "D:\Workspace-groom\~"
path="/"
reloadable="true"/>
```
이런 식.

톰캣 배포하기
폴더 그대로 옮기기, root.war, 외부 소스 끌어오기 총 3가지 방법 존재.

---

JDBC, JdbcTemplate

| 시대            | 주류 기술                   | 특징               |
| ------------- | ----------------------- | ---------------- |
| **2000-2005** | 순수 JDBC                 | 모든 것을 직접 구현      |
| **2005-2010** | **JdbcTemplate 전성기**    | Spring의 혁신적 도구   |
| **2010-2015** | MyBatis vs JdbcTemplate | XML 기반 SQL 매핑 인기 |
| **2015-2020** | **JPA + Hibernate 대세**  | 객체 지향 패러다임 확산    |
| **2020-현재**   | **JPA + QueryDSL 표준**   | 타입 안전 + 동적 쿼리    |

Statement vs PreparedStatement vs JdbcTemplate

| 구분                   | Statement         | PreparedStatement | JdbcTemplate      |
| -------------------- | ----------------- | ----------------- | ----------------- |
| **SQL 파싱**           | 매번 파싱             | 한 번 파싱 후 재사용      | 한 번 파싱 후 재사용      |
| **성능**               | 낮음                | 높음                | 높음                |
| **SQL Injection 보안** | ❌ 취약              | ✅ 안전 (매개변수 사용 시)  | ✅ 안전              |
| **매개변수 설정**          | 문자열 조작            | 타입 안전한 메서드        | 타입 안전한 메서드        |
| **동적 SQL**           | 문자열 조작            | 매개변수 + 구조 조합      | 매개변수 + 구조 조합      |
| **자원 관리**            | 수동 (finally 블록)   | 수동 (finally 블록)   | ✅ 자동              |
| **예외 처리**            | Checked Exception | Checked Exception | Runtime Exception |
| **Spring 통합**        | 별도 설정             | 별도 설정             | ✅ 완벽 통합           |

- **Maven Central** = 중앙 저장소 (라이브러리와 메타데이터를 저장)
- **Maven** = 빌드 도구 1종 (Gradle, Ivy 등과 다른 도구)
- Gradle도 내부적으로 **Maven 형식의 저장소**를 사용 가능
- 그래서 Gradle 설정에서도 `mavenCentral()`를 선언하면 같은 곳에서 다운로드


prepareStatement는 입력을 문자열로 받아서 sql 인젝션 시도 시 잘못된 쿼리로 날아간다. 방어 보장?
캐싱도 좀 더 빨라짐.

JdbcTemplate
JDBC 추상화 클래스. 스프링 초기 핵심 데이터 액세스 기술
하이버네이트 무겁고 복잡했을 때 간단해서 쓰기 좋았음.
사장된 기술은 아닌데, 메인으로는 안쓰임.

복잡한 쿼리 쓸 시 JPA보다 편하다.

트랜잭션 관리
@Transactional을 이용해서 쿼리들을 하나의 트랜잭션으로 묶을 수 있음.
프로세스를 하나로 만들어준다는 소리. 와! 드디어 이해가 좀 가는 것 같아요.
왜 쿼리를 Transactional로 묶나 했네. 맨날 동시성이나 로킹 같은 것만 생각하다가 이거 생각하니 머리가 좀 맑아진듯? 일단 이 기능들도 있긴 할 거 같은데 찾아봐야 할듯

---

톰캣에 WAR 배포하기
안된다!
된다!
왜돼지?
주석 지웠더니 작동한다... 이런 쥐엔자아앙
주석으로 prepare statement 막아놓은 코드가 문제가 되었던 것으로 보인다.
오류코드도 없으니 화를 참을 수가 없!!!다!!!!!!
옛날 개발자들은 어떻게 버틴거임...