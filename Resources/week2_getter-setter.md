자바에서 **게터(getter)**와 **세터(setter)**는 클래스 내의 **필드(변수)**에 접근하고 수정하는 메서드입니다. 이 패턴은 **캡슐화(Encapsulation)**를 구현하는 핵심적인 방법으로, 객체 지향 프로그래밍의 중요한 원칙 중 하나입니다.

### 캡슐화와 게터/세터

게터/세터 패턴을 사용하는 가장 큰 이유는 **캡슐화**를 달성하기 위해서입니다. 캡슐화는 **데이터와 그 데이터를 다루는 함수를 하나로 묶는 것**을 의미합니다. 이를 통해 외부에서 클래스의 내부 상태에 직접 접근하는 것을 막고, 정해진 메서드를 통해서만 필드에 접근하도록 제어할 수 있습니다.

예를 들어, '나이'라는 필드를 가진 `Person` 클래스가 있다고 가정해 봅시다.

- **게터(Getter)**: 필드의 값을 **읽어오는** 역할을 합니다. 보통 `get`이라는 접두사를 사용하며, `getAge()`와 같이 필드 이름을 결합하여 만듭니다. 이 메서드는 단순히 `age` 필드의 현재 값을 반환합니다.
    
- **세터(Setter)**: 필드의 값을 **설정하는** 역할을 합니다. 보통 `set`이라는 접두사를 사용하며, `setAge(int age)`와 같이 필드 이름을 결합하여 만듭니다. 이 메서드를 통해 `age` 필드의 값을 새롭게 설정할 수 있습니다.
    


```Java
public class Person {
    private int age; // private 필드

    // 게터 메서드
    public int getAge() {
        return age;
    }

    // 세터 메서드
    public void setAge(int age) {
        if (age > 0) { // 유효성 검사 로직 추가 가능
            this.age = age;
        } else {
            System.out.println("나이는 0보다 커야 합니다.");
        }
    }
}
```

---

### 게터/세터 패턴의 장점

- **데이터 보호 및 유효성 검사**: 세터 메서드 내부에 필드 값에 대한 **유효성 검사 로직**을 추가할 수 있습니다. 예를 들어, `age` 필드에 음수 값이 할당되는 것을 막을 수 있습니다.
    
- **유연성**: 클래스의 내부 구현이 변경되어도, 게터와 세터의 **인터페이스(메서드 시그니처)**가 동일하다면 이를 사용하는 외부 코드는 영향을 받지 않습니다.
    
- **접근 제어**: 특정 필드는 세터만 제공하여 **쓰기**만 가능하게 하거나, 게터만 제공하여 **읽기**만 가능하게 할 수 있습니다. 혹은 둘 다 제공하지 않아 **외부 접근을 완전히 차단**할 수도 있습니다.
    
- **디버깅 용이성**: 필드에 접근하는 모든 로직이 특정 메서드에 집중되므로, 값의 변경을 추적하고 오류를 수정하기가 용이합니다.
    

이 패턴은 객체 지향 원칙을 지키며 안전하고 유지보수가 쉬운 코드를 만드는 데 필수적입니다. 최근에는 롬복(Lombok)과 같은 라이브러리를 사용해 게터와 세터 메서드를 자동으로 생성하는 경우가 많아, 코드를 더 간결하게 작성할 수 있습니다.


참고자료용

게터-세터를 지양해야 하는 이유
https://colabear754.tistory.com/173


