준원님 권한 설정 문제 컨트롤러 직접 접근해도 될까용

TODO (고도화)

1. 레디스 캐싱
2. Date 헤더 큐
3. 쿠폰 생성 후 발급 시간 스케줄러

### 레디스 캐싱

결제 트랜잭션 로직
일단 쿠폰 조회하게 하면 나중에 그 쿠폰 사용할 확률 높음.
그래서 레디스에서 캐싱을 해서 쿠폰 정보를 가져온다.
그거 끌어다 쓰면 된다. 끗!

### 요청 시간 큐

필터 단에서 사용해야 한다.
RequestDate 기반 우선순위 큐

메시징 큐도 생각을 해볼 수 있으나, 대기 순서가 보장되어야 함.
메시징 큐는 이런 면에서 사용하기 꺼려지는 선택지이다.

서버에서는 레디스를 캐싱을 위해 사용하고 있기에 카프카를 활용하기로 하였음. 이벤트 큐에 넣고, Request-Date를 우선순위로 가져오는 방식

> 현재 순서를 사용자에게 알려줘야 할까?
> 몰라. SSE 열어야됨? 굳이? 열어야 되긴 하네?
> FE 쪽이 받나?

https://devwinnie.tistory.com/15
https://hseong.tistory.com/94

### 발급 시간 스케줄러

스프링 쿼츠
레디스 pub/sub
카프카 스트림즈

선정을 위한 증거
https://taekt.tistory.com/39

그리고 아키텍처 복잡성과 안정성 때문에 메시징 큐는 사용하지 않는다.
배치 처리는 이거 대용량으로 생성하는 게 아니라 오버 스펙이다.

일단 프로젝트가 이벤트 기반으로 돌아가기 때문에 카프카가 가장 적합하다고 판단함. 특정 시간에 이벤트를 전달해야하기 때문에 안정성도 제일 높은 카프카가 중요하다고 판단했음.
당장 중요한 건 아닌데 확장성도 챙길 수 있다.

카프카 재고 임계값을 보내는 이벤트
쿠폰 발급도 파서 그냥 보내면 될듯?

확인 결과, 이미 카프카 스트림즈가 있다.

사실 Redis Zset(Sorted Set)이 더 간단한 해결책일 수 있다.
그러나 현재 Redis는 캐시 저장소로 사용하고 있음. 아키텍처가 모놀리식 서버이고, 추가적으로 Pub/Sub 패턴을 사용하기 위해 증설하기엔 비용과 시간에 무리가 있기 때문에 기존에 존재하던 Kafka를 선정한 것임.

평균/최대 지연 시간은 정해지지 않았으나, 최소 시간은 3시간이며 최대 시간은 5일로 예상됨.

이 도메인은 이커머스이며 쿠폰을 잘 발행하지 않을 것으로 예상됨. 쿠폰을 삭제해야 되는 이벤트이므로, 가장 빈번한 시나리오를 잡아도 하루에 4~5번임.

Kafka Streams는 대용량 처리 작업이기 때문에 이런 초저용량 작업에는 비 효율적이다.
인프라 변경을 최소화한다면 스프링 스케줄러와 DB를 활용하는 방법 존재.

---

# 피드백
회의록 - 질문 사항에 붙어있음.

민성님 질문.
동적 스레드 풀로 유동적이게 조절하고 있는데 실무는 어떻게 해결하는지?

트래픽은 예상하기 어렵다. 못함

스케일링은 손댄적 있지만 스레드는 해본적없음.
어플리케이션이 아니라 인프라적인 면에서 개선 접근을 해야 한다.
서버 자체를 여러개 더 띄우는 것이 더 효과적.
코어 몇 개 늘어난다고 성능이 높아지진 않음.

ML 서버도 많아서 하드한게 있으면 코어 적은 게 좋고..
JSON 상하차만 하면 코어 많은 것도 좋고...

> 성능보다는 I/O 작업을 피하는 등 코드적으로 접근하는 것이 나은지?

네 가장 큰 이점 있을 것.

증권이나 은행 가면 20~30년 전 레거시 코드가 있다.
이런 건 수정할 수 없음. 이럴 바에 컴퓨터 늘리자 라고 하는 것들이 있다.
코드 보수도 몇 억이지만 컴퓨터도 비싸다. 안정성을 봤을 때 서버 늘리는 것이 이득.


준영님

기능에 대한 기준점?
카프카 분산 로그 기반
대용량 트래픽이 있는 곳에서 비용 감수할 만한 곳에서 사용할만한 서비스
큐가 메시지를 못받으면 대참사
SQS는 그런 거 신경 안 써도 된다. 그래서 우리는 SQS 쓰고 있다.

가장 큰 차이점은 푸시 기반이냐 풀 기반이냐?
센더 있으면 넣어두고 컨슈머가 꺼내가는지, 센더가 던지면 컨슈머가 바로 받는지...

Redis pub/sub 사랑했어서 kafka를 많이 사용해보진 못했당

민규님

쿠폰 발급의 유효 시간 설정.
DB에 기록하지 않고 이벤트 형식으로 사용
컨슈머가 지연시켜서 처리한다. 스프링 스케줄러로 하고 있고, 큐 시스템?

쿠폰 발급 API?
쿠폰 자체를 제어 하는 것이 아님.
카프카로 switching을 해주고 있다.
발급에 대한 것을 제어.

이벤트 기반으로 쿠폰을 만료시키고자 함.
실시간 처리가 될 것 같긴 함.

쿠폰 사용 내역, 환불에 대한 기조, DB에 저장만 되어 있다면 좋다. 이것도 생각해봐야 한다.
이거 되게 흥미로운 듯?
이벤트 유실에 대한 것만 걱정하면 됨. 근데 질문과는 동떨어진 얘기

어쨌든 요지는? DB나 레디스 같은 거 썼었다.
쿠폰 로직에다가 무조건 레디스 값 확인을 해라. start end 시간을 확인해봐라.
현재 시간을 확인하는 로직 썼었음. DB랑 레디스가 가장 간단한 방법
제어가 역전이 된 부분. DB 쿼리를 계속 날려야 함. -> 카프카가 뿌려준다.
이전에는 수 십만 쿼리를 던져야 했을 것. 그래서 레디스 -> 다음에 이벤트

스프링 스케줄러? 카프카? pub, sub? 방식은 많다. -> 스케줄러 써도 똑같다.
요즘은 레디스를 해서 어떤게 남아있는지 보기 편해서 많이 쓴다.
지연 이벤트.

메시징 큐는 지연 이벤트 지원할 수는 있지만 그걸 위해서 만드는 건 아님. 노출되는 시간을 바꿔줄 순 있는데 차이점이 있다.
- 컨슈머는 하나가 가져가면 끝난다.
- 메시지는 그대로 있고 100개 서버가 각각 가져가는 식으로 구현 가능.

---

진행 계획?
- 주말까지 민성님이 배포
- 월요일까지 버그잡는 것으로 하기
- 금요일날 민성님 빠짐.

---

after

https://www.reddit.com/r/apachekafka/comments/1fuqvn3/delayed_processing_with_kafka/?tl=ko
- https://www.redpanda.com/guides/kafka-cloud-kafka-timer

카프카 타이머의 중요성

지연 처리를 하려면 시간을 쟤야 한다.
어디서 쟤야 할까? 할 거 많은 백엔드가 하리?
그렇다. 카프카나 메시징 큐 같은 친구들이 시간 쟤서 보관해뒀다가 꺼내는 것이다.

kafka streams를 쓴다.
JVM 진영? 자바 진영에 api 제공해주는 라이브러리다.

context.schedule() 이 타이머 기능을 담당할 듯하다.
processor api? 라고 한다.

