[[Index-structure-introduction]]
원본이 되는 내용

# 데이터베이스 인덱스 for 면접 대비

## 1. 인덱스 기본 개념

인덱스는 테이블의 데이터를 빠르게 검색하기 위해 데이터베이스가 추가적으로 유지하는 자료구조입니다.  
일반적으로 책 뒤에 있는 색인과 비슷한 역할을 하며, 필요한 데이터를 빠르게 찾아갈 수 있도록 도와줍니다.

인덱스의 가장 큰 장점은 **조회 속도가 향상된다**는 점이고, 디스크 랜덤 접근 횟수가 줄어듭니다.  
하지만 단점도 있습니다. 새로운 데이터를 삽입하거나, 값을 수정하거나, 삭제하는 경우에는 인덱스를 유지하기 위해 추가 작업이 필요합니다.  
즉, 쓰기 연산에서는 오히려 부하가 발생합니다. 이러한 작업은 `page split`, 재정렬, 인덱스 유지 비용으로 이어집니다.


> **디스크 랜덤 접근(random access)**
> 인덱스를 사용할 때는 필요한 부분만 읽어오면 충분하지만, 필요한 부분이 디스크 위에 연속적으로 존재하는 경우는 거의 없습니다. 따라서 디스크 헤드(HDD 기준)를 움직여가면서 띄엄띄엄 접근하는 랜덤 액세스 방식을 사용하게 됩니다.
> 
> - 그래서 왜 랜덤 접근인가요???
> 논리적으로는 트리의 루트에서 리프로 순차적으로 따라가지만, 물리적으로는 연속적으로 저장되어 있지 않기 때문에... 랜덤 접근이라고 합니다...
> **대비되는 개념 : 순차 엑세스(Sequential Access)**

> 페이지 스플릿(Page Split / Index Split)
> B 트리를 사용하는 DB의 경우, 페이지(*리프 노드에서 데이터가 물리적으로 저장되는 물리적 저장 단위*)를 통해 데이터에 접근하게 됩니다. 만약 리프 노드의 크기가 커지게 될 때 효율적으로 관리하기 위해 페이지를 분할하는 page split 이라는 행위를 하게 됩니다.

---

## 2. 인덱스 알고리즘

인덱스 알고리즘은 크게 세 가지 정도가 있습니다.
- 해시 알고리즘 (NoSQL에서 주로 사용)
- B-트리 알고리즘 (MySQL에서도 사용하는 방식)
- 프랙탈-트리 알고리즘 (비교적 최근에 나온 알고리즘)

![[B-tree.png]]

MySQL(InnoDB)에서 가장 기본적으로 사용되는 인덱스 알고리즘은 B-Tree의 아종인 **B+Tree**입니다.
B+Tree는 리프 노드에만 실제 데이터가 저장되고, 리프 노드들은 Linked List 형태로 연결되어 있습니다.  
이 구조 덕분에 범위 검색이나 `ORDER BY` 같은 정렬 최적화가 가능하며, 시간 복잡도는 O(log N) 수준으로 안정적입니다.

![[hash table.png]]

반면에, **Hash 인덱스**는 값의 동등 비교, 즉 `=` 연산에는 매우 빠릅니다. 하지만 범위 검색이나 정렬에서 불리합니다.
따라서 Redis나, MySQL의 Memory 엔진처럼 메모리 기반의 특정 엔진에서 주로 사용됩니다.

hash 인덱스 예제
```sql
-- 1. 메모리 엔진으로 테이블 생성
CREATE TABLE user_sessions (
    session_id CHAR(36) NOT NULL, -- UUID 같은 세션 키
    user_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (session_id) USING HASH  -- 해시 인덱스 지정
) ENGINE=MEMORY;

-- 2. 데이터 삽입
INSERT INTO user_sessions (session_id, user_id) VALUES
('550e8400-e29b-41d4-a716-446655440000', 1),
('550e8400-e29b-41d4-a716-446655440001', 2),
('550e8400-e29b-41d4-a716-446655440002', 3);

-- 3. 해시 인덱스는 동등 비교(=)에 특화
SELECT * FROM user_sessions
WHERE session_id = '550e8400-e29b-41d4-a716-446655440001';

-- 4. 해시 인덱스 확인
SHOW INDEX FROM user_sessions;
```

> B-Tree의 장점은 RID(row ID, record ID) 원본을 유지한다는 것입니다.
> 해시와 다르게 PK를 유지하므로 범위 비교, 정렬 등에서 해당 유용하게 사용할 수 있습니다.
---

## 3. 인덱스 유형

인덱스에는 크게 **클러스터 인덱스**와 **보조 인덱스** 두 가지가 있습니다.

- **클러스터 인덱스**는 테이블당 하나만 만들 수 있고, 보통 Primary Key에 의해 결정됩니다.  
리프 페이지 자체가 데이터 페이지이기 때문에 조회 속도가 빠릅니다. 하지만 데이터 변경이 자주 일어나는 경우 성능 저하가 발생할 수 있습니다.
    
- 보조 인덱스(세컨더리 인덱스)는 여러 개를 만들 수 있습니다.  
리프 페이지에는 데이터 자체가 아니라 클러스터 인덱스 키 값이 저장됩니다. 따라서 데이터를 실제로 가져오려면 보조 인덱스를 탐색하고, 거기서 PK를 추출한 뒤 다시 클러스터 인덱스를 탐색하는 과정이 필요합니다. 이를 Bookmark Lookup이라고 부릅니다.  
실무에서 인덱스 튜닝의 대부분은 이 보조 인덱스를 어떻게 설계할 지에 달려 있습니다.

> 참고사항
> 페이지 스플릿은 두 유형에서 모두 일어나며 모두 디스크 I/O가 발생함.
> 그러나 보조 인덱스는 스플릿 시 데이터 페이지를 옮기지 않기 때문에 상대적으로 부담이 덜하다.

![[B-tree-bookmark-lookup.png]]
*보조 인덱스의 Bookmark look up 예시*

### Order by & Group by
INDEX는 ORDER BY와 GROUP BY에도 영향을 끼치는데 다음과 같은 경우에는 INDEX를 타지 않는다.

- ORDER BY 인덱스컬럼1, 컬럼2 : 복수의 키에 대해서 ORDER BY를 사용한 경우
- WHERE 컬럼1='값' ORDER BY 인덱스 컬럼 : 연속하지 않은 컬럼에 대해 ORDER BY를 실행한 경우
- ORDER BY 인덱스컬럼1 DESC, 인덱스컬럼2 ASC : DESC와 ASC를 혼합해서 사용한 경우
- GROUP BY 컬럼1 ORDER BY 컬럼2 : GROUP BY와 ORDER BY의 컬럼이 다른 경우
- ORDER BY ABS(컬럼) : ORDER BY 절에 다른 표현을 사용한 경우

**특수 케이스**
**Group by `col1`, `col2` 와 같은 정렬 시 `(idx_col1)`과 `(idx_col2)`를 사용한 경우**
두 개의 단일 인덱스를 정렬 조건으로 입력 시, 가장 효율적인 인덱스를 하나 선택해 사용하거나 인덱스를 사용하지 않고 별도 정렬 작업(filesort)을 수행하게 됨.
즉, 복합 인덱스가 아닌 이상 단일 인덱스를 사용하는 것과 다름없습니다.

---

## 4. 중요 포인트

> 면접 예상 질문 포인트 (인덱스만)

### 1. 인덱스를 만들면 무조건 성능이 좋아지나요?
그렇지 않습니다. 조회는 빨라지지만 변경 작업에는 부하가 생깁니다. 따라서 읽기 위주의 시스템에서는 인덱스 효과가 크지만, 쓰기 작업이 많은 시스템에서는 오히려 성능이 나빠질 수 있습니다.

### 2. 인덱스가 적용되지 않는 경우는 언제냐?

- **인덱스 컬럼에 함수나 연산을 적용하는 경우**
> 인덱스에 저장된 값은 원래의 형태 그대로이기 때문에, 쿼리에서 인덱스 컬럼에 함수나 연산을 적용하면 인덱스 값이 변형되어 올바른 순서를 찾을 수 없습니다.

**예시 - 함수 및 연산 적용:**
```SQL
-- 인덱스 컬럼에 함수 적용
SELECT * FROM employees WHERE YEAR(hire_date) = 2024;

-- 인덱스 컬럼에 연산 적용
SELECT * FROM products WHERE price * 1.1 > 1000;
```
위 쿼리에서 `hire_date`와 `price` 컬럼에 인덱스가 있더라도, 데이터베이스는 모든 행에 대해 함수나 연산을 수행한 후 조건을 비교해야 하므로 인덱스를 사용할 수 없습니다. 이 경우 **WHERE 절의 조건을 함수나 연산이 없는 형태로** 변경해야 합니다.

**개선된 예시:**
```SQL
-- 날짜 범위로 변경하여 인덱스 사용 유도
SELECT * FROM employees WHERE hire_date >= '2024-01-01' AND hire_date < '2025-01-01';

-- 연산 결과값을 미리 계산하여 인덱스 사용 유도
SELECT * FROM products WHERE price > 1000 / 1.1;
```

- **묵시적 형변환을 사용하는 경우**
> 컬럼의 데이터 타입과 비교 대상의 데이터 타입이 다를 때 데이터베이스가 내부적으로 형변환을 수행합니다. 이 과정에서 인덱스가 무효화될 수 있습니다.

**예시 - 묵시적 형변환**
```SQL
-- 숫자 타입인 user_id 컬럼을 문자열과 비교
SELECT * FROM users WHERE user_id = '123';
```
`user_id` 컬럼이 숫자 타입(`INT`)임에도 불구하고 문자열(`'123'`)과 비교하면, 데이터베이스는 인덱스 키 값들을 모두 문자열로 변환한 후 비교해야 하므로 인덱스를 사용할 수 없습니다.


- **`!=`, `NOT IN`, `NOT LIKE` 같은 부정 비교를 사용하는 경우**
> `!=`, `<>`, `NOT IN`, `NOT LIKE` 와 같은 부정형 조건은 인덱스 검색 범위가 매우 넓어지거나, 인덱스를 사용하는 것보다 전체 테이블을 스캔하는 것이 더 효율적이라고 판단될 수 있습니다.

**예시 - 부정 비교 연산:**
```SQL
-- 부정형 비교
SELECT * FROM orders WHERE status != 'completed';
```
이 쿼리는 `completed` 상태가 아닌 모든 주문을 찾습니다. 만약 `completed` 상태인 주문이 전체의 90%를 차지한다면, 인덱스로 10%의 데이터를 찾는 것이 유리하지만, 반대로 `completed` 상태가 10%에 불과하다면 나머지 90%를 인덱스로 찾는 것보다 테이블 전체를 스캔하는 것이 더 빠를 수 있습니다.


- **와일드카드가 앞에 위치하는 경우**
> `LIKE` 연산에서 와일드카드 문자(`%`)가 검색어의 앞에 위치하면 인덱스의 정렬 순서를 활용할 수 없으므로 인덱스가 사용되지 않습니다.

-> 왜 활용할 수 없나요?
B+Tree는 키 값을 기준으로 정렬되어 있으므로, 검색 시작점을 찾기 위해서는 첫글자부터 일치해야 합니다. 따라서 와일드카드가 앞에 오면 첫 글자가 무엇인지 알 수 없어 정렬된 인덱스를 활용할 수 없어 전체 인덱스를 스캔하거나 전체 테이블을 스캔하게 됩니다

- **예시:**
```SQL
-- 인덱스를 사용하지 않음
SELECT * FROM products WHERE product_name LIKE '%coffee';
```

이 쿼리는 'coffee'로 끝나는 모든 제품을 찾습니다. 인덱스는 'c'로 시작하는 키부터 'f'로 시작하는 키까지의 범위를 찾을 수 없으므로 모든 행을 스캔해야 합니다.

- **데이터 분포도가 낮은 컬럼의 경우**
성별과 같이 전체 데이터에서 선택도(selectivity, 데이터가 중복되지 않는 정도)가 낮을 경우 인덱스를 사용하는 효용성이 떨어집니다.
또한, 선택도가 동일하더라도 각 고유값이 균등하게 분포되어 있는지에 따라서 인덱스 성능이 달라질 수 있습니다.

### 3. 복합 인덱스의 주의사항은 무엇이냐?
복합 인덱스는 왼쪽 우선 규칙(Leftmost Prefix Rule)을 따라야 합니다.  
예를 들어 인덱스가 `(col1, col2, col3)` 순서로 만들어졌다면, `col1`이 반드시 조건절에 포함되어야 인덱스를 제대로 활용할 수 있습니다.

Where 절 예시
- `WHERE col1=…` → OK
- `WHERE col1=… AND col2=…` → OK
- `WHERE col2=…` 단독 → ❌ (col1 없으면 인덱스 무효)

> 복합 인덱스는 카디널리티(고유값 수)가 성능 차이를 만듭니다.
> 따라서 카디널리티가 높은 것을 고려해야 합니다.
> 추가절으로 조건절에서 자주 쓰이는 컬럼이거나, order by / group by 또한 고려할 수 있습니다.

### 4. 커버링 인덱스란 무엇이냐?
쿼리 결과를 인덱스만 보고도 바로 충족시킬 수 있는 경우입니다.  
즉, 실제 데이터 페이지를 읽을 필요가 없고 인덱스에 저장된 값만으로 결과를 반환할 수 있습니다.

> 보조 인덱스의 경우, 클러스터 인덱스를 타야하는 Bookmark Lookup 과정이 있기 때문에 랜덤 접근이 2번 일어나게 됩니다. 그래서 select `*` 쿼리에서 덜 유리하기 때문에 커버링 인덱스 활용 시 이 과정을 생략할 수 있습니다.

### 5. JOIN 최적화
조인 조건에 사용되는 컬럼에 인덱스를 걸어야 합니다. 특히 외래키(FK) 컬럼과 자주 조인되는 PK 컬럼이 대표적입니다.

- **JOIN 동작**은 결국 두 테이블을 연결하기 위해 **공통된 컬럼 값을 비교**하는 작업.
- 인덱스가 없으면 DB는 양쪽 테이블을 전부 스캔하면서 매칭해야 해서 **Nested Loop + Full Scan**으로 느려짐.
- 인덱스가 있으면 옵티마이저가 `Index Nested Loop Join` 같은 효율적인 방식으로 실행할 수 있음.

> 가장 기초적인 내용이지만 내부적으로 어떻게 동작하는 지 이해하는 것도 좋은 포인트가 될 것 같습니다.

> Nested Loop Join (NL Join)
> 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 row를 결합해 원하는 결과를 조합하는 조인 방식
> nested loop + full scan은 2중 for문을 두 DB 전부 조회하는 것으로 이해하면 됩니다.
> **추가 개념 : Hash join, Merge join**

### 6. ORDER BY가 느릴 때는 어떻게 하느냐?
ORDER BY에 사용되는 컬럼이 인덱스에 포함되어 있어야 합니다.  
복합 인덱스를 설계할 때 ORDER BY에서 자주 사용하는 컬럼을 포함시켜주는 것도 좋은 방법입니다.

> 인덱스에 포함된 컬럼 순서대로 `ORDER BY` 하면, DB는 별도의 정렬(filesort) 없이 인덱스 순서대로 읽기만 하면 되므로 성능이 향상됩니다.


---

## 5. 실무적 활용 포인트

실제 실무에서 인덱스를 다룰 때는 다음과 같은 점을 기억해야 합니다.

- `EXPLAIN` 명령어를 통해 실행 계획을 확인하고, 어떤 인덱스가 사용되는지 점검합니다.
    
- 불필요하거나 중복된 인덱스를 제거하면 성능과 저장공간 모두 최적화할 수 있습니다.
    
- 테이블당 인덱스는 4~5개 이상이면 과도한 경우가 많습니다.
    
- 조회 비율이 전체 데이터의 대략적으로 15% 미만일 때 인덱스가 효과적입니다. 그 이상이면 풀스캔이 더 빠른 경우가 많습니다.

> *그림으로 공부하는 오라클 구조 - 스기타 아츠시 외 4인*에서 나온 문장으로 보이며, 이는 랜덤 액세스와 시퀀셜 액세스의 특성에 있습니다.


---

## 핵심 요약

1. 인덱스는 조회 성능을 높이지만, 쓰기 성능을 떨어뜨린다.
    
2. MySQL InnoDB 인덱스는 기본적으로 B+Tree 기반이다.
    
3. 보조 인덱스는 PK를 통해 다시 실제 데이터를 찾기 때문에 Bookmark Lookup이 필요하다.
    
4. 인덱스가 무효화되는 경우를 반드시 숙지해야 한다: 함수/연산, 묵시적 형변환, 부정 조건, LIKE `%`, 낮은 Selectivity.
    
5. 복합 인덱스는 Leftmost Prefix Rule을 따른다.
    
6. 튜닝의 핵심은 EXPLAIN 실행계획 분석과 적절한 보조 인덱스 설계, 그리고 Covering Index 활용이다.
    

# what is this

## filesort

조회된 데이터를 인덱스로 정렬할 수 없을 때, 내부적으로 추가적인 정렬 작업을 수행하는 것을 칭함.

Using temporary와 Using filesort로 나뉜다.


`Using filesort`는 쿼리에서 첫 번째로 조회하는 테이블(**드라이빙 테이블**이라고 한다)에 대해서만 정렬이 필요한 경우이다.

일반적으론 단일 테이블에 대해 실행한 쿼리가 정렬 시 인덱스를 사용하지 못하는 경우 발생한다.

> 이때 SortBuffer로 복사 및 in-place 정렬을 실행하게 된다.

`Using temporary`는 정렬 작업을 위해 임시 테이블이 필요한 경우를 말한다.

인덱스를 통해 정렬을 수행할 수 없거나, `filesort`만으로 정렬을 완료할 수 없는 경우 임시 테이블을 생성해 그곳에 조회된 데이터들을 모두 밀어넣고 정렬하는 작업을 거친다.

# Reference

랜덤 액세스, 순차 액세스
https://0soo.tistory.com/215

디스크 IO, 랜덤 액세스
https://loosie.tistory.com/843

mysql 인덱스?
https://yoon-ssi.tistory.com/131

인덱스 알고리즘의 특징 및 종류
https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

B-tree
https://zorba91.tistory.com/293

B-tree 예제
https://velog.io/@chanyoung1998/B%ED%8A%B8%EB%A6%AC

mysql b-tree
https://mangkyu.tistory.com/286

알아보면 좋은 것들

cardinality와 selectivity의 차이
- https://hbase.tistory.com/195

백엔드 DB 면접 대비
- https://kkoon9.tistory.com/509

면접 대비 - join
- https://one-armed-boy.tistory.com/entry/JOIN-%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84

filesort
https://seongonion.tistory.com/158