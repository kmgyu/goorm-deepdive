성능 향상하는 방법에 대해 알아본다.
완성도 높은 시스템을 개발하려면 기능 외에도 성능, 신뢰성, 보안 등 고려할 요소가 많다. 이 중 성능을 향상시키는 방법을 알아보자.

# 4.1. 시스템 성능

어떤 물건 또는 기계가 성질과 능력치를 말한다. 성능 주체가 시스템이기 때문에 시스템 성능이라는 표현을 자주 사용한다.
시스템이 수행할 수 있는 작업량을 의미하기도 한다. 단위 시간 동안 목표한 작업량보다 더 많이 처리 시, 성능이 좋다고 한다.

모든 시스템이 높은 수준의 성능이 요구되는 것이 아님.
- 적은 사용자는 성능 중요하지 않음.
- 많은 사용자라면, 성능 고려가 필수적

그래서 성능 고민은 주로 대량의 작업을 신속하게 처리하는 시스템을 개발해야 할 때 시작된다.

시스템 성능에서 `시스템`은 하드웨어와 소프트웨어를 아우름.
- 소프트웨어의 성능이 뛰어나더라도 하드웨어가 뒷받침되지 않으면 우수한 성능을 내기 어려움.
- 반대로 하드웨어가 뛰어나더라도 소프트웨어가 활용하지 못하면 무용지물이 됨.


### 동시 사용자의 중요성

동시 사용자에 따라 서버가 할 작업량이 결정된다.
시스템의 사용자가 5000명이라고 해서 전원이 동시에 접속하지는 않는다.
따라서 성능 고민 시 전체 사용자가 아닌, 시스템 실제 접속하는 동시 사용자를 고려해야 한다.

서버에 요청을 보내거나, 응답을 기다리거나, 응답 결과를 읽는 사람 모두 동시 사용자에 포함된다.

### **어떻게 알아낼까?**

보통은 현재 운영 시스템의 로그를 분석해 동시 사용자 수를 가늠한다.
신규 시스템의 경우, 합리적인 방법으로 계산한다.
- 유사 시스템의 동시 사용자 수 분석
- 서비스 가입자 수 고려, 동시 사용자 수 예측

### **추천하는 도구**

구글 애널리틱스
웹사이트 트래픽 분석에 유용
웹사이트 속도도 확인 가능. 페이지 로딩 시간, 서버 응답 시간, 페이지 다운로드 시간 등 여러 지표로 웹사이트 속도를 가시화한다.


응답 시간은 시스템 성능에서 매우 중요한 요소 중 하나이다.
응답시간 : 사용자가 서비스 요청 시점부터, 서버가 요청 처리 후 사용자에게 도달하기까지 걸리는 시간

구글은 응답시간을 2초 이내로 유지하는 것을 권장함.

---

# 4.2. 병목지점

시스템이 느려지는 지점


```
인터넷 - 방화벽 - L4 스위치 - 방화벽 - Web Server - 방화벽 - WAS - DB Server
```
웹 시스템의 구성도 예시

시스템을 구성하는 서버들 중 하나라도 느리게 동작한다면 전체적인 웹 서비스 속도에 지장을 준다.

### **시스템 성능 측정**

시스템 성능이 느려지는 요소는 소프트웨어 뿐이 아니다., 하드웨어 자원 부족으로 인해 느려질 수도 있다. 따라서 각 서버의 cpu, 메모리 등 자원 사용률을 측정하는 것은 성능 분석의 첫 번째 단계이다.

시스템 성능이 떨어질 경우, 병목 지점을 찾아내기 위해 성능 시험을 시행해 각 서버의 성능을 진단한다.
목적에 따라 부하 시험, 스트레스 시험, 스파이크 시험 등으로 분류된다.

> **부하시험 (workload test)**
> 시스템에 작업을 많이 던져서 감당할 수 있는지 확인하는 시험
> 작업량은 시스템 사용 환경, 사용자 인원, 작업 종류 등에 따라 바뀜.
> i.e. 출퇴근 시스템의 경우 출근 및 퇴근 시 동시 접속자 수가 폭증하며 사용자 수가 동시 접속자와 근사할 수 있다.

성능 시험에서는 테스트를 위해 가상 사용자를 만든다. 실제 사용자처럼 웹 페이지에서 입력 필드에 값을 넣거나, 링크를 클릭하는 등의 작업을 통해 서버에 부하를 가한다.
Jmeter와 LoadRunner가 대표적이며, 이에 대해 6장에서 언급한다고 함.


### **성능 측정을 위한 지표**

대표적 지표 
- 응답 시간
- 처리량
- CPU
- 메모리 사용량

> 처리량?
> 단위 시간 동안 처리하는 작업량
> 단위 : TPS (Transaction Per Second)

트랜잭션 단위는 어떻게 정의하느냐에 따라 달라진다.
(1장에서도 언급했다는 데 직접적인 표현을 확인하지 못함. 그냥 트랜잭션 크기 말하는 것 같음...)
시스템이 초당 트랜잭션을 얼마나 많이 처리하는 지 확인하고, 목표 성능을 충족하는 지 확인하는 것이 성능 시험의 일반적 흐름

TPS가 증가하지 않고 정체되거나 감소하는 상태에서는 그 원인을 파악해야 한다.
하드웨어 자원이 부족해도 성능 하락의 원인이 되므로, 자원 사용량 관찰이 우선. 자원 부족의 경우 장비 추가 또는 부품을 증설하여 해결함.

자원 사용량은 모니터링 도구를 사용해 관찰함.
윈도우 기반 운영체제의 경우, 리소스 모니터 사용.
리눅스는 vmstat 같은 도구를 사용한다. 이 도구는 자원 사용량 측정 결과를 텍스트 파일로 저장해 엑셀 등을 사용해 성능 추이를 그래프로 가시화할 수 있다.


위와 같이 각 서버 TPS, 응답 시간, 자원 사용률을 측정해 시스템의 병목 지점을 찾게 된다. 그 다음 시스템을 느리게 만든 원인을 찾는다.
책에서는 메모리 검출 도구를 활용하는 방법은 매우 유용한 방법이라고 소개함.

---
# 4.3 클라우드 서비스 - 오토 스케일링

### **클라우드 서비스의 개념**

먼저 ISO/IEC 22123-1에서는 클라우드 컴퓨팅을 다음과 같이 정의한다.
```
주문형 셀프 서비스 프로비저닝 및 관리를 통해 공유 가능한 물리적 또는 가상 리소스 확장 가능하고 탄력적인 풀에 대한 네트워크 액세스를 가능케 하는 패러다임
```
ISO/IEC 22123-1는 용어집으로 구성되어있으며, 구매해야 한다...
원문은 책에 있다.

주요 개념
- 클라우드 컴퓨팅 기술이 가상화한 컴퓨팅 자원을 공유 풀 형태로 사용자에게 제공
- 셀프 서비스
  클라우드 컴퓨팅 서비스는 관리 최소화를 위해 많은 부분을 자동화한다.
  따라서 버튼 클릭만으로 서버, 네트워크, 스토리지 등을 구축하는 장점이 존재한다.
- 확장 가능하고 탄력적인 풀
  탄력적이고 빠른 자원 확장이 가능하기 때문에 필요한 자원만 필요한 양만큼 탄력적으로 골라 사용할 수 있다.

### **클라우드 컴퓨팅의 특징**

*뒷 부분 안읽고 급발진했다가 탄력성 설명하길래... 그냥 내가 조사한 것과 대조해서 좋은 것들만 넣었다.*

> 간단하게 설명하는 책에서 소개하는 탄력성(elasticity)의 의미
> - **자동 확장/축소**  
    예를 들어 사용자가 갑자기 몰려 서버 부하가 높아지면, 클라우드 플랫폼이 자동으로 가상머신이나 컨테이너를 늘려준다. 반대로 트래픽이 줄어들면 필요 없는 인스턴스를 줄여 비용을 절감한다.
>- **실시간 대응**  
    수요 변화가 하루 단위, 시간 단위가 아니라 **분 단위**로 발생해도 대응할 수 있다. 즉, 자원 할당이 고정적이지 않고 필요에 따라 유동적으로 변한다.  
>- **사용자 관점**  
    사용자는 별도의 하드웨어 증설이나 네트워크 장비 설치 없이, 콘솔 클릭이나 API 호출만으로 자원을 확보할 수 있다.

확장 가능성(scalability)과의 차이
- **확장 가능성**: 자원을 늘릴 수 있는 구조적 가능성  
    (예: 서버를 10대에서 100대로 늘릴 수 있는 아키텍처)
- **탄력성**: 실제로 그 확장을 **자동**으로, **필요할 때 즉시** 적용할 수 있는 성질  
    (예: 트래픽이 몰리면 서버를 자동으로 100대까지 늘리고, 다시 줄일 수 있음)



클라우드 컴퓨팅의 탄력성을 성능 관점에서 살펴본다.

성능 요구사항이 기존에 1000명의 요청을 1초 내에 처리했었다. 인기가 많아진다면 그만큼 성능 향상이 필요할 것임. 이때, 하드웨어 스펙을 올리거나(스케일 업) 새로운 하드웨어를 추가하는 방식(스케일 아웃)으로 시스템을 확장할 수 있다.

시스템 확장은 메모리 구입 후 서버에 장착하고, 장비에 도입해 구축하는 등 시간과 노력을 요하는 작업이다. 확장성은 시스템 사양과 규모를 단계적으로 변경하는 작업이라고 할 수 있음.
클라우드 컴퓨팅은 이런 확장성을 빠르게 지원한다는 것임.
부하량에 따라 시스템 자원을 동적 할당하도록 한다.
이런 탄력성 덕분에 비용도 저감할 수 있다.

### 오토 스케일링

자원 사용량에 따라 여러 대의 서버를 자동으로 확장 또는 축소하는 기술

AWS는 오토 스케일링 그룹을 통해 오토 스케일링을 설정한다.
오토 스케일링 그룹에 다수의 인스턴스를 등록 후, 최소 인스턴스와 확장 가능한 인스턴스를 설정하면 사용량에 따라 대기 자원과 사용 자원을 자동으로 할당한다.
동적으로 인스턴스를 추가하거나 제외하는 조건 설정도 가능하다.
i.e. CPU 사용률이 30%일 경우 1개, 80% 이상일 경우 8개 추가 등...
이때 인스턴스 8개로 부하를 감당하지 못해도 인스턴스를 추가할 수 없다.
따라서 부하 최대치를 예측하여 그룹의 인스턴스 개수를 적절하게 설정하는 것이 중요하다고 한다.
확장 조건은 직접 설정히므로 잘못된 부하 조건을 설정하지 않으려면 성능 개념을 충분히 이해할 필요가 있다고 한다.

# 4.4 성능을 고려한 5가지 개발 팁

### 과도한 로그 기록 지양

많은 경우 시스템 에러 분석 등의 디버깅을 목적으로 로그를 남긴다.
메모리 구조 상에서 디스크 속도가 가장 느리다는 점을 고려하면 로그 기록은 되도록 하지 말아야 할 작업 중 하나다.
시스템 사용자가 많아져 서버 처리 작업이 늘어날 수록, 로깅도 성능에 영향을 주기 때문이다.
디스크에 데이터를 쓰는 작업중에는 CPU를 사용하지 못한 다는 것을 항상 기억하라. 빠른 성능을 보장해야 하는 시스템에서는 작업 처리 지연 요소인 디스크 쓰기 작업을 가능한 줄이는 것이 성능의 관건이 된다.

### 불필요한 데이터는 조회하지 마라

DBMS는 데이터를 전담하여 관리하는 소프트웨어이고, 데이터는 디스크에 저장된다. 필연적으로 디스크 사용량이 많아지는데, 시스템 병목은 디스크 읽기/쓰기 작업에서 나타날 가능성이 높다.
그렇기 때문에 효율적인 쿼리 쓰기가 중요해지는 것이다.

책에서는 전체 쿼리 검색을 소개했다.
```sql
--비효율적 쿼리
select * from item where item='신발';

--페이지네이션
select * from item where item='신발' limit 10, 20;
```
화면에 출력하지도 않을 데이터 빼오지 말라는 소리다.

*그렇다면 특정 컬럼만 빼오는 것도 디스크 I/O에 영향이 갈까?*
내 생각에 큰 영향은 없을 것 같다. RDBMS의 경우 대부분이 행 단위로 저장할텐데 일렬로 나열된 정보를 가져오는 것과 몇 개만 선택하는 경우 큰 차이는 없을 것 같다.
-> **디스크 I/O에서는 차이가 없다.**
하지만 쿼리 최적화 / 네트워크 / 메모리 처리 단계에서 차이가 발생한다.
DBMS에서 메모리로 로드 및 네트워크로 전달하고, 받을 때의 오버헤드가 줄어든다. TEXT나 BLOB같은 대용량 데이터를 매번 가져온다고 생각해보자. 끔찍하다!
쿼리 캐시나 정렬, 조인에서 다루는 데이터가 줄어드니 메모리와 CPU 측면에서도 비용 절감이 된다고 할 수 있다.
물론 열지향에서는 디스크 I/O에도 영향이 간다! 디스크 I/O 측면만 생각했었는데 다른 자원에도 영향이 갔다. 시각을 넓혀야 할 듯...


### 고해상도 이미지 사용 금물

웹 페이지에서 이미지가 차지하는 비중은 크다. 그래서 고해상도 이미지의 크기를 줄이지 않고 그대로 사용 시 이미지 크기가 성능 저하의 원인이 되기도 한다.
4K 고해상도 이미지는 약 5mb 이상인데, 웹페이지에 이런 것을 10개만 넣어도 50mb이다. 그런데 동시에 100명이 사용한다면 서버는 최소 5GB의 데이터를 전송하는 것이다.
일반적으로 우리가 보는 웹페이지에서는 고해상도 이미지가 필요하지 않다.
따라서 이미지 해상도를 크기에 맞게 변경하는 것이 좋다.
4K 고해상도 이미지를 800x600 이미지로 변경하면 200kb로 줄어들어 응답 시간이 감소한다.
압축률이 좋은 이미지 포맷도 최적화의 고려사항 중 하나이다. 이런 이유로 많이 사용하는 이미지 포맷은 jpeg, png, Webp이다.

### HTML, CSS, JS 파일 압축

시스템 성능을 높이는 가장 좋은 방법은 디스크 I/O를 줄이는 것이다.
사용자가 특정 웹 페이지 요청 시, 서버는 웹 페이지를 구성하는 HTML, CSS, JS 등의 파일을 디스크에서 로드한다.
다수 사용자가 동시에 같은 파일을 요청 시 디스크 I/O 횟수가 증가하므로 성능에 영향을 줄 수 있다. 시스템 성능 고려 시 디스크 I/O 횟수를 줄이는 방향으로 개발해야 한다. 따라서 HTML, CSS, JS 파일을 압축해 사용해야 한다.

> *압축한 html, css, js를 캐시로 드셔보시겠습니까?*
> nginx, 아파치 등의 웹 서버에서는 gzip, Brotli 등의 방식으로 정적 리소스를 압축해 클라이언트로 전송할 수 있다. 이때 압축은 CPU에서 시행되며, 이 압축 결과를 캐시하거나 미리 준비해둔다. (많은 웹서버에서 이렇게 한다고 함.)
> 아파치 톰캣의 경우, 실시간 압축은 기본 제공하나 static gzip 파일 서빙 기능은 없어 리버스 프록시(Nginx, CDN 등)에서 캐싱을 담당하게 한다.
> 이 압축하는 것도 FE 빌드 툴인 Webpack, Vite, CRA, Next.js 등으로 개발자가 직접 명령어로 압축시키거나 웹 서버가 런타임에 압축할 수 있다!!!


### 웹 캐시 적극 활용

데이터를 임시 저장하는 캐시는 속도를 개선하는 일반적인 방법이다.
웹 서비스에서도 같은 목적으로 캐시를 사용한다. 서비스에 필요한 데이터가 캐시에 저장되어있다면 디스크에서 데이터를 가져오는 수고가 줄어 속도가 빨라질 것이다.
앞서 설명했던 이미지 최적화, 파일 압축 등이 네트워크 트래픽 양을 줄여 성능을 개선한다면, 브라우저 캐시는 전송되는 트래픽 건수를 줄어 성능을 개선하는 방법이다.
브라우저 캐시를 사용하기 위해서는 Cache-Control 헤더를 HTTP response 헤더에 추가해야 한다. 책에서는 이중 몇가지를 소개한다.

1. max-age
해당 파일의 캐시 유효 시간이다. 단위 시간은 초이다.

동작 방식
max-age 기간동안 캐시된 리소스(파일)은 신선하다고 간주한다.
이 기간 동안 브라우저는 서버에 확인하지 않고 캐시를 그대로 사용한다.
설정된 시간이 지나면 캐시는 만료되며, 서버와 통신한다.

서버 파일 업데이트 됨, 만료 시간 전
브라우저는 캐시된 파일을 계속 사용
서버에 새 파일이 있어도 반영되지 않는 이슈 존재.

만료 시간이 지난 후
브라우저는 서버에 재검증 요청을 보냄.
서버
- 파일 업데이트가 된 경우, 200 OK 및 새 파일 쏴줌
- 변경 없을 경우, 304 헤더만 전송


만약 파일 변경 시 새 파일을 다운로드해 캐시로 저장하고 유효기간을 지정된 max-age로 재설정한다. 바뀌지 않은 경우, 현재 파일의 유효기간을 max-age로 재설정한다.

0일 경우, 캐시는 즉시 만료되며 매번 서버에 확인하도록 요청한다.

따라서 max-age의 간격도 중요하다. 서버에 새 파일이 있어도 반영되지 않는 이슈가 생길 수 있기 때문..
이 때문에 브라우저에 캐시된 이미지 및 파일 삭제 기능이 존재하기도 한다.
그러므로 잦은 변경에 예상되는 파일은 되도록 짧게 설정하는 것이 좋다고 한다.

gpt 및 구글링
> 서버에 새 파일이 있어도 반영되지 않는 이슈를 계속 생각해보자.
> 캐시 수명만으로 이걸 해결하는 것은 너무 한정적이다. 따라서 해결 방법은 다음과 같다.
> 1. 캐시 버스팅
> 파일명 변경 시 브라우저는 새로운 리소스로 인식한다.
> 배포마다 html이 새 파일명을 가리키므로, max-age가 남아 있어도 새 캐시로 즉시 교체된다.
> 2. html과 정적 자산 캐시 정책 분리
> no-cache + ETag로 사용 전 항상 재검증 또는 아주 짧은 max-age
> js/css/이미지 : 파일명 해시 + 긴 max-age + immutable
> 이 경우 html만 재검증하여 최신 번들 파일명을 받아오고, 나머지는 길게 캐시하게 된다.
> 3. 조건부 요청
> no-cache + ETag/Last+Modified를 사용 시 브라우저는 매번 서버에 확인하고 바뀌지 않으면 304로 응답한다.
> max-age가 남아있으면 재검증을 안 하므로, 항상 확인해야 할 시 no-cache를 사용해야 한다.
> 4. 실시간 알림으로 강제 갱신 유도
> WebSocket/SSE/웹 푸시 등으로 버전 변경 이벤트를 보내 클라이언트가 스스로 재요청하게 만들 수 있다.
> 서비스 워커 사용 시 캐시 정책을 코드로 제어해 배포 시점에 프로그램적 무효화도 가능하다고 한다...?
> 5. 프록시, CDN 캐시 무효화
> 공유 캐시는 API로 퍼지가 가능하다고 함.
> 퍼지 후 새 응답 가면 html이 새 번들 url을 가리켜 브라우저 측도 자연히 교체된다.


2. no-cache
파일을 캐시하지만 항상 캐시 파일 최신 여부를 확인하는 요청을 웹 서버에 보낸다.

3. no-store
파일을 캐시에 저장하지 않는다.
보안이 요구되는 중요한 파일의 경우 이 옵션으로 파일을 캐시하지 않도록 설정한다.


캐시에 대한 추가자료
[웹 브라우저의 캐시 전략](https://inpa.tistory.com/entry/HTTP-%F0%9F%8C%90-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%BA%90%EC%8B%9C-%EC%A0%84%EB%9E%B5-Cache-Headers-%EB%8B%A4%EB%A3%A8%EA%B8%B0#%ED%94%84%EB%A1%9D%EC%8B%9C_%EC%BA%90%EC%8B%9C_%ED%97%A4%EB%8D%94)